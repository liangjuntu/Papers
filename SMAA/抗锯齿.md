# 抗锯齿



## 背景

需求是想要优化G58的神器使展示，降低人物模型的锯齿感。

本来Forward管线采用MSAA是好的选择，但是G58的外放包引擎有BUG，MSAA开不起来，所以为了能够在不强迫玩家更包的情况下加上抗锯齿，需要绕一下。



### FXAA

首先选择尝试的是FXAA，一方面由于后处理抗锯齿能够非常简单的添加到当前的渲染框架中，另一方面在于它的开销比较低，满足移动平台的性能要求。

但是，FXAA的缺点是会让画面整体变的模糊，由于边缘检测可能会把贴图的颜色变化错分为边缘。

[截图]

同时它的边缘方向只有水平和垂直方向，对于斜45度角的锯齿效果不好。



![image-20191224170627136](E:\Papers\SMAA\抗锯齿\image-20191224170627136.png)

所以改为尝试传说中消耗更高但效果也更好的SMAA。

### SMAA



SMAA发展自Jimenez's MLAA，其中S和M分别是Subpixel和Morphological的缩写。SMAA的改进是基于多种抗锯齿技术的融合，有多个变种：SMAA 1x，SMAA S2x，SMAA T2x和SMAA 4x。[具体原理见另一篇]()。

其中SMAA 1x，是对MLAA算法的改进，也是后处理，方便嵌入。并且听说其性能消耗是FXAA的2倍，感觉可以一试。



[效果图]

可见锯齿消弱了，并且没FXAA那么模糊，同时斜45度角也有效。

![image-20191225111250661](E:\Papers\SMAA\抗锯齿\image-20191225111250661.png)

![image-20191225111114954](E:\Papers\SMAA\抗锯齿\image-20191225111114954.png)









## MSAA

g58neox2可以开启MSAA，效果的话MSSA 2x < SMAA 1x < MSAA 4x，附一下MSAA的效果做对比



最后附上测试数据 

### 性能测试



另外，SMAA需要3个PASS

1. 基于原图做边缘检测，生成edgeTex
2. 根据edgeTex计算weightTex
3. 用weightTex混合原图

其中Pass2的计算只需在Pass1中判断为边缘的像素进行，从而可以通过Stencil Test来过滤掉非边缘的像素，减少PASS2的消耗。而在神器使界面，边缘像素的占比不多，所以性能提升还是挺明显的。



iOS测试基于Iphone6，A9处理器，屏幕1334*750分辨率，XCode

Android测试基于小米8， 骁龙845处理器，屏幕2248*1080分辨率, RenderDoc

| 耗时：单位ms | FXAA | SMAA 1x | SMAA 1x Stencil |
| ------------ | ---- | ------- | --------------- |
| iOS          | 4.13 | 5.3     | 4.67            |
| Android      | 5.27 | 10.35   | 6.63            |



MSAA的消耗分散到各个Pass中，没法具体测量，下表是开启前后的一帧总耗时和时间差(只测了Android的)

| 总耗时/时间差：单位ms    | 0x   | 2x       | 4x        |
| ------------------------ | ---- | -------- | --------- |
| 神器使界面（DrawCall少） | 13.8 | 15.4/1.6 | 18.8/5.0  |
| 主城（DrawCall多）       | 23.5 | 32.1/8.6 | 47.0/23.5 |



MSAA 4x效果虽好，随着DrawCall数增多，消耗也很惊人，特别是像主城。

## 其他

问题还没有完全解决：neox1的后处理只能够对场景的渲染结果做抗锯齿，但是项目中还存在一些渲染到UI上的模型(先渲染到RT，再作为UI的贴图)，例如剧情对话中的神器使，前面的方法对它们不起效。

最省的方法是把后处理抗锯齿移到画完UI后再跑，但是UI会跟着变模糊，行不通。

同样在不需要更引擎的条件下，想到了两种方法：

1. 方法一是提高一倍RT的分辨率到2048，再对UI的Sprite做0.5缩放，做双线性采样，相当于做了4xSSAA，效果很好，但是坏处是RT内存变为4倍了。
2. 方法二是对RT做一次后处理，但是neox1没有提供对RT做过滤(RT渲染到RT，类似Unity的Blit)的方法，不过发现cocos可以指定只有某个UI渲染到RT，那么就可以绕一下：让原来的RT经过一个隐藏的UI Sprtite渲染到新的RT2，让RT2作为原UI的贴图；而在这个UI Sprite里可以指定任意的shader，模拟了RT过滤。虽然效果没有方法一好，但好处是内存少一半，锯齿感也有减少 。不过这里用的是FXAA，因为SMAA需要3个Pass，额外多2个RT，消耗赶上方法一了，不划算。

简单的测试了一下性能

| 耗时：单位ms | 方法一 | 方法二 |
| ------------ | ------ | ------ |
| iOS(A9)      | 5~8    | 5      |
| Android(845) | 3~6    | 5      |

FXAA方法消耗高，效果还不好，感觉很不划算。后来想了下，其实方法一不需要整倍的提升分辨率，只要比原来的分辨率大就有Subpixel抗锯齿的效果。所以试了下1.5倍分辨率的RT：发现不单效果比FXAA好不少，并不模糊。时间消耗还比FXAA少。而内存消耗1.5x1.5=2.25，只比FXAA多1M。

所以这是直观和实践相反的案例，SSAA不是不能用，要看用的场合，而这里由于RT渲染的东西不多，只有角色模型，消耗反而比传统方法的要少。

最后的解决方案是分别把分辨率提升2倍和1.5倍作为齿高配和低配，实现简单，效果又好。



## 参考

https://zhuanlan.zhihu.com/p/84434802

![image-20191224155129439](E:\Papers\SMAA\抗锯齿\image-20191224155129439.png)



![image-20191225113605534](E:\Papers\SMAA\抗锯齿\image-20191225113605534.png)

