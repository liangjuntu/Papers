#line 1 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 7 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 1 "Common.ush"
#line 13 "/Engine/Private/Common.ush"
#line 1 "/Engine/Public/Platform.ush"
#line 9 "/Engine/Public/Platform.ush"
#line 1 "FP16Math.ush"
#line 10 "/Engine/Public/Platform.ush"
#line 41 "/Engine/Public/Platform.ush"
#line 1 "ShaderVersion.ush"
#line 42 "/Engine/Public/Platform.ush"
#line 577 "/Engine/Public/Platform.ush"
float min3( float a, float b, float c )
{
	return min( a, min( b, c ) );
}

float max3( float a, float b, float c )
{
	return max( a, max( b, c ) );
}

float2 min3( float2 a, float2 b, float2 c )
{
	return float2(
		min3( a.x, b.x, c.x ),
		min3( a.y, b.y, c.y )
	);
}

float2 max3( float2 a, float2 b, float2 c )
{
	return float2(
		max3( a.x, b.x, c.x ),
		max3( a.y, b.y, c.y )
	);
}

float3 max3( float3 a, float3 b, float3 c )
{
	return float3(
		max3( a.x, b.x, c.x ),
		max3( a.y, b.y, c.y ),
		max3( a.z, b.z, c.z )
	);
}

float3 min3( float3 a, float3 b, float3 c )
{
	return float3(
		min3( a.x, b.x, c.x ),
		min3( a.y, b.y, c.y ),
		min3( a.z, b.z, c.z )
	);
}

float4 min3( float4 a, float4 b, float4 c )
{
	return float4(
		min3( a.x, b.x, c.x ),
		min3( a.y, b.y, c.y ),
		min3( a.z, b.z, c.z ),
		min3( a.w, b.w, c.w )
	);
}

float4 max3( float4 a, float4 b, float4 c )
{
	return float4(
		max3( a.x, b.x, c.x ),
		max3( a.y, b.y, c.y ),
		max3( a.z, b.z, c.z ),
		max3( a.w, b.w, c.w )
	);
}
#line 14 "/Engine/Private/Common.ush"
#line 55 "/Engine/Private/Common.ush"
#line 1 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/View.ush"


cbuffer View
{
	float4x4 View_TranslatedWorldToClip;
	float4x4 View_WorldToClip;
	float4x4 View_ClipToWorld;
	float4x4 View_TranslatedWorldToView;
	float4x4 View_ViewToTranslatedWorld;
	float4x4 View_TranslatedWorldToCameraView;
	float4x4 View_CameraViewToTranslatedWorld;
	float4x4 View_ViewToClip;
	float4x4 View_ViewToClipNoAA;
	float4x4 View_ClipToView;
	float4x4 View_ClipToTranslatedWorld;
	float4x4 View_SVPositionToTranslatedWorld;
	float4x4 View_ScreenToWorld;
	float4x4 View_ScreenToTranslatedWorld;
	float3  View_ViewForward;
	float  PrePadding_View_908;
	float3  View_ViewUp;
	float  PrePadding_View_924;
	float3  View_ViewRight;
	float  PrePadding_View_940;
	float3  View_HMDViewNoRollUp;
	float  PrePadding_View_956;
	float3  View_HMDViewNoRollRight;
	float  PrePadding_View_972;
	float4 View_InvDeviceZToWorldZTransform;
	float4  View_ScreenPositionScaleBias;
	float3 View_WorldCameraOrigin;
	float PrePadding_View_1020;
	float3 View_TranslatedWorldCameraOrigin;
	float PrePadding_View_1036;
	float3 View_WorldViewOrigin;
	float PrePadding_View_1052;
	float3 View_PreViewTranslation;
	float PrePadding_View_1068;
	float4x4 View_PrevProjection;
	float4x4 View_PrevViewProj;
	float4x4 View_PrevViewRotationProj;
	float4x4 View_PrevViewToClip;
	float4x4 View_PrevClipToView;
	float4x4 View_PrevTranslatedWorldToClip;
	float4x4 View_PrevTranslatedWorldToView;
	float4x4 View_PrevViewToTranslatedWorld;
	float4x4 View_PrevTranslatedWorldToCameraView;
	float4x4 View_PrevCameraViewToTranslatedWorld;
	float3 View_PrevWorldCameraOrigin;
	float PrePadding_View_1724;
	float3 View_PrevWorldViewOrigin;
	float PrePadding_View_1740;
	float3 View_PrevPreViewTranslation;
	float PrePadding_View_1756;
	float4x4 View_PrevInvViewProj;
	float4x4 View_PrevScreenToTranslatedWorld;
	float4x4 View_ClipToPrevClip;
	float4 View_TemporalAAJitter;
	float4 View_GlobalClippingPlane;
	float2 View_FieldOfViewWideAngles;
	float2 View_PrevFieldOfViewWideAngles;
	float4  View_ViewRectMin;
	float4 View_ViewSizeAndInvSize;
	float4 View_BufferSizeAndInvSize;
	float4 View_BufferBilinearUVMinMax;
	int View_NumSceneColorMSAASamples;
	float  View_PreExposure;
	float  View_OneOverPreExposure;
	float  PrePadding_View_2076;
	float4  View_DiffuseOverrideParameter;
	float4  View_SpecularOverrideParameter;
	float4  View_NormalOverrideParameter;
	float2  View_RoughnessOverrideParameter;
	float View_PrevFrameGameTime;
	float View_PrevFrameRealTime;
	float  View_OutOfBoundsMask;
	float  PrePadding_View_2148;
	float  PrePadding_View_2152;
	float  PrePadding_View_2156;
	float3 View_WorldCameraMovementSinceLastFrame;
	float View_CullingSign;
	float  View_NearPlane;
	float View_AdaptiveTessellationFactor;
	float View_GameTime;
	float View_RealTime;
	float View_DeltaTime;
	float View_MaterialTextureMipBias;
	float View_MaterialTextureDerivativeMultiply;
	uint View_Random;
	uint View_FrameNumber;
	uint View_StateFrameIndexMod8;
	uint View_StateFrameIndex;
	float  View_CameraCut;
	float  View_UnlitViewmodeMask;
	float  PrePadding_View_2228;
	float  PrePadding_View_2232;
	float  PrePadding_View_2236;
	float4  View_DirectionalLightColor;
	float3  View_DirectionalLightDirection;
	float  PrePadding_View_2268;
	float4 View_TranslucencyLightingVolumeMin[2];
	float4 View_TranslucencyLightingVolumeInvSize[2];
	float4 View_TemporalAAParams;
	float4 View_CircleDOFParams;
	float View_DepthOfFieldSensorWidth;
	float View_DepthOfFieldFocalDistance;
	float View_DepthOfFieldScale;
	float View_DepthOfFieldFocalLength;
	float View_DepthOfFieldFocalRegion;
	float View_DepthOfFieldNearTransitionRegion;
	float View_DepthOfFieldFarTransitionRegion;
	float View_MotionBlurNormalizedToPixel;
	float View_bSubsurfacePostprocessEnabled;
	float View_GeneralPurposeTweak;
	float  View_DemosaicVposOffset;
	float  PrePadding_View_2412;
	float3 View_IndirectLightingColorScale;
	float  View_HDR32bppEncodingMode;
	float3 View_AtmosphericFogSunDirection;
	float  View_AtmosphericFogSunPower;
	float  View_AtmosphericFogPower;
	float  View_AtmosphericFogDensityScale;
	float  View_AtmosphericFogDensityOffset;
	float  View_AtmosphericFogGroundOffset;
	float  View_AtmosphericFogDistanceScale;
	float  View_AtmosphericFogAltitudeScale;
	float  View_AtmosphericFogHeightScaleRayleigh;
	float  View_AtmosphericFogStartDistance;
	float  View_AtmosphericFogDistanceOffset;
	float  View_AtmosphericFogSunDiscScale;
	uint View_AtmosphericFogRenderMask;
	uint View_AtmosphericFogInscatterAltitudeSampleNum;
	float4 View_AtmosphericFogSunColor;
	float3 View_NormalCurvatureToRoughnessScaleBias;
	float View_RenderingReflectionCaptureMask;
	float4 View_AmbientCubemapTint;
	float View_AmbientCubemapIntensity;
	float View_SkyLightParameters;
	float PrePadding_View_2552;
	float PrePadding_View_2556;
	float4 View_SkyLightColor;
	float4 View_SkyIrradianceEnvironmentMap[7];
	float View_MobilePreviewMode;
	float View_HMDEyePaddingOffset;
	float  View_ReflectionCubemapMaxMip;
	float View_ShowDecalsMask;
	uint View_DistanceFieldAOSpecularOcclusionMode;
	float View_IndirectCapsuleSelfShadowingIntensity;
	float PrePadding_View_2712;
	float PrePadding_View_2716;
	float3 View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int View_StereoPassIndex;
	float4 View_GlobalVolumeCenterAndExtent[4];
	float4 View_GlobalVolumeWorldToUVAddAndMul[4];
	float View_GlobalVolumeDimension;
	float View_GlobalVolumeTexelSize;
	float View_MaxGlobalDistance;
	float View_bCheckerboardSubsurfaceProfileRendering;
	float3 View_VolumetricFogInvGridSize;
	float PrePadding_View_2892;
	float3 View_VolumetricFogGridZParams;
	float PrePadding_View_2908;
	float2 View_VolumetricFogSVPosToVolumeUV;
	float View_VolumetricFogMaxDistance;
	float PrePadding_View_2924;
	float3 View_VolumetricLightmapWorldToUVScale;
	float PrePadding_View_2940;
	float3 View_VolumetricLightmapWorldToUVAdd;
	float PrePadding_View_2956;
	float3 View_VolumetricLightmapIndirectionTextureSize;
	float View_VolumetricLightmapBrickSize;
	float3 View_VolumetricLightmapBrickTexelSize;
	float View_StereoIPD;
	float View_IndirectLightingCacheShowFlag;
	float View_EyeToPixelSpreadAngle;
}
SamplerState View_MaterialTextureBilinearWrapedSampler;
SamplerState View_MaterialTextureBilinearClampedSampler;
Texture3D<uint4> View_VolumetricLightmapIndirectionTexture;
Texture3D View_VolumetricLightmapBrickAmbientVector;
Texture3D View_VolumetricLightmapBrickSHCoefficients0;
Texture3D View_VolumetricLightmapBrickSHCoefficients1;
Texture3D View_VolumetricLightmapBrickSHCoefficients2;
Texture3D View_VolumetricLightmapBrickSHCoefficients3;
Texture3D View_VolumetricLightmapBrickSHCoefficients4;
Texture3D View_VolumetricLightmapBrickSHCoefficients5;
Texture3D View_SkyBentNormalBrickTexture;
Texture3D View_DirectionalLightShadowingBrickTexture;
SamplerState View_VolumetricLightmapBrickAmbientVectorSampler;
SamplerState View_VolumetricLightmapTextureSampler0;
SamplerState View_VolumetricLightmapTextureSampler1;
SamplerState View_VolumetricLightmapTextureSampler2;
SamplerState View_VolumetricLightmapTextureSampler3;
SamplerState View_VolumetricLightmapTextureSampler4;
SamplerState View_VolumetricLightmapTextureSampler5;
SamplerState View_SkyBentNormalTextureSampler;
SamplerState View_DirectionalLightShadowingTextureSampler;
Texture3D View_GlobalDistanceFieldTexture0;
SamplerState View_GlobalDistanceFieldSampler0;
Texture3D View_GlobalDistanceFieldTexture1;
SamplerState View_GlobalDistanceFieldSampler1;
Texture3D View_GlobalDistanceFieldTexture2;
SamplerState View_GlobalDistanceFieldSampler2;
Texture3D View_GlobalDistanceFieldTexture3;
SamplerState View_GlobalDistanceFieldSampler3;
Texture2D View_AtmosphereTransmittanceTexture;
SamplerState View_AtmosphereTransmittanceTextureSampler;
Texture2D View_AtmosphereIrradianceTexture;
SamplerState View_AtmosphereIrradianceTextureSampler;
Texture3D View_AtmosphereInscatterTexture;
SamplerState View_AtmosphereInscatterTextureSampler;
Texture2D View_PerlinNoiseGradientTexture;
SamplerState View_PerlinNoiseGradientTextureSampler;
Texture3D View_PerlinNoise3DTexture;
SamplerState View_PerlinNoise3DTextureSampler;
Texture2D<uint> View_SobolSamplingTexture;
SamplerState View_SharedPointWrappedSampler;
SamplerState View_SharedPointClampedSampler;
SamplerState View_SharedBilinearWrappedSampler;
SamplerState View_SharedBilinearClampedSampler;
SamplerState View_SharedTrilinearWrappedSampler;
SamplerState View_SharedTrilinearClampedSampler;
Texture2D View_PreIntegratedBRDF;
SamplerState View_PreIntegratedBRDFSampler;
StructuredBuffer<float4> View_PrimitiveSceneData;
StructuredBuffer<float4> View_LightmapSceneData;
/*atic const struct
{
	float4x4 TranslatedWorldToClip;
	float4x4 WorldToClip;
	float4x4 ClipToWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToWorld;
	float4x4 ScreenToTranslatedWorld;
	float3  ViewForward;
	float3  ViewUp;
	float3  ViewRight;
	float3  HMDViewNoRollUp;
	float3  HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4  ScreenPositionScaleBias;
	float3 WorldCameraOrigin;
	float3 TranslatedWorldCameraOrigin;
	float3 WorldViewOrigin;
	float3 PreViewTranslation;
	float4x4 PrevProjection;
	float4x4 PrevViewProj;
	float4x4 PrevViewRotationProj;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevWorldCameraOrigin;
	float3 PrevWorldViewOrigin;
	float3 PrevPreViewTranslation;
	float4x4 PrevInvViewProj;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4  ViewRectMin;
	float4 ViewSizeAndInvSize;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	int NumSceneColorMSAASamples;
	float  PreExposure;
	float  OneOverPreExposure;
	float4  DiffuseOverrideParameter;
	float4  SpecularOverrideParameter;
	float4  NormalOverrideParameter;
	float2  RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float  OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float  NearPlane;
	float AdaptiveTessellationFactor;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	float  CameraCut;
	float  UnlitViewmodeMask;
	float4  DirectionalLightColor;
	float3  DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float bSubsurfacePostprocessEnabled;
	float GeneralPurposeTweak;
	float  DemosaicVposOffset;
	float3 IndirectLightingColorScale;
	float  HDR32bppEncodingMode;
	float3 AtmosphericFogSunDirection;
	float  AtmosphericFogSunPower;
	float  AtmosphericFogPower;
	float  AtmosphericFogDensityScale;
	float  AtmosphericFogDensityOffset;
	float  AtmosphericFogGroundOffset;
	float  AtmosphericFogDistanceScale;
	float  AtmosphericFogAltitudeScale;
	float  AtmosphericFogHeightScaleRayleigh;
	float  AtmosphericFogStartDistance;
	float  AtmosphericFogDistanceOffset;
	float  AtmosphericFogSunDiscScale;
	uint AtmosphericFogRenderMask;
	uint AtmosphericFogInscatterAltitudeSampleNum;
	float4 AtmosphericFogSunColor;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightParameters;
	float4 SkyLightColor;
	float4 SkyIrradianceEnvironmentMap[7];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float  ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeCenterAndExtent[4];
	float4 GlobalVolumeWorldToUVAddAndMul[4];
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDistance;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float StereoIPD;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
	SamplerState MaterialTextureBilinearWrapedSampler;
	SamplerState MaterialTextureBilinearClampedSampler;
	Texture3D<uint4> VolumetricLightmapIndirectionTexture;
	Texture3D VolumetricLightmapBrickAmbientVector;
	Texture3D VolumetricLightmapBrickSHCoefficients0;
	Texture3D VolumetricLightmapBrickSHCoefficients1;
	Texture3D VolumetricLightmapBrickSHCoefficients2;
	Texture3D VolumetricLightmapBrickSHCoefficients3;
	Texture3D VolumetricLightmapBrickSHCoefficients4;
	Texture3D VolumetricLightmapBrickSHCoefficients5;
	Texture3D SkyBentNormalBrickTexture;
	Texture3D DirectionalLightShadowingBrickTexture;
	SamplerState VolumetricLightmapBrickAmbientVectorSampler;
	SamplerState VolumetricLightmapTextureSampler0;
	SamplerState VolumetricLightmapTextureSampler1;
	SamplerState VolumetricLightmapTextureSampler2;
	SamplerState VolumetricLightmapTextureSampler3;
	SamplerState VolumetricLightmapTextureSampler4;
	SamplerState VolumetricLightmapTextureSampler5;
	SamplerState SkyBentNormalTextureSampler;
	SamplerState DirectionalLightShadowingTextureSampler;
	Texture3D GlobalDistanceFieldTexture0;
	SamplerState GlobalDistanceFieldSampler0;
	Texture3D GlobalDistanceFieldTexture1;
	SamplerState GlobalDistanceFieldSampler1;
	Texture3D GlobalDistanceFieldTexture2;
	SamplerState GlobalDistanceFieldSampler2;
	Texture3D GlobalDistanceFieldTexture3;
	SamplerState GlobalDistanceFieldSampler3;
	Texture2D AtmosphereTransmittanceTexture;
	SamplerState AtmosphereTransmittanceTextureSampler;
	Texture2D AtmosphereIrradianceTexture;
	SamplerState AtmosphereIrradianceTextureSampler;
	Texture3D AtmosphereInscatterTexture;
	SamplerState AtmosphereInscatterTextureSampler;
	Texture2D PerlinNoiseGradientTexture;
	SamplerState PerlinNoiseGradientTextureSampler;
	Texture3D PerlinNoise3DTexture;
	SamplerState PerlinNoise3DTextureSampler;
	Texture2D<uint> SobolSamplingTexture;
	SamplerState SharedPointWrappedSampler;
	SamplerState SharedPointClampedSampler;
	SamplerState SharedBilinearWrappedSampler;
	SamplerState SharedBilinearClampedSampler;
	SamplerState SharedTrilinearWrappedSampler;
	SamplerState SharedTrilinearClampedSampler;
	Texture2D PreIntegratedBRDF;
	SamplerState PreIntegratedBRDFSampler;
	StructuredBuffer<float4> PrimitiveSceneData;
	StructuredBuffer<float4> LightmapSceneData;
} View = { View_TranslatedWorldToClip,View_WorldToClip,View_ClipToWorld,View_TranslatedWorldToView,View_ViewToTranslatedWorld,View_TranslatedWorldToCameraView,View_CameraViewToTranslatedWorld,View_ViewToClip,View_ViewToClipNoAA,View_ClipToView,View_ClipToTranslatedWorld,View_SVPositionToTranslatedWorld,View_ScreenToWorld,View_ScreenToTranslatedWorld,View_ViewForward,View_ViewUp,View_ViewRight,View_HMDViewNoRollUp,View_HMDViewNoRollRight,View_InvDeviceZToWorldZTransform,View_ScreenPositionScaleBias,View_WorldCameraOrigin,View_TranslatedWorldCameraOrigin,View_WorldViewOrigin,View_PreViewTranslation,View_PrevProjection,View_PrevViewProj,View_PrevViewRotationProj,View_PrevViewToClip,View_PrevClipToView,View_PrevTranslatedWorldToClip,View_PrevTranslatedWorldToView,View_PrevViewToTranslatedWorld,View_PrevTranslatedWorldToCameraView,View_PrevCameraViewToTranslatedWorld,View_PrevWorldCameraOrigin,View_PrevWorldViewOrigin,View_PrevPreViewTranslation,View_PrevInvViewProj,View_PrevScreenToTranslatedWorld,View_ClipToPrevClip,View_TemporalAAJitter,View_GlobalClippingPlane,View_FieldOfViewWideAngles,View_PrevFieldOfViewWideAngles,View_ViewRectMin,View_ViewSizeAndInvSize,View_BufferSizeAndInvSize,View_BufferBilinearUVMinMax,View_NumSceneColorMSAASamples,View_PreExposure,View_OneOverPreExposure,View_DiffuseOverrideParameter,View_SpecularOverrideParameter,View_NormalOverrideParameter,View_RoughnessOverrideParameter,View_PrevFrameGameTime,View_PrevFrameRealTime,View_OutOfBoundsMask,View_WorldCameraMovementSinceLastFrame,View_CullingSign,View_NearPlane,View_AdaptiveTessellationFactor,View_GameTime,View_RealTime,View_DeltaTime,View_MaterialTextureMipBias,View_MaterialTextureDerivativeMultiply,View_Random,View_FrameNumber,View_StateFrameIndexMod8,View_StateFrameIndex,View_CameraCut,View_UnlitViewmodeMask,View_DirectionalLightColor,View_DirectionalLightDirection,View_TranslucencyLightingVolumeMin,View_TranslucencyLightingVolumeInvSize,View_TemporalAAParams,View_CircleDOFParams,View_DepthOfFieldSensorWidth,View_DepthOfFieldFocalDistance,View_DepthOfFieldScale,View_DepthOfFieldFocalLength,View_DepthOfFieldFocalRegion,View_DepthOfFieldNearTransitionRegion,View_DepthOfFieldFarTransitionRegion,View_MotionBlurNormalizedToPixel,View_bSubsurfacePostprocessEnabled,View_GeneralPurposeTweak,View_DemosaicVposOffset,View_IndirectLightingColorScale,View_HDR32bppEncodingMode,View_AtmosphericFogSunDirection,View_AtmosphericFogSunPower,View_AtmosphericFogPower,View_AtmosphericFogDensityScale,View_AtmosphericFogDensityOffset,View_AtmosphericFogGroundOffset,View_AtmosphericFogDistanceScale,View_AtmosphericFogAltitudeScale,View_AtmosphericFogHeightScaleRayleigh,View_AtmosphericFogStartDistance,View_AtmosphericFogDistanceOffset,View_AtmosphericFogSunDiscScale,View_AtmosphericFogRenderMask,View_AtmosphericFogInscatterAltitudeSampleNum,View_AtmosphericFogSunColor,View_NormalCurvatureToRoughnessScaleBias,View_RenderingReflectionCaptureMask,View_AmbientCubemapTint,View_AmbientCubemapIntensity,View_SkyLightParameters,View_SkyLightColor,View_SkyIrradianceEnvironmentMap,View_MobilePreviewMode,View_HMDEyePaddingOffset,View_ReflectionCubemapMaxMip,View_ShowDecalsMask,View_DistanceFieldAOSpecularOcclusionMode,View_IndirectCapsuleSelfShadowingIntensity,View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight,View_StereoPassIndex,View_GlobalVolumeCenterAndExtent,View_GlobalVolumeWorldToUVAddAndMul,View_GlobalVolumeDimension,View_GlobalVolumeTexelSize,View_MaxGlobalDistance,View_bCheckerboardSubsurfaceProfileRendering,View_VolumetricFogInvGridSize,View_VolumetricFogGridZParams,View_VolumetricFogSVPosToVolumeUV,View_VolumetricFogMaxDistance,View_VolumetricLightmapWorldToUVScale,View_VolumetricLightmapWorldToUVAdd,View_VolumetricLightmapIndirectionTextureSize,View_VolumetricLightmapBrickSize,View_VolumetricLightmapBrickTexelSize,View_StereoIPD,View_IndirectLightingCacheShowFlag,View_EyeToPixelSpreadAngle,View_MaterialTextureBilinearWrapedSampler,View_MaterialTextureBilinearClampedSampler,View_VolumetricLightmapIndirectionTexture,View_VolumetricLightmapBrickAmbientVector,View_VolumetricLightmapBrickSHCoefficients0,View_VolumetricLightmapBrickSHCoefficients1,View_VolumetricLightmapBrickSHCoefficients2,View_VolumetricLightmapBrickSHCoefficients3,View_VolumetricLightmapBrickSHCoefficients4,View_VolumetricLightmapBrickSHCoefficients5,View_SkyBentNormalBrickTexture,View_DirectionalLightShadowingBrickTexture,View_VolumetricLightmapBrickAmbientVectorSampler,View_VolumetricLightmapTextureSampler0,View_VolumetricLightmapTextureSampler1,View_VolumetricLightmapTextureSampler2,View_VolumetricLightmapTextureSampler3,View_VolumetricLightmapTextureSampler4,View_VolumetricLightmapTextureSampler5,View_SkyBentNormalTextureSampler,View_DirectionalLightShadowingTextureSampler,View_GlobalDistanceFieldTexture0,View_GlobalDistanceFieldSampler0,View_GlobalDistanceFieldTexture1,View_GlobalDistanceFieldSampler1,View_GlobalDistanceFieldTexture2,View_GlobalDistanceFieldSampler2,View_GlobalDistanceFieldTexture3,View_GlobalDistanceFieldSampler3,View_AtmosphereTransmittanceTexture,View_AtmosphereTransmittanceTextureSampler,View_AtmosphereIrradianceTexture,View_AtmosphereIrradianceTextureSampler,View_AtmosphereInscatterTexture,View_AtmosphereInscatterTextureSampler,View_PerlinNoiseGradientTexture,View_PerlinNoiseGradientTextureSampler,View_PerlinNoise3DTexture,View_PerlinNoise3DTextureSampler,View_SobolSamplingTexture,View_SharedPointWrappedSampler,View_SharedPointClampedSampler,View_SharedBilinearWrappedSampler,View_SharedBilinearClampedSampler,View_SharedTrilinearWrappedSampler,View_SharedTrilinearClampedSampler,View_PreIntegratedBRDF,View_PreIntegratedBRDFSampler  ,View_PrimitiveSceneData   ,View_LightmapSceneData  */
#line 2 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/DrawRectangleParameters.ush"


cbuffer DrawRectangleParameters
{
	float4 DrawRectangleParameters_PosScaleBias;
	float4 DrawRectangleParameters_UVScaleBias;
	float4 DrawRectangleParameters_InvTargetSizeAndTextureSize;
}
/*atic const struct
{
	float4 PosScaleBias;
	float4 UVScaleBias;
	float4 InvTargetSizeAndTextureSize;
} DrawRectangleParameters = { DrawRectangleParameters_PosScaleBias,DrawRectangleParameters_UVScaleBias,DrawRectangleParameters_InvTargetSizeAndTextureSize*/
#line 3 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/InstancedView.ush"


cbuffer InstancedView
{
	float4x4 InstancedView_TranslatedWorldToClip;
	float4x4 InstancedView_WorldToClip;
	float4x4 InstancedView_ClipToWorld;
	float4x4 InstancedView_TranslatedWorldToView;
	float4x4 InstancedView_ViewToTranslatedWorld;
	float4x4 InstancedView_TranslatedWorldToCameraView;
	float4x4 InstancedView_CameraViewToTranslatedWorld;
	float4x4 InstancedView_ViewToClip;
	float4x4 InstancedView_ViewToClipNoAA;
	float4x4 InstancedView_ClipToView;
	float4x4 InstancedView_ClipToTranslatedWorld;
	float4x4 InstancedView_SVPositionToTranslatedWorld;
	float4x4 InstancedView_ScreenToWorld;
	float4x4 InstancedView_ScreenToTranslatedWorld;
	float3  InstancedView_ViewForward;
	float  PrePadding_InstancedView_908;
	float3  InstancedView_ViewUp;
	float  PrePadding_InstancedView_924;
	float3  InstancedView_ViewRight;
	float  PrePadding_InstancedView_940;
	float3  InstancedView_HMDViewNoRollUp;
	float  PrePadding_InstancedView_956;
	float3  InstancedView_HMDViewNoRollRight;
	float  PrePadding_InstancedView_972;
	float4 InstancedView_InvDeviceZToWorldZTransform;
	float4  InstancedView_ScreenPositionScaleBias;
	float3 InstancedView_WorldCameraOrigin;
	float PrePadding_InstancedView_1020;
	float3 InstancedView_TranslatedWorldCameraOrigin;
	float PrePadding_InstancedView_1036;
	float3 InstancedView_WorldViewOrigin;
	float PrePadding_InstancedView_1052;
	float3 InstancedView_PreViewTranslation;
	float PrePadding_InstancedView_1068;
	float4x4 InstancedView_PrevProjection;
	float4x4 InstancedView_PrevViewProj;
	float4x4 InstancedView_PrevViewRotationProj;
	float4x4 InstancedView_PrevViewToClip;
	float4x4 InstancedView_PrevClipToView;
	float4x4 InstancedView_PrevTranslatedWorldToClip;
	float4x4 InstancedView_PrevTranslatedWorldToView;
	float4x4 InstancedView_PrevViewToTranslatedWorld;
	float4x4 InstancedView_PrevTranslatedWorldToCameraView;
	float4x4 InstancedView_PrevCameraViewToTranslatedWorld;
	float3 InstancedView_PrevWorldCameraOrigin;
	float PrePadding_InstancedView_1724;
	float3 InstancedView_PrevWorldViewOrigin;
	float PrePadding_InstancedView_1740;
	float3 InstancedView_PrevPreViewTranslation;
	float PrePadding_InstancedView_1756;
	float4x4 InstancedView_PrevInvViewProj;
	float4x4 InstancedView_PrevScreenToTranslatedWorld;
	float4x4 InstancedView_ClipToPrevClip;
	float4 InstancedView_TemporalAAJitter;
	float4 InstancedView_GlobalClippingPlane;
	float2 InstancedView_FieldOfViewWideAngles;
	float2 InstancedView_PrevFieldOfViewWideAngles;
	float4  InstancedView_ViewRectMin;
	float4 InstancedView_ViewSizeAndInvSize;
	float4 InstancedView_BufferSizeAndInvSize;
	float4 InstancedView_BufferBilinearUVMinMax;
	int InstancedView_NumSceneColorMSAASamples;
	float  InstancedView_PreExposure;
	float  InstancedView_OneOverPreExposure;
	float  PrePadding_InstancedView_2076;
	float4  InstancedView_DiffuseOverrideParameter;
	float4  InstancedView_SpecularOverrideParameter;
	float4  InstancedView_NormalOverrideParameter;
	float2  InstancedView_RoughnessOverrideParameter;
	float InstancedView_PrevFrameGameTime;
	float InstancedView_PrevFrameRealTime;
	float  InstancedView_OutOfBoundsMask;
	float  PrePadding_InstancedView_2148;
	float  PrePadding_InstancedView_2152;
	float  PrePadding_InstancedView_2156;
	float3 InstancedView_WorldCameraMovementSinceLastFrame;
	float InstancedView_CullingSign;
	float  InstancedView_NearPlane;
	float InstancedView_AdaptiveTessellationFactor;
	float InstancedView_GameTime;
	float InstancedView_RealTime;
	float InstancedView_DeltaTime;
	float InstancedView_MaterialTextureMipBias;
	float InstancedView_MaterialTextureDerivativeMultiply;
	uint InstancedView_Random;
	uint InstancedView_FrameNumber;
	uint InstancedView_StateFrameIndexMod8;
	uint InstancedView_StateFrameIndex;
	float  InstancedView_CameraCut;
	float  InstancedView_UnlitViewmodeMask;
	float  PrePadding_InstancedView_2228;
	float  PrePadding_InstancedView_2232;
	float  PrePadding_InstancedView_2236;
	float4  InstancedView_DirectionalLightColor;
	float3  InstancedView_DirectionalLightDirection;
	float  PrePadding_InstancedView_2268;
	float4 InstancedView_TranslucencyLightingVolumeMin[2];
	float4 InstancedView_TranslucencyLightingVolumeInvSize[2];
	float4 InstancedView_TemporalAAParams;
	float4 InstancedView_CircleDOFParams;
	float InstancedView_DepthOfFieldSensorWidth;
	float InstancedView_DepthOfFieldFocalDistance;
	float InstancedView_DepthOfFieldScale;
	float InstancedView_DepthOfFieldFocalLength;
	float InstancedView_DepthOfFieldFocalRegion;
	float InstancedView_DepthOfFieldNearTransitionRegion;
	float InstancedView_DepthOfFieldFarTransitionRegion;
	float InstancedView_MotionBlurNormalizedToPixel;
	float InstancedView_bSubsurfacePostprocessEnabled;
	float InstancedView_GeneralPurposeTweak;
	float  InstancedView_DemosaicVposOffset;
	float  PrePadding_InstancedView_2412;
	float3 InstancedView_IndirectLightingColorScale;
	float  InstancedView_HDR32bppEncodingMode;
	float3 InstancedView_AtmosphericFogSunDirection;
	float  InstancedView_AtmosphericFogSunPower;
	float  InstancedView_AtmosphericFogPower;
	float  InstancedView_AtmosphericFogDensityScale;
	float  InstancedView_AtmosphericFogDensityOffset;
	float  InstancedView_AtmosphericFogGroundOffset;
	float  InstancedView_AtmosphericFogDistanceScale;
	float  InstancedView_AtmosphericFogAltitudeScale;
	float  InstancedView_AtmosphericFogHeightScaleRayleigh;
	float  InstancedView_AtmosphericFogStartDistance;
	float  InstancedView_AtmosphericFogDistanceOffset;
	float  InstancedView_AtmosphericFogSunDiscScale;
	uint InstancedView_AtmosphericFogRenderMask;
	uint InstancedView_AtmosphericFogInscatterAltitudeSampleNum;
	float4 InstancedView_AtmosphericFogSunColor;
	float3 InstancedView_NormalCurvatureToRoughnessScaleBias;
	float InstancedView_RenderingReflectionCaptureMask;
	float4 InstancedView_AmbientCubemapTint;
	float InstancedView_AmbientCubemapIntensity;
	float InstancedView_SkyLightParameters;
	float PrePadding_InstancedView_2552;
	float PrePadding_InstancedView_2556;
	float4 InstancedView_SkyLightColor;
	float4 InstancedView_SkyIrradianceEnvironmentMap[7];
	float InstancedView_MobilePreviewMode;
	float InstancedView_HMDEyePaddingOffset;
	float  InstancedView_ReflectionCubemapMaxMip;
	float InstancedView_ShowDecalsMask;
	uint InstancedView_DistanceFieldAOSpecularOcclusionMode;
	float InstancedView_IndirectCapsuleSelfShadowingIntensity;
	float PrePadding_InstancedView_2712;
	float PrePadding_InstancedView_2716;
	float3 InstancedView_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int InstancedView_StereoPassIndex;
	float4 InstancedView_GlobalVolumeCenterAndExtent[4];
	float4 InstancedView_GlobalVolumeWorldToUVAddAndMul[4];
	float InstancedView_GlobalVolumeDimension;
	float InstancedView_GlobalVolumeTexelSize;
	float InstancedView_MaxGlobalDistance;
	float InstancedView_bCheckerboardSubsurfaceProfileRendering;
	float3 InstancedView_VolumetricFogInvGridSize;
	float PrePadding_InstancedView_2892;
	float3 InstancedView_VolumetricFogGridZParams;
	float PrePadding_InstancedView_2908;
	float2 InstancedView_VolumetricFogSVPosToVolumeUV;
	float InstancedView_VolumetricFogMaxDistance;
	float PrePadding_InstancedView_2924;
	float3 InstancedView_VolumetricLightmapWorldToUVScale;
	float PrePadding_InstancedView_2940;
	float3 InstancedView_VolumetricLightmapWorldToUVAdd;
	float PrePadding_InstancedView_2956;
	float3 InstancedView_VolumetricLightmapIndirectionTextureSize;
	float InstancedView_VolumetricLightmapBrickSize;
	float3 InstancedView_VolumetricLightmapBrickTexelSize;
	float InstancedView_StereoIPD;
	float InstancedView_IndirectLightingCacheShowFlag;
	float InstancedView_EyeToPixelSpreadAngle;
}
/*atic const struct
{
	float4x4 TranslatedWorldToClip;
	float4x4 WorldToClip;
	float4x4 ClipToWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToWorld;
	float4x4 ScreenToTranslatedWorld;
	float3  ViewForward;
	float3  ViewUp;
	float3  ViewRight;
	float3  HMDViewNoRollUp;
	float3  HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4  ScreenPositionScaleBias;
	float3 WorldCameraOrigin;
	float3 TranslatedWorldCameraOrigin;
	float3 WorldViewOrigin;
	float3 PreViewTranslation;
	float4x4 PrevProjection;
	float4x4 PrevViewProj;
	float4x4 PrevViewRotationProj;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevWorldCameraOrigin;
	float3 PrevWorldViewOrigin;
	float3 PrevPreViewTranslation;
	float4x4 PrevInvViewProj;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4  ViewRectMin;
	float4 ViewSizeAndInvSize;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	int NumSceneColorMSAASamples;
	float  PreExposure;
	float  OneOverPreExposure;
	float4  DiffuseOverrideParameter;
	float4  SpecularOverrideParameter;
	float4  NormalOverrideParameter;
	float2  RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float  OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float  NearPlane;
	float AdaptiveTessellationFactor;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	float  CameraCut;
	float  UnlitViewmodeMask;
	float4  DirectionalLightColor;
	float3  DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float bSubsurfacePostprocessEnabled;
	float GeneralPurposeTweak;
	float  DemosaicVposOffset;
	float3 IndirectLightingColorScale;
	float  HDR32bppEncodingMode;
	float3 AtmosphericFogSunDirection;
	float  AtmosphericFogSunPower;
	float  AtmosphericFogPower;
	float  AtmosphericFogDensityScale;
	float  AtmosphericFogDensityOffset;
	float  AtmosphericFogGroundOffset;
	float  AtmosphericFogDistanceScale;
	float  AtmosphericFogAltitudeScale;
	float  AtmosphericFogHeightScaleRayleigh;
	float  AtmosphericFogStartDistance;
	float  AtmosphericFogDistanceOffset;
	float  AtmosphericFogSunDiscScale;
	uint AtmosphericFogRenderMask;
	uint AtmosphericFogInscatterAltitudeSampleNum;
	float4 AtmosphericFogSunColor;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightParameters;
	float4 SkyLightColor;
	float4 SkyIrradianceEnvironmentMap[7];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float  ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeCenterAndExtent[4];
	float4 GlobalVolumeWorldToUVAddAndMul[4];
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDistance;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float StereoIPD;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
} InstancedView = { InstancedView_TranslatedWorldToClip,InstancedView_WorldToClip,InstancedView_ClipToWorld,InstancedView_TranslatedWorldToView,InstancedView_ViewToTranslatedWorld,InstancedView_TranslatedWorldToCameraView,InstancedView_CameraViewToTranslatedWorld,InstancedView_ViewToClip,InstancedView_ViewToClipNoAA,InstancedView_ClipToView,InstancedView_ClipToTranslatedWorld,InstancedView_SVPositionToTranslatedWorld,InstancedView_ScreenToWorld,InstancedView_ScreenToTranslatedWorld,InstancedView_ViewForward,InstancedView_ViewUp,InstancedView_ViewRight,InstancedView_HMDViewNoRollUp,InstancedView_HMDViewNoRollRight,InstancedView_InvDeviceZToWorldZTransform,InstancedView_ScreenPositionScaleBias,InstancedView_WorldCameraOrigin,InstancedView_TranslatedWorldCameraOrigin,InstancedView_WorldViewOrigin,InstancedView_PreViewTranslation,InstancedView_PrevProjection,InstancedView_PrevViewProj,InstancedView_PrevViewRotationProj,InstancedView_PrevViewToClip,InstancedView_PrevClipToView,InstancedView_PrevTranslatedWorldToClip,InstancedView_PrevTranslatedWorldToView,InstancedView_PrevViewToTranslatedWorld,InstancedView_PrevTranslatedWorldToCameraView,InstancedView_PrevCameraViewToTranslatedWorld,InstancedView_PrevWorldCameraOrigin,InstancedView_PrevWorldViewOrigin,InstancedView_PrevPreViewTranslation,InstancedView_PrevInvViewProj,InstancedView_PrevScreenToTranslatedWorld,InstancedView_ClipToPrevClip,InstancedView_TemporalAAJitter,InstancedView_GlobalClippingPlane,InstancedView_FieldOfViewWideAngles,InstancedView_PrevFieldOfViewWideAngles,InstancedView_ViewRectMin,InstancedView_ViewSizeAndInvSize,InstancedView_BufferSizeAndInvSize,InstancedView_BufferBilinearUVMinMax,InstancedView_NumSceneColorMSAASamples,InstancedView_PreExposure,InstancedView_OneOverPreExposure,InstancedView_DiffuseOverrideParameter,InstancedView_SpecularOverrideParameter,InstancedView_NormalOverrideParameter,InstancedView_RoughnessOverrideParameter,InstancedView_PrevFrameGameTime,InstancedView_PrevFrameRealTime,InstancedView_OutOfBoundsMask,InstancedView_WorldCameraMovementSinceLastFrame,InstancedView_CullingSign,InstancedView_NearPlane,InstancedView_AdaptiveTessellationFactor,InstancedView_GameTime,InstancedView_RealTime,InstancedView_DeltaTime,InstancedView_MaterialTextureMipBias,InstancedView_MaterialTextureDerivativeMultiply,InstancedView_Random,InstancedView_FrameNumber,InstancedView_StateFrameIndexMod8,InstancedView_StateFrameIndex,InstancedView_CameraCut,InstancedView_UnlitViewmodeMask,InstancedView_DirectionalLightColor,InstancedView_DirectionalLightDirection,InstancedView_TranslucencyLightingVolumeMin,InstancedView_TranslucencyLightingVolumeInvSize,InstancedView_TemporalAAParams,InstancedView_CircleDOFParams,InstancedView_DepthOfFieldSensorWidth,InstancedView_DepthOfFieldFocalDistance,InstancedView_DepthOfFieldScale,InstancedView_DepthOfFieldFocalLength,InstancedView_DepthOfFieldFocalRegion,InstancedView_DepthOfFieldNearTransitionRegion,InstancedView_DepthOfFieldFarTransitionRegion,InstancedView_MotionBlurNormalizedToPixel,InstancedView_bSubsurfacePostprocessEnabled,InstancedView_GeneralPurposeTweak,InstancedView_DemosaicVposOffset,InstancedView_IndirectLightingColorScale,InstancedView_HDR32bppEncodingMode,InstancedView_AtmosphericFogSunDirection,InstancedView_AtmosphericFogSunPower,InstancedView_AtmosphericFogPower,InstancedView_AtmosphericFogDensityScale,InstancedView_AtmosphericFogDensityOffset,InstancedView_AtmosphericFogGroundOffset,InstancedView_AtmosphericFogDistanceScale,InstancedView_AtmosphericFogAltitudeScale,InstancedView_AtmosphericFogHeightScaleRayleigh,InstancedView_AtmosphericFogStartDistance,InstancedView_AtmosphericFogDistanceOffset,InstancedView_AtmosphericFogSunDiscScale,InstancedView_AtmosphericFogRenderMask,InstancedView_AtmosphericFogInscatterAltitudeSampleNum,InstancedView_AtmosphericFogSunColor,InstancedView_NormalCurvatureToRoughnessScaleBias,InstancedView_RenderingReflectionCaptureMask,InstancedView_AmbientCubemapTint,InstancedView_AmbientCubemapIntensity,InstancedView_SkyLightParameters,InstancedView_SkyLightColor,InstancedView_SkyIrradianceEnvironmentMap,InstancedView_MobilePreviewMode,InstancedView_HMDEyePaddingOffset,InstancedView_ReflectionCubemapMaxMip,InstancedView_ShowDecalsMask,InstancedView_DistanceFieldAOSpecularOcclusionMode,InstancedView_IndirectCapsuleSelfShadowingIntensity,InstancedView_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight,InstancedView_StereoPassIndex,InstancedView_GlobalVolumeCenterAndExtent,InstancedView_GlobalVolumeWorldToUVAddAndMul,InstancedView_GlobalVolumeDimension,InstancedView_GlobalVolumeTexelSize,InstancedView_MaxGlobalDistance,InstancedView_bCheckerboardSubsurfaceProfileRendering,InstancedView_VolumetricFogInvGridSize,InstancedView_VolumetricFogGridZParams,InstancedView_VolumetricFogSVPosToVolumeUV,InstancedView_VolumetricFogMaxDistance,InstancedView_VolumetricLightmapWorldToUVScale,InstancedView_VolumetricLightmapWorldToUVAdd,InstancedView_VolumetricLightmapIndirectionTextureSize,InstancedView_VolumetricLightmapBrickSize,InstancedView_VolumetricLightmapBrickTexelSize,InstancedView_StereoIPD,InstancedView_IndirectLightingCacheShowFlag,InstancedView_EyeToPixelSpreadAngle*/
#line 4 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/SceneTexturesStruct.ush"


cbuffer SceneTexturesStruct
{
}
Texture2D SceneTexturesStruct_SceneColorTexture;
SamplerState SceneTexturesStruct_SceneColorTextureSampler;
Texture2D SceneTexturesStruct_SceneDepthTexture;
SamplerState SceneTexturesStruct_SceneDepthTextureSampler;
Texture2D<float> SceneTexturesStruct_SceneDepthTextureNonMS;
Texture2D SceneTexturesStruct_GBufferATexture;
Texture2D SceneTexturesStruct_GBufferBTexture;
Texture2D SceneTexturesStruct_GBufferCTexture;
Texture2D SceneTexturesStruct_GBufferDTexture;
Texture2D SceneTexturesStruct_GBufferETexture;
Texture2D SceneTexturesStruct_GBufferVelocityTexture;
Texture2D<float4> SceneTexturesStruct_GBufferATextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferBTextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferCTextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferDTextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferETextureNonMS;
Texture2D<float4> SceneTexturesStruct_GBufferVelocityTextureNonMS;
SamplerState SceneTexturesStruct_GBufferATextureSampler;
SamplerState SceneTexturesStruct_GBufferBTextureSampler;
SamplerState SceneTexturesStruct_GBufferCTextureSampler;
SamplerState SceneTexturesStruct_GBufferDTextureSampler;
SamplerState SceneTexturesStruct_GBufferETextureSampler;
SamplerState SceneTexturesStruct_GBufferVelocityTextureSampler;
Texture2D SceneTexturesStruct_ScreenSpaceAOTexture;
SamplerState SceneTexturesStruct_ScreenSpaceAOTextureSampler;
Texture2D<float> SceneTexturesStruct_CustomDepthTextureNonMS;
Texture2D SceneTexturesStruct_CustomDepthTexture;
SamplerState SceneTexturesStruct_CustomDepthTextureSampler;
Texture2D<uint2> SceneTexturesStruct_CustomStencilTexture;
Texture2D<uint2> SceneTexturesStruct_SceneStencilTexture;
Texture2D SceneTexturesStruct_EyeAdaptation;
Texture2D SceneTexturesStruct_SceneColorCopyTexture;
SamplerState SceneTexturesStruct_SceneColorCopyTextureSampler;
/*atic const struct
{
	Texture2D SceneColorTexture;
	SamplerState SceneColorTextureSampler;
	Texture2D SceneDepthTexture;
	SamplerState SceneDepthTextureSampler;
	Texture2D<float> SceneDepthTextureNonMS;
	Texture2D GBufferATexture;
	Texture2D GBufferBTexture;
	Texture2D GBufferCTexture;
	Texture2D GBufferDTexture;
	Texture2D GBufferETexture;
	Texture2D GBufferVelocityTexture;
	Texture2D<float4> GBufferATextureNonMS;
	Texture2D<float4> GBufferBTextureNonMS;
	Texture2D<float4> GBufferCTextureNonMS;
	Texture2D<float4> GBufferDTextureNonMS;
	Texture2D<float4> GBufferETextureNonMS;
	Texture2D<float4> GBufferVelocityTextureNonMS;
	SamplerState GBufferATextureSampler;
	SamplerState GBufferBTextureSampler;
	SamplerState GBufferCTextureSampler;
	SamplerState GBufferDTextureSampler;
	SamplerState GBufferETextureSampler;
	SamplerState GBufferVelocityTextureSampler;
	Texture2D ScreenSpaceAOTexture;
	SamplerState ScreenSpaceAOTextureSampler;
	Texture2D<float> CustomDepthTextureNonMS;
	Texture2D CustomDepthTexture;
	SamplerState CustomDepthTextureSampler;
	Texture2D<uint2> CustomStencilTexture;
	Texture2D<uint2> SceneStencilTexture;
	Texture2D EyeAdaptation;
	Texture2D SceneColorCopyTexture;
	SamplerState SceneColorCopyTextureSampler;
} SceneTexturesStruct = { SceneTexturesStruct_SceneColorTexture,SceneTexturesStruct_SceneColorTextureSampler,SceneTexturesStruct_SceneDepthTexture,SceneTexturesStruct_SceneDepthTextureSampler,SceneTexturesStruct_SceneDepthTextureNonMS,SceneTexturesStruct_GBufferATexture,SceneTexturesStruct_GBufferBTexture,SceneTexturesStruct_GBufferCTexture,SceneTexturesStruct_GBufferDTexture,SceneTexturesStruct_GBufferETexture,SceneTexturesStruct_GBufferVelocityTexture,SceneTexturesStruct_GBufferATextureNonMS,SceneTexturesStruct_GBufferBTextureNonMS,SceneTexturesStruct_GBufferCTextureNonMS,SceneTexturesStruct_GBufferDTextureNonMS,SceneTexturesStruct_GBufferETextureNonMS,SceneTexturesStruct_GBufferVelocityTextureNonMS,SceneTexturesStruct_GBufferATextureSampler,SceneTexturesStruct_GBufferBTextureSampler,SceneTexturesStruct_GBufferCTextureSampler,SceneTexturesStruct_GBufferDTextureSampler,SceneTexturesStruct_GBufferETextureSampler,SceneTexturesStruct_GBufferVelocityTextureSampler,SceneTexturesStruct_ScreenSpaceAOTexture,SceneTexturesStruct_ScreenSpaceAOTextureSampler,SceneTexturesStruct_CustomDepthTextureNonMS,SceneTexturesStruct_CustomDepthTexture,SceneTexturesStruct_CustomDepthTextureSampler  ,SceneTexturesStruct_CustomStencilTexture   ,SceneTexturesStruct_SceneStencilTexture  ,SceneTexturesStruct_EyeAdaptation,SceneTexturesStruct_SceneColorCopyTexture,SceneTexturesStruct_SceneColorCopyTextureSampler*/
#line 5 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/MobileSceneTextures.ush"


cbuffer MobileSceneTextures
{
}
Texture2D MobileSceneTextures_SceneColorTexture;
SamplerState MobileSceneTextures_SceneColorTextureSampler;
Texture2D MobileSceneTextures_SceneDepthTexture;
SamplerState MobileSceneTextures_SceneDepthTextureSampler;
Texture2D MobileSceneTextures_SceneAlphaCopyTexture;
SamplerState MobileSceneTextures_SceneAlphaCopyTextureSampler;
Texture2D MobileSceneTextures_CustomDepthTexture;
SamplerState MobileSceneTextures_CustomDepthTextureSampler;
Texture2D MobileSceneTextures_MobileCustomStencilTexture;
SamplerState MobileSceneTextures_MobileCustomStencilTextureSampler;
/*atic const struct
{
	Texture2D SceneColorTexture;
	SamplerState SceneColorTextureSampler;
	Texture2D SceneDepthTexture;
	SamplerState SceneDepthTextureSampler;
	Texture2D SceneAlphaCopyTexture;
	SamplerState SceneAlphaCopyTextureSampler;
	Texture2D CustomDepthTexture;
	SamplerState CustomDepthTextureSampler;
	Texture2D MobileCustomStencilTexture;
	SamplerState MobileCustomStencilTextureSampler;
} MobileSceneTextures = { MobileSceneTextures_SceneColorTexture,MobileSceneTextures_SceneColorTextureSampler,MobileSceneTextures_SceneDepthTexture,MobileSceneTextures_SceneDepthTextureSampler,MobileSceneTextures_SceneAlphaCopyTexture,MobileSceneTextures_SceneAlphaCopyTextureSampler,MobileSceneTextures_CustomDepthTexture,MobileSceneTextures_CustomDepthTextureSampler,MobileSceneTextures_MobileCustomStencilTexture,MobileSceneTextures_MobileCustomStencilTextureSampler*/
#line 6 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/ReflectionStruct.ush"


cbuffer ReflectionStruct
{
	float4 ReflectionStruct_SkyLightParameters;
	float ReflectionStruct_SkyLightCubemapBrightness;
}
TextureCube ReflectionStruct_SkyLightCubemap;
SamplerState ReflectionStruct_SkyLightCubemapSampler;
TextureCube ReflectionStruct_SkyLightBlendDestinationCubemap;
SamplerState ReflectionStruct_SkyLightBlendDestinationCubemapSampler;
TextureCubeArray ReflectionStruct_ReflectionCubemap;
SamplerState ReflectionStruct_ReflectionCubemapSampler;
Texture2D ReflectionStruct_PreIntegratedGF;
SamplerState ReflectionStruct_PreIntegratedGFSampler;
/*atic const struct
{
	float4 SkyLightParameters;
	float SkyLightCubemapBrightness;
	TextureCube SkyLightCubemap;
	SamplerState SkyLightCubemapSampler;
	TextureCube SkyLightBlendDestinationCubemap;
	SamplerState SkyLightBlendDestinationCubemapSampler;
	TextureCubeArray ReflectionCubemap;
	SamplerState ReflectionCubemapSampler;
	Texture2D PreIntegratedGF;
	SamplerState PreIntegratedGFSampler;
} ReflectionStruct = { ReflectionStruct_SkyLightParameters,ReflectionStruct_SkyLightCubemapBrightness,ReflectionStruct_SkyLightCubemap,ReflectionStruct_SkyLightCubemapSampler,ReflectionStruct_SkyLightBlendDestinationCubemap,ReflectionStruct_SkyLightBlendDestinationCubemapSampler,ReflectionStruct_ReflectionCubemap,ReflectionStruct_ReflectionCubemapSampler,ReflectionStruct_PreIntegratedGF,ReflectionStruct_PreIntegratedGFSampler*/
#line 7 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/AOSamples2.ush"


cbuffer AOSamples2
{
	float4 AOSamples2_SampleDirections[9];
}
/*atic const struct
{
	float4 SampleDirections[9];
} AOSamples2 = { AOSamples2_SampleDirections*/
#line 8 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/RectLight.ush"


cbuffer RectLight
{
	int RectLight_SamplesPerPixel;
	int RectLight_bIsTextureImportanceSampling;
	int PrePadding_RectLight_8;
	int PrePadding_RectLight_12;
	float3 RectLight_Position;
	float PrePadding_RectLight_28;
	float3 RectLight_Normal;
	float PrePadding_RectLight_44;
	float3 RectLight_dPdu;
	float PrePadding_RectLight_60;
	float3 RectLight_dPdv;
	float PrePadding_RectLight_76;
	float3 RectLight_Color;
	float RectLight_Width;
	float RectLight_Height;
	float PrePadding_RectLight_100;
	float PrePadding_RectLight_104;
	float PrePadding_RectLight_108;
	int3 RectLight_MipTreeDimensions;
	float RectLight_MaxNormalBias;
	float RectLight_BarnCosAngle;
	float RectLight_BarnLength;
}
Texture2D RectLight_Texture;
SamplerState RectLight_TextureSampler;
Buffer<float> RectLight_MipTree;
/*atic const struct
{
	int SamplesPerPixel;
	int bIsTextureImportanceSampling;
	float3 Position;
	float3 Normal;
	float3 dPdu;
	float3 dPdv;
	float3 Color;
	float Width;
	float Height;
	int3 MipTreeDimensions;
	float MaxNormalBias;
	float BarnCosAngle;
	float BarnLength;
	Texture2D Texture;
	SamplerState TextureSampler;
	Buffer<float> MipTree;
} RectLight = { RectLight_SamplesPerPixel,RectLight_bIsTextureImportanceSampling,RectLight_Position,RectLight_Normal,RectLight_dPdu,RectLight_dPdv,RectLight_Color,RectLight_Width,RectLight_Height,RectLight_MipTreeDimensions,RectLight_MaxNormalBias,RectLight_BarnCosAngle,RectLight_BarnLength,RectLight_Texture,RectLight_TextureSampler  ,RectLight_MipTree  */
#line 9 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/ForwardLightData.ush"


cbuffer ForwardLightData
{
	uint ForwardLightData_NumLocalLights;
	uint ForwardLightData_NumReflectionCaptures;
	uint ForwardLightData_HasDirectionalLight;
	uint ForwardLightData_NumGridCells;
	int3 ForwardLightData_CulledGridSize;
	uint ForwardLightData_MaxCulledLightsPerCell;
	uint ForwardLightData_LightGridPixelSizeShift;
	uint PrePadding_ForwardLightData_36;
	uint PrePadding_ForwardLightData_40;
	uint PrePadding_ForwardLightData_44;
	float3 ForwardLightData_LightGridZParams;
	float PrePadding_ForwardLightData_60;
	float3 ForwardLightData_DirectionalLightDirection;
	float PrePadding_ForwardLightData_76;
	float3 ForwardLightData_DirectionalLightColor;
	float ForwardLightData_DirectionalLightVolumetricScatteringIntensity;
	uint ForwardLightData_DirectionalLightShadowMapChannelMask;
	uint PrePadding_ForwardLightData_100;
	float2 ForwardLightData_DirectionalLightDistanceFadeMAD;
	uint ForwardLightData_NumDirectionalLightCascades;
	uint PrePadding_ForwardLightData_116;
	uint PrePadding_ForwardLightData_120;
	uint PrePadding_ForwardLightData_124;
	float4 ForwardLightData_CascadeEndDepths;
	float4x4 ForwardLightData_DirectionalLightWorldToShadowMatrix[4];
	float4 ForwardLightData_DirectionalLightShadowmapMinMax[4];
	float4 ForwardLightData_DirectionalLightShadowmapAtlasBufferSize;
	float ForwardLightData_DirectionalLightDepthBias;
	uint ForwardLightData_DirectionalLightUseStaticShadowing;
	uint PrePadding_ForwardLightData_488;
	uint PrePadding_ForwardLightData_492;
	float4 ForwardLightData_DirectionalLightStaticShadowBufferSize;
	float4x4 ForwardLightData_DirectionalLightWorldToStaticShadow;
}
Texture2D ForwardLightData_DirectionalLightShadowmapAtlas;
SamplerState ForwardLightData_ShadowmapSampler;
Texture2D ForwardLightData_DirectionalLightStaticShadowmap;
SamplerState ForwardLightData_StaticShadowmapSampler;
Buffer <float4> ForwardLightData_ForwardLocalLightBuffer;
Buffer <uint> ForwardLightData_NumCulledLightsGrid;
Buffer <uint> ForwardLightData_CulledLightDataGrid;
/*atic const struct
{
	uint NumLocalLights;
	uint NumReflectionCaptures;
	uint HasDirectionalLight;
	uint NumGridCells;
	int3 CulledGridSize;
	uint MaxCulledLightsPerCell;
	uint LightGridPixelSizeShift;
	float3 LightGridZParams;
	float3 DirectionalLightDirection;
	float3 DirectionalLightColor;
	float DirectionalLightVolumetricScatteringIntensity;
	uint DirectionalLightShadowMapChannelMask;
	float2 DirectionalLightDistanceFadeMAD;
	uint NumDirectionalLightCascades;
	float4 CascadeEndDepths;
	float4x4 DirectionalLightWorldToShadowMatrix[4];
	float4 DirectionalLightShadowmapMinMax[4];
	float4 DirectionalLightShadowmapAtlasBufferSize;
	float DirectionalLightDepthBias;
	uint DirectionalLightUseStaticShadowing;
	float4 DirectionalLightStaticShadowBufferSize;
	float4x4 DirectionalLightWorldToStaticShadow;
	Texture2D DirectionalLightShadowmapAtlas;
	SamplerState ShadowmapSampler;
	Texture2D DirectionalLightStaticShadowmap;
	SamplerState StaticShadowmapSampler;
	Buffer <float4> ForwardLocalLightBuffer;
	Buffer <uint> NumCulledLightsGrid;
	Buffer <uint> CulledLightDataGrid;
} ForwardLightData = { ForwardLightData_NumLocalLights,ForwardLightData_NumReflectionCaptures,ForwardLightData_HasDirectionalLight,ForwardLightData_NumGridCells,ForwardLightData_CulledGridSize,ForwardLightData_MaxCulledLightsPerCell,ForwardLightData_LightGridPixelSizeShift,ForwardLightData_LightGridZParams,ForwardLightData_DirectionalLightDirection,ForwardLightData_DirectionalLightColor,ForwardLightData_DirectionalLightVolumetricScatteringIntensity,ForwardLightData_DirectionalLightShadowMapChannelMask,ForwardLightData_DirectionalLightDistanceFadeMAD,ForwardLightData_NumDirectionalLightCascades,ForwardLightData_CascadeEndDepths,ForwardLightData_DirectionalLightWorldToShadowMatrix,ForwardLightData_DirectionalLightShadowmapMinMax,ForwardLightData_DirectionalLightShadowmapAtlasBufferSize,ForwardLightData_DirectionalLightDepthBias,ForwardLightData_DirectionalLightUseStaticShadowing,ForwardLightData_DirectionalLightStaticShadowBufferSize,ForwardLightData_DirectionalLightWorldToStaticShadow,ForwardLightData_DirectionalLightShadowmapAtlas,ForwardLightData_ShadowmapSampler,ForwardLightData_DirectionalLightStaticShadowmap,ForwardLightData_StaticShadowmapSampler  ,ForwardLightData_ForwardLocalLightBuffer   ,ForwardLightData_NumCulledLightsGrid   ,ForwardLightData_CulledLightDataGrid  */
#line 10 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/TranslucentBasePass.ush"


cbuffer TranslucentBasePass
{
	uint TranslucentBasePass_Shared_Forward_NumLocalLights;
	uint TranslucentBasePass_Shared_Forward_NumReflectionCaptures;
	uint TranslucentBasePass_Shared_Forward_HasDirectionalLight;
	uint TranslucentBasePass_Shared_Forward_NumGridCells;
	int3 TranslucentBasePass_Shared_Forward_CulledGridSize;
	uint TranslucentBasePass_Shared_Forward_MaxCulledLightsPerCell;
	uint TranslucentBasePass_Shared_Forward_LightGridPixelSizeShift;
	uint PrePadding_TranslucentBasePass_Shared_Forward_36;
	uint PrePadding_TranslucentBasePass_Shared_Forward_40;
	uint PrePadding_TranslucentBasePass_Shared_Forward_44;
	float3 TranslucentBasePass_Shared_Forward_LightGridZParams;
	float PrePadding_TranslucentBasePass_Shared_Forward_60;
	float3 TranslucentBasePass_Shared_Forward_DirectionalLightDirection;
	float PrePadding_TranslucentBasePass_Shared_Forward_76;
	float3 TranslucentBasePass_Shared_Forward_DirectionalLightColor;
	float TranslucentBasePass_Shared_Forward_DirectionalLightVolumetricScatteringIntensity;
	uint TranslucentBasePass_Shared_Forward_DirectionalLightShadowMapChannelMask;
	uint PrePadding_TranslucentBasePass_Shared_Forward_100;
	float2 TranslucentBasePass_Shared_Forward_DirectionalLightDistanceFadeMAD;
	uint TranslucentBasePass_Shared_Forward_NumDirectionalLightCascades;
	uint PrePadding_TranslucentBasePass_Shared_Forward_116;
	uint PrePadding_TranslucentBasePass_Shared_Forward_120;
	uint PrePadding_TranslucentBasePass_Shared_Forward_124;
	float4 TranslucentBasePass_Shared_Forward_CascadeEndDepths;
	float4x4 TranslucentBasePass_Shared_Forward_DirectionalLightWorldToShadowMatrix[4];
	float4 TranslucentBasePass_Shared_Forward_DirectionalLightShadowmapMinMax[4];
	float4 TranslucentBasePass_Shared_Forward_DirectionalLightShadowmapAtlasBufferSize;
	float TranslucentBasePass_Shared_Forward_DirectionalLightDepthBias;
	uint TranslucentBasePass_Shared_Forward_DirectionalLightUseStaticShadowing;
	uint PrePadding_TranslucentBasePass_Shared_Forward_488;
	uint PrePadding_TranslucentBasePass_Shared_Forward_492;
	float4 TranslucentBasePass_Shared_Forward_DirectionalLightStaticShadowBufferSize;
	float4x4 TranslucentBasePass_Shared_Forward_DirectionalLightWorldToStaticShadow;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_576;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_580;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_584;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_588;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_592;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_596;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_600;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_604;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_608;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_612;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_616;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_620;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_624;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_628;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_632;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_636;
	uint TranslucentBasePass_Shared_ForwardISR_NumLocalLights;
	uint TranslucentBasePass_Shared_ForwardISR_NumReflectionCaptures;
	uint TranslucentBasePass_Shared_ForwardISR_HasDirectionalLight;
	uint TranslucentBasePass_Shared_ForwardISR_NumGridCells;
	int3 TranslucentBasePass_Shared_ForwardISR_CulledGridSize;
	uint TranslucentBasePass_Shared_ForwardISR_MaxCulledLightsPerCell;
	uint TranslucentBasePass_Shared_ForwardISR_LightGridPixelSizeShift;
	uint PrePadding_TranslucentBasePass_Shared_ForwardISR_676;
	uint PrePadding_TranslucentBasePass_Shared_ForwardISR_680;
	uint PrePadding_TranslucentBasePass_Shared_ForwardISR_684;
	float3 TranslucentBasePass_Shared_ForwardISR_LightGridZParams;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_700;
	float3 TranslucentBasePass_Shared_ForwardISR_DirectionalLightDirection;
	float PrePadding_TranslucentBasePass_Shared_ForwardISR_716;
	float3 TranslucentBasePass_Shared_ForwardISR_DirectionalLightColor;
	float TranslucentBasePass_Shared_ForwardISR_DirectionalLightVolumetricScatteringIntensity;
	uint TranslucentBasePass_Shared_ForwardISR_DirectionalLightShadowMapChannelMask;
	uint PrePadding_TranslucentBasePass_Shared_ForwardISR_740;
	float2 TranslucentBasePass_Shared_ForwardISR_DirectionalLightDistanceFadeMAD;
	uint TranslucentBasePass_Shared_ForwardISR_NumDirectionalLightCascades;
	uint PrePadding_TranslucentBasePass_Shared_ForwardISR_756;
	uint PrePadding_TranslucentBasePass_Shared_ForwardISR_760;
	uint PrePadding_TranslucentBasePass_Shared_ForwardISR_764;
	float4 TranslucentBasePass_Shared_ForwardISR_CascadeEndDepths;
	float4x4 TranslucentBasePass_Shared_ForwardISR_DirectionalLightWorldToShadowMatrix[4];
	float4 TranslucentBasePass_Shared_ForwardISR_DirectionalLightShadowmapMinMax[4];
	float4 TranslucentBasePass_Shared_ForwardISR_DirectionalLightShadowmapAtlasBufferSize;
	float TranslucentBasePass_Shared_ForwardISR_DirectionalLightDepthBias;
	uint TranslucentBasePass_Shared_ForwardISR_DirectionalLightUseStaticShadowing;
	uint PrePadding_TranslucentBasePass_Shared_ForwardISR_1128;
	uint PrePadding_TranslucentBasePass_Shared_ForwardISR_1132;
	float4 TranslucentBasePass_Shared_ForwardISR_DirectionalLightStaticShadowBufferSize;
	float4x4 TranslucentBasePass_Shared_ForwardISR_DirectionalLightWorldToStaticShadow;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1216;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1220;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1224;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1228;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1232;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1236;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1240;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1244;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1248;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1252;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1256;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1260;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1264;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1268;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1272;
	float PrePadding_TranslucentBasePass_Shared_Reflection_1276;
	float4 TranslucentBasePass_Shared_Reflection_SkyLightParameters;
	float TranslucentBasePass_Shared_Reflection_SkyLightCubemapBrightness;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1300;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1304;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1308;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1312;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1316;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1320;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1324;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1328;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1332;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1336;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1340;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1344;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1348;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1352;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1356;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1360;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1364;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1368;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1372;
	float4 TranslucentBasePass_Shared_PlanarReflection_ReflectionPlane;
	float4 TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionOrigin;
	float4 TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionXAxis;
	float4 TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionYAxis;
	float3x4 TranslucentBasePass_Shared_PlanarReflection_InverseTransposeMirrorMatrix;
	float3 TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionParameters;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1500;
	float2 TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionParameters2;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1512;
	float PrePadding_TranslucentBasePass_Shared_PlanarReflection_1516;
	float4x4 TranslucentBasePass_Shared_PlanarReflection_ProjectionWithExtraFOV[2];
	float4 TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionScreenScaleBias[2];
	float2 TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionScreenBound;
	bool TranslucentBasePass_Shared_PlanarReflection_bIsStereo;
	float PrePadding_TranslucentBasePass_Shared_Fog_1692;
	float PrePadding_TranslucentBasePass_Shared_Fog_1696;
	float PrePadding_TranslucentBasePass_Shared_Fog_1700;
	float PrePadding_TranslucentBasePass_Shared_Fog_1704;
	float PrePadding_TranslucentBasePass_Shared_Fog_1708;
	float4 TranslucentBasePass_Shared_Fog_ExponentialFogParameters;
	float4 TranslucentBasePass_Shared_Fog_ExponentialFogParameters2;
	float4 TranslucentBasePass_Shared_Fog_ExponentialFogColorParameter;
	float4 TranslucentBasePass_Shared_Fog_ExponentialFogParameters3;
	float4 TranslucentBasePass_Shared_Fog_InscatteringLightDirection;
	float4 TranslucentBasePass_Shared_Fog_DirectionalInscatteringColor;
	float2 TranslucentBasePass_Shared_Fog_SinCosInscatteringColorCubemapRotation;
	float PrePadding_TranslucentBasePass_Shared_Fog_1816;
	float PrePadding_TranslucentBasePass_Shared_Fog_1820;
	float3 TranslucentBasePass_Shared_Fog_FogInscatteringTextureParameters;
	float TranslucentBasePass_Shared_Fog_ApplyVolumetricFog;
	float PrePadding_TranslucentBasePass_1840;
	float PrePadding_TranslucentBasePass_1844;
	float PrePadding_TranslucentBasePass_1848;
	float PrePadding_TranslucentBasePass_1852;
	float PrePadding_TranslucentBasePass_1856;
	float PrePadding_TranslucentBasePass_1860;
	float PrePadding_TranslucentBasePass_1864;
	float PrePadding_TranslucentBasePass_1868;
	float PrePadding_TranslucentBasePass_1872;
	float PrePadding_TranslucentBasePass_1876;
	float PrePadding_TranslucentBasePass_1880;
	float PrePadding_TranslucentBasePass_1884;
	float PrePadding_TranslucentBasePass_1888;
	float PrePadding_TranslucentBasePass_1892;
	float PrePadding_TranslucentBasePass_1896;
	float PrePadding_TranslucentBasePass_1900;
	float PrePadding_TranslucentBasePass_1904;
	float PrePadding_TranslucentBasePass_1908;
	float PrePadding_TranslucentBasePass_1912;
	float PrePadding_TranslucentBasePass_1916;
	float PrePadding_TranslucentBasePass_1920;
	float PrePadding_TranslucentBasePass_1924;
	float PrePadding_TranslucentBasePass_1928;
	float PrePadding_TranslucentBasePass_1932;
	float PrePadding_TranslucentBasePass_1936;
	float PrePadding_TranslucentBasePass_1940;
	float PrePadding_TranslucentBasePass_1944;
	float PrePadding_TranslucentBasePass_1948;
	float PrePadding_TranslucentBasePass_1952;
	float PrePadding_TranslucentBasePass_1956;
	float PrePadding_TranslucentBasePass_1960;
	float PrePadding_TranslucentBasePass_1964;
	float PrePadding_TranslucentBasePass_1968;
	float PrePadding_TranslucentBasePass_1972;
	float PrePadding_TranslucentBasePass_1976;
	float PrePadding_TranslucentBasePass_1980;
	float PrePadding_TranslucentBasePass_1984;
	float PrePadding_TranslucentBasePass_1988;
	float PrePadding_TranslucentBasePass_1992;
	float PrePadding_TranslucentBasePass_1996;
	float PrePadding_TranslucentBasePass_2000;
	float PrePadding_TranslucentBasePass_2004;
	float PrePadding_TranslucentBasePass_2008;
	float PrePadding_TranslucentBasePass_2012;
	float PrePadding_TranslucentBasePass_2016;
	float PrePadding_TranslucentBasePass_2020;
	float PrePadding_TranslucentBasePass_2024;
	float PrePadding_TranslucentBasePass_2028;
	float PrePadding_TranslucentBasePass_2032;
	float PrePadding_TranslucentBasePass_2036;
	float PrePadding_TranslucentBasePass_2040;
	float PrePadding_TranslucentBasePass_2044;
	float PrePadding_TranslucentBasePass_2048;
	float PrePadding_TranslucentBasePass_2052;
	float PrePadding_TranslucentBasePass_2056;
	float PrePadding_TranslucentBasePass_2060;
	float PrePadding_TranslucentBasePass_2064;
	float PrePadding_TranslucentBasePass_2068;
	float PrePadding_TranslucentBasePass_2072;
	float PrePadding_TranslucentBasePass_2076;
	float PrePadding_TranslucentBasePass_2080;
	float PrePadding_TranslucentBasePass_2084;
	float PrePadding_TranslucentBasePass_2088;
	float PrePadding_TranslucentBasePass_2092;
	float PrePadding_TranslucentBasePass_2096;
	float PrePadding_TranslucentBasePass_2100;
	float PrePadding_TranslucentBasePass_2104;
	float PrePadding_TranslucentBasePass_2108;
	float PrePadding_TranslucentBasePass_2112;
	float PrePadding_TranslucentBasePass_2116;
	float PrePadding_TranslucentBasePass_2120;
	float PrePadding_TranslucentBasePass_2124;
	float PrePadding_TranslucentBasePass_2128;
	float PrePadding_TranslucentBasePass_2132;
	float PrePadding_TranslucentBasePass_2136;
	float PrePadding_TranslucentBasePass_2140;
	float PrePadding_TranslucentBasePass_2144;
	float PrePadding_TranslucentBasePass_2148;
	float PrePadding_TranslucentBasePass_2152;
	float PrePadding_TranslucentBasePass_2156;
	float4 TranslucentBasePass_HZBUvFactorAndInvFactor;
	float4 TranslucentBasePass_PrevScreenPositionScaleBias;
	float TranslucentBasePass_PrevSceneColorPreExposureInv;
}
Texture2D TranslucentBasePass_Shared_Forward_DirectionalLightShadowmapAtlas;
SamplerState TranslucentBasePass_Shared_Forward_ShadowmapSampler;
Texture2D TranslucentBasePass_Shared_Forward_DirectionalLightStaticShadowmap;
SamplerState TranslucentBasePass_Shared_Forward_StaticShadowmapSampler;
Buffer <float4> TranslucentBasePass_Shared_Forward_ForwardLocalLightBuffer;
Buffer <uint> TranslucentBasePass_Shared_Forward_NumCulledLightsGrid;
Buffer <uint> TranslucentBasePass_Shared_Forward_CulledLightDataGrid;
Texture2D TranslucentBasePass_Shared_ForwardISR_DirectionalLightShadowmapAtlas;
SamplerState TranslucentBasePass_Shared_ForwardISR_ShadowmapSampler;
Texture2D TranslucentBasePass_Shared_ForwardISR_DirectionalLightStaticShadowmap;
SamplerState TranslucentBasePass_Shared_ForwardISR_StaticShadowmapSampler;
Buffer <float4> TranslucentBasePass_Shared_ForwardISR_ForwardLocalLightBuffer;
Buffer <uint> TranslucentBasePass_Shared_ForwardISR_NumCulledLightsGrid;
Buffer <uint> TranslucentBasePass_Shared_ForwardISR_CulledLightDataGrid;
TextureCube TranslucentBasePass_Shared_Reflection_SkyLightCubemap;
SamplerState TranslucentBasePass_Shared_Reflection_SkyLightCubemapSampler;
TextureCube TranslucentBasePass_Shared_Reflection_SkyLightBlendDestinationCubemap;
SamplerState TranslucentBasePass_Shared_Reflection_SkyLightBlendDestinationCubemapSampler;
TextureCubeArray TranslucentBasePass_Shared_Reflection_ReflectionCubemap;
SamplerState TranslucentBasePass_Shared_Reflection_ReflectionCubemapSampler;
Texture2D TranslucentBasePass_Shared_Reflection_PreIntegratedGF;
SamplerState TranslucentBasePass_Shared_Reflection_PreIntegratedGFSampler;
Texture2D TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionTexture;
SamplerState TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionSampler;
TextureCube TranslucentBasePass_Shared_Fog_FogInscatteringColorCubemap;
SamplerState TranslucentBasePass_Shared_Fog_FogInscatteringColorSampler;
Texture3D TranslucentBasePass_Shared_Fog_IntegratedLightScattering;
SamplerState TranslucentBasePass_Shared_Fog_IntegratedLightScatteringSampler;
Texture2D TranslucentBasePass_Shared_SSProfilesTexture;
Texture2D TranslucentBasePass_SceneTextures_SceneColorTexture;
SamplerState TranslucentBasePass_SceneTextures_SceneColorTextureSampler;
Texture2D TranslucentBasePass_SceneTextures_SceneDepthTexture;
SamplerState TranslucentBasePass_SceneTextures_SceneDepthTextureSampler;
Texture2D<float> TranslucentBasePass_SceneTextures_SceneDepthTextureNonMS;
Texture2D TranslucentBasePass_SceneTextures_GBufferATexture;
Texture2D TranslucentBasePass_SceneTextures_GBufferBTexture;
Texture2D TranslucentBasePass_SceneTextures_GBufferCTexture;
Texture2D TranslucentBasePass_SceneTextures_GBufferDTexture;
Texture2D TranslucentBasePass_SceneTextures_GBufferETexture;
Texture2D TranslucentBasePass_SceneTextures_GBufferVelocityTexture;
Texture2D<float4> TranslucentBasePass_SceneTextures_GBufferATextureNonMS;
Texture2D<float4> TranslucentBasePass_SceneTextures_GBufferBTextureNonMS;
Texture2D<float4> TranslucentBasePass_SceneTextures_GBufferCTextureNonMS;
Texture2D<float4> TranslucentBasePass_SceneTextures_GBufferDTextureNonMS;
Texture2D<float4> TranslucentBasePass_SceneTextures_GBufferETextureNonMS;
Texture2D<float4> TranslucentBasePass_SceneTextures_GBufferVelocityTextureNonMS;
SamplerState TranslucentBasePass_SceneTextures_GBufferATextureSampler;
SamplerState TranslucentBasePass_SceneTextures_GBufferBTextureSampler;
SamplerState TranslucentBasePass_SceneTextures_GBufferCTextureSampler;
SamplerState TranslucentBasePass_SceneTextures_GBufferDTextureSampler;
SamplerState TranslucentBasePass_SceneTextures_GBufferETextureSampler;
SamplerState TranslucentBasePass_SceneTextures_GBufferVelocityTextureSampler;
Texture2D TranslucentBasePass_SceneTextures_ScreenSpaceAOTexture;
SamplerState TranslucentBasePass_SceneTextures_ScreenSpaceAOTextureSampler;
Texture2D<float> TranslucentBasePass_SceneTextures_CustomDepthTextureNonMS;
Texture2D TranslucentBasePass_SceneTextures_CustomDepthTexture;
SamplerState TranslucentBasePass_SceneTextures_CustomDepthTextureSampler;
Texture2D<uint2> TranslucentBasePass_SceneTextures_CustomStencilTexture;
Texture2D<uint2> TranslucentBasePass_SceneTextures_SceneStencilTexture;
Texture2D TranslucentBasePass_SceneTextures_EyeAdaptation;
Texture2D TranslucentBasePass_SceneTextures_SceneColorCopyTexture;
SamplerState TranslucentBasePass_SceneTextures_SceneColorCopyTextureSampler;
Texture2D TranslucentBasePass_HZBTexture;
SamplerState TranslucentBasePass_HZBSampler;
Texture2D TranslucentBasePass_PrevSceneColor;
SamplerState TranslucentBasePass_PrevSceneColorSampler;
Texture3D TranslucentBasePass_TranslucencyLightingVolumeAmbientInner;
SamplerState TranslucentBasePass_TranslucencyLightingVolumeAmbientInnerSampler;
Texture3D TranslucentBasePass_TranslucencyLightingVolumeAmbientOuter;
SamplerState TranslucentBasePass_TranslucencyLightingVolumeAmbientOuterSampler;
Texture3D TranslucentBasePass_TranslucencyLightingVolumeDirectionalInner;
SamplerState TranslucentBasePass_TranslucencyLightingVolumeDirectionalInnerSampler;
Texture3D TranslucentBasePass_TranslucencyLightingVolumeDirectionalOuter;
SamplerState TranslucentBasePass_TranslucencyLightingVolumeDirectionalOuterSampler;
/*atic const struct
{
struct {
struct {
	uint NumLocalLights;
	uint NumReflectionCaptures;
	uint HasDirectionalLight;
	uint NumGridCells;
	int3 CulledGridSize;
	uint MaxCulledLightsPerCell;
	uint LightGridPixelSizeShift;
	float3 LightGridZParams;
	float3 DirectionalLightDirection;
	float3 DirectionalLightColor;
	float DirectionalLightVolumetricScatteringIntensity;
	uint DirectionalLightShadowMapChannelMask;
	float2 DirectionalLightDistanceFadeMAD;
	uint NumDirectionalLightCascades;
	float4 CascadeEndDepths;
	float4x4 DirectionalLightWorldToShadowMatrix[4];
	float4 DirectionalLightShadowmapMinMax[4];
	float4 DirectionalLightShadowmapAtlasBufferSize;
	float DirectionalLightDepthBias;
	uint DirectionalLightUseStaticShadowing;
	float4 DirectionalLightStaticShadowBufferSize;
	float4x4 DirectionalLightWorldToStaticShadow;
	Texture2D DirectionalLightShadowmapAtlas;
	SamplerState ShadowmapSampler;
	Texture2D DirectionalLightStaticShadowmap;
	SamplerState StaticShadowmapSampler;
	Buffer <float4> ForwardLocalLightBuffer;
	Buffer <uint> NumCulledLightsGrid;
	Buffer <uint> CulledLightDataGrid;
} Forward;
struct {
	uint NumLocalLights;
	uint NumReflectionCaptures;
	uint HasDirectionalLight;
	uint NumGridCells;
	int3 CulledGridSize;
	uint MaxCulledLightsPerCell;
	uint LightGridPixelSizeShift;
	float3 LightGridZParams;
	float3 DirectionalLightDirection;
	float3 DirectionalLightColor;
	float DirectionalLightVolumetricScatteringIntensity;
	uint DirectionalLightShadowMapChannelMask;
	float2 DirectionalLightDistanceFadeMAD;
	uint NumDirectionalLightCascades;
	float4 CascadeEndDepths;
	float4x4 DirectionalLightWorldToShadowMatrix[4];
	float4 DirectionalLightShadowmapMinMax[4];
	float4 DirectionalLightShadowmapAtlasBufferSize;
	float DirectionalLightDepthBias;
	uint DirectionalLightUseStaticShadowing;
	float4 DirectionalLightStaticShadowBufferSize;
	float4x4 DirectionalLightWorldToStaticShadow;
	Texture2D DirectionalLightShadowmapAtlas;
	SamplerState ShadowmapSampler;
	Texture2D DirectionalLightStaticShadowmap;
	SamplerState StaticShadowmapSampler;
	Buffer <float4> ForwardLocalLightBuffer;
	Buffer <uint> NumCulledLightsGrid;
	Buffer <uint> CulledLightDataGrid;
} ForwardISR;
struct {
	float4 SkyLightParameters;
	float SkyLightCubemapBrightness;
	TextureCube SkyLightCubemap;
	SamplerState SkyLightCubemapSampler;
	TextureCube SkyLightBlendDestinationCubemap;
	SamplerState SkyLightBlendDestinationCubemapSampler;
	TextureCubeArray ReflectionCubemap;
	SamplerState ReflectionCubemapSampler;
	Texture2D PreIntegratedGF;
	SamplerState PreIntegratedGFSampler;
} Reflection;
struct {
	float4 ReflectionPlane;
	float4 PlanarReflectionOrigin;
	float4 PlanarReflectionXAxis;
	float4 PlanarReflectionYAxis;
	float3x4 InverseTransposeMirrorMatrix;
	float3 PlanarReflectionParameters;
	float2 PlanarReflectionParameters2;
	float4x4 ProjectionWithExtraFOV[2];
	float4 PlanarReflectionScreenScaleBias[2];
	float2 PlanarReflectionScreenBound;
	bool bIsStereo;
	Texture2D PlanarReflectionTexture;
	SamplerState PlanarReflectionSampler;
} PlanarReflection;
struct {
	float4 ExponentialFogParameters;
	float4 ExponentialFogParameters2;
	float4 ExponentialFogColorParameter;
	float4 ExponentialFogParameters3;
	float4 InscatteringLightDirection;
	float4 DirectionalInscatteringColor;
	float2 SinCosInscatteringColorCubemapRotation;
	float3 FogInscatteringTextureParameters;
	float ApplyVolumetricFog;
	TextureCube FogInscatteringColorCubemap;
	SamplerState FogInscatteringColorSampler;
	Texture3D IntegratedLightScattering;
	SamplerState IntegratedLightScatteringSampler;
} Fog;
	Texture2D SSProfilesTexture;
} Shared;
struct {
	Texture2D SceneColorTexture;
	SamplerState SceneColorTextureSampler;
	Texture2D SceneDepthTexture;
	SamplerState SceneDepthTextureSampler;
	Texture2D<float> SceneDepthTextureNonMS;
	Texture2D GBufferATexture;
	Texture2D GBufferBTexture;
	Texture2D GBufferCTexture;
	Texture2D GBufferDTexture;
	Texture2D GBufferETexture;
	Texture2D GBufferVelocityTexture;
	Texture2D<float4> GBufferATextureNonMS;
	Texture2D<float4> GBufferBTextureNonMS;
	Texture2D<float4> GBufferCTextureNonMS;
	Texture2D<float4> GBufferDTextureNonMS;
	Texture2D<float4> GBufferETextureNonMS;
	Texture2D<float4> GBufferVelocityTextureNonMS;
	SamplerState GBufferATextureSampler;
	SamplerState GBufferBTextureSampler;
	SamplerState GBufferCTextureSampler;
	SamplerState GBufferDTextureSampler;
	SamplerState GBufferETextureSampler;
	SamplerState GBufferVelocityTextureSampler;
	Texture2D ScreenSpaceAOTexture;
	SamplerState ScreenSpaceAOTextureSampler;
	Texture2D<float> CustomDepthTextureNonMS;
	Texture2D CustomDepthTexture;
	SamplerState CustomDepthTextureSampler;
	Texture2D<uint2> CustomStencilTexture;
	Texture2D<uint2> SceneStencilTexture;
	Texture2D EyeAdaptation;
	Texture2D SceneColorCopyTexture;
	SamplerState SceneColorCopyTextureSampler;
} SceneTextures;
	float4 HZBUvFactorAndInvFactor;
	float4 PrevScreenPositionScaleBias;
	float PrevSceneColorPreExposureInv;
	Texture2D HZBTexture;
	SamplerState HZBSampler;
	Texture2D PrevSceneColor;
	SamplerState PrevSceneColorSampler;
	Texture3D TranslucencyLightingVolumeAmbientInner;
	SamplerState TranslucencyLightingVolumeAmbientInnerSampler;
	Texture3D TranslucencyLightingVolumeAmbientOuter;
	SamplerState TranslucencyLightingVolumeAmbientOuterSampler;
	Texture3D TranslucencyLightingVolumeDirectionalInner;
	SamplerState TranslucencyLightingVolumeDirectionalInnerSampler;
	Texture3D TranslucencyLightingVolumeDirectionalOuter;
	SamplerState TranslucencyLightingVolumeDirectionalOuterSampler;
} TranslucentBasePass = { { { TranslucentBasePass_Shared_Forward_NumLocalLights,TranslucentBasePass_Shared_Forward_NumReflectionCaptures,TranslucentBasePass_Shared_Forward_HasDirectionalLight,TranslucentBasePass_Shared_Forward_NumGridCells,TranslucentBasePass_Shared_Forward_CulledGridSize,TranslucentBasePass_Shared_Forward_MaxCulledLightsPerCell,TranslucentBasePass_Shared_Forward_LightGridPixelSizeShift,TranslucentBasePass_Shared_Forward_LightGridZParams,TranslucentBasePass_Shared_Forward_DirectionalLightDirection,TranslucentBasePass_Shared_Forward_DirectionalLightColor,TranslucentBasePass_Shared_Forward_DirectionalLightVolumetricScatteringIntensity,TranslucentBasePass_Shared_Forward_DirectionalLightShadowMapChannelMask,TranslucentBasePass_Shared_Forward_DirectionalLightDistanceFadeMAD,TranslucentBasePass_Shared_Forward_NumDirectionalLightCascades,TranslucentBasePass_Shared_Forward_CascadeEndDepths,TranslucentBasePass_Shared_Forward_DirectionalLightWorldToShadowMatrix,TranslucentBasePass_Shared_Forward_DirectionalLightShadowmapMinMax,TranslucentBasePass_Shared_Forward_DirectionalLightShadowmapAtlasBufferSize,TranslucentBasePass_Shared_Forward_DirectionalLightDepthBias,TranslucentBasePass_Shared_Forward_DirectionalLightUseStaticShadowing,TranslucentBasePass_Shared_Forward_DirectionalLightStaticShadowBufferSize,TranslucentBasePass_Shared_Forward_DirectionalLightWorldToStaticShadow,TranslucentBasePass_Shared_Forward_DirectionalLightShadowmapAtlas,TranslucentBasePass_Shared_Forward_ShadowmapSampler,TranslucentBasePass_Shared_Forward_DirectionalLightStaticShadowmap,TranslucentBasePass_Shared_Forward_StaticShadowmapSampler  ,TranslucentBasePass_Shared_Forward_ForwardLocalLightBuffer   ,TranslucentBasePass_Shared_Forward_NumCulledLightsGrid   ,TranslucentBasePass_Shared_Forward_CulledLightDataGrid  },{ TranslucentBasePass_Shared_ForwardISR_NumLocalLights,TranslucentBasePass_Shared_ForwardISR_NumReflectionCaptures,TranslucentBasePass_Shared_ForwardISR_HasDirectionalLight,TranslucentBasePass_Shared_ForwardISR_NumGridCells,TranslucentBasePass_Shared_ForwardISR_CulledGridSize,TranslucentBasePass_Shared_ForwardISR_MaxCulledLightsPerCell,TranslucentBasePass_Shared_ForwardISR_LightGridPixelSizeShift,TranslucentBasePass_Shared_ForwardISR_LightGridZParams,TranslucentBasePass_Shared_ForwardISR_DirectionalLightDirection,TranslucentBasePass_Shared_ForwardISR_DirectionalLightColor,TranslucentBasePass_Shared_ForwardISR_DirectionalLightVolumetricScatteringIntensity,TranslucentBasePass_Shared_ForwardISR_DirectionalLightShadowMapChannelMask,TranslucentBasePass_Shared_ForwardISR_DirectionalLightDistanceFadeMAD,TranslucentBasePass_Shared_ForwardISR_NumDirectionalLightCascades,TranslucentBasePass_Shared_ForwardISR_CascadeEndDepths,TranslucentBasePass_Shared_ForwardISR_DirectionalLightWorldToShadowMatrix,TranslucentBasePass_Shared_ForwardISR_DirectionalLightShadowmapMinMax,TranslucentBasePass_Shared_ForwardISR_DirectionalLightShadowmapAtlasBufferSize,TranslucentBasePass_Shared_ForwardISR_DirectionalLightDepthBias,TranslucentBasePass_Shared_ForwardISR_DirectionalLightUseStaticShadowing,TranslucentBasePass_Shared_ForwardISR_DirectionalLightStaticShadowBufferSize,TranslucentBasePass_Shared_ForwardISR_DirectionalLightWorldToStaticShadow,TranslucentBasePass_Shared_ForwardISR_DirectionalLightShadowmapAtlas,TranslucentBasePass_Shared_ForwardISR_ShadowmapSampler,TranslucentBasePass_Shared_ForwardISR_DirectionalLightStaticShadowmap,TranslucentBasePass_Shared_ForwardISR_StaticShadowmapSampler  ,TranslucentBasePass_Shared_ForwardISR_ForwardLocalLightBuffer   ,TranslucentBasePass_Shared_ForwardISR_NumCulledLightsGrid   ,TranslucentBasePass_Shared_ForwardISR_CulledLightDataGrid  },{ TranslucentBasePass_Shared_Reflection_SkyLightParameters,TranslucentBasePass_Shared_Reflection_SkyLightCubemapBrightness,TranslucentBasePass_Shared_Reflection_SkyLightCubemap,TranslucentBasePass_Shared_Reflection_SkyLightCubemapSampler,TranslucentBasePass_Shared_Reflection_SkyLightBlendDestinationCubemap,TranslucentBasePass_Shared_Reflection_SkyLightBlendDestinationCubemapSampler,TranslucentBasePass_Shared_Reflection_ReflectionCubemap,TranslucentBasePass_Shared_Reflection_ReflectionCubemapSampler,TranslucentBasePass_Shared_Reflection_PreIntegratedGF,TranslucentBasePass_Shared_Reflection_PreIntegratedGFSampler},{ TranslucentBasePass_Shared_PlanarReflection_ReflectionPlane,TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionOrigin,TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionXAxis,TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionYAxis,TranslucentBasePass_Shared_PlanarReflection_InverseTransposeMirrorMatrix,TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionParameters,TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionParameters2,TranslucentBasePass_Shared_PlanarReflection_ProjectionWithExtraFOV,TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionScreenScaleBias,TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionScreenBound,TranslucentBasePass_Shared_PlanarReflection_bIsStereo,TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionTexture,TranslucentBasePass_Shared_PlanarReflection_PlanarReflectionSampler},{ TranslucentBasePass_Shared_Fog_ExponentialFogParameters,TranslucentBasePass_Shared_Fog_ExponentialFogParameters2,TranslucentBasePass_Shared_Fog_ExponentialFogColorParameter,TranslucentBasePass_Shared_Fog_ExponentialFogParameters3,TranslucentBasePass_Shared_Fog_InscatteringLightDirection,TranslucentBasePass_Shared_Fog_DirectionalInscatteringColor,TranslucentBasePass_Shared_Fog_SinCosInscatteringColorCubemapRotation,TranslucentBasePass_Shared_Fog_FogInscatteringTextureParameters,TranslucentBasePass_Shared_Fog_ApplyVolumetricFog,TranslucentBasePass_Shared_Fog_FogInscatteringColorCubemap,TranslucentBasePass_Shared_Fog_FogInscatteringColorSampler,TranslucentBasePass_Shared_Fog_IntegratedLightScattering,TranslucentBasePass_Shared_Fog_IntegratedLightScatteringSampler},TranslucentBasePass_Shared_SSProfilesTexture},{ TranslucentBasePass_SceneTextures_SceneColorTexture,TranslucentBasePass_SceneTextures_SceneColorTextureSampler,TranslucentBasePass_SceneTextures_SceneDepthTexture,TranslucentBasePass_SceneTextures_SceneDepthTextureSampler,TranslucentBasePass_SceneTextures_SceneDepthTextureNonMS,TranslucentBasePass_SceneTextures_GBufferATexture,TranslucentBasePass_SceneTextures_GBufferBTexture,TranslucentBasePass_SceneTextures_GBufferCTexture,TranslucentBasePass_SceneTextures_GBufferDTexture,TranslucentBasePass_SceneTextures_GBufferETexture,TranslucentBasePass_SceneTextures_GBufferVelocityTexture,TranslucentBasePass_SceneTextures_GBufferATextureNonMS,TranslucentBasePass_SceneTextures_GBufferBTextureNonMS,TranslucentBasePass_SceneTextures_GBufferCTextureNonMS,TranslucentBasePass_SceneTextures_GBufferDTextureNonMS,TranslucentBasePass_SceneTextures_GBufferETextureNonMS,TranslucentBasePass_SceneTextures_GBufferVelocityTextureNonMS,TranslucentBasePass_SceneTextures_GBufferATextureSampler,TranslucentBasePass_SceneTextures_GBufferBTextureSampler,TranslucentBasePass_SceneTextures_GBufferCTextureSampler,TranslucentBasePass_SceneTextures_GBufferDTextureSampler,TranslucentBasePass_SceneTextures_GBufferETextureSampler,TranslucentBasePass_SceneTextures_GBufferVelocityTextureSampler,TranslucentBasePass_SceneTextures_ScreenSpaceAOTexture,TranslucentBasePass_SceneTextures_ScreenSpaceAOTextureSampler,TranslucentBasePass_SceneTextures_CustomDepthTextureNonMS,TranslucentBasePass_SceneTextures_CustomDepthTexture,TranslucentBasePass_SceneTextures_CustomDepthTextureSampler  ,TranslucentBasePass_SceneTextures_CustomStencilTexture   ,TranslucentBasePass_SceneTextures_SceneStencilTexture  ,TranslucentBasePass_SceneTextures_EyeAdaptation,TranslucentBasePass_SceneTextures_SceneColorCopyTexture,TranslucentBasePass_SceneTextures_SceneColorCopyTextureSampler},TranslucentBasePass_HZBUvFactorAndInvFactor,TranslucentBasePass_PrevScreenPositionScaleBias,TranslucentBasePass_PrevSceneColorPreExposureInv,TranslucentBasePass_HZBTexture,TranslucentBasePass_HZBSampler,TranslucentBasePass_PrevSceneColor,TranslucentBasePass_PrevSceneColorSampler,TranslucentBasePass_TranslucencyLightingVolumeAmbientInner,TranslucentBasePass_TranslucencyLightingVolumeAmbientInnerSampler,TranslucentBasePass_TranslucencyLightingVolumeAmbientOuter,TranslucentBasePass_TranslucencyLightingVolumeAmbientOuterSampler,TranslucentBasePass_TranslucencyLightingVolumeDirectionalInner,TranslucentBasePass_TranslucencyLightingVolumeDirectionalInnerSampler,TranslucentBasePass_TranslucencyLightingVolumeDirectionalOuter,TranslucentBasePass_TranslucencyLightingVolumeDirectionalOuterSampler*/
#line 11 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/OpaqueBasePass.ush"


cbuffer OpaqueBasePass
{
	uint OpaqueBasePass_Shared_Forward_NumLocalLights;
	uint OpaqueBasePass_Shared_Forward_NumReflectionCaptures;
	uint OpaqueBasePass_Shared_Forward_HasDirectionalLight;
	uint OpaqueBasePass_Shared_Forward_NumGridCells;
	int3 OpaqueBasePass_Shared_Forward_CulledGridSize;
	uint OpaqueBasePass_Shared_Forward_MaxCulledLightsPerCell;
	uint OpaqueBasePass_Shared_Forward_LightGridPixelSizeShift;
	uint PrePadding_OpaqueBasePass_Shared_Forward_36;
	uint PrePadding_OpaqueBasePass_Shared_Forward_40;
	uint PrePadding_OpaqueBasePass_Shared_Forward_44;
	float3 OpaqueBasePass_Shared_Forward_LightGridZParams;
	float PrePadding_OpaqueBasePass_Shared_Forward_60;
	float3 OpaqueBasePass_Shared_Forward_DirectionalLightDirection;
	float PrePadding_OpaqueBasePass_Shared_Forward_76;
	float3 OpaqueBasePass_Shared_Forward_DirectionalLightColor;
	float OpaqueBasePass_Shared_Forward_DirectionalLightVolumetricScatteringIntensity;
	uint OpaqueBasePass_Shared_Forward_DirectionalLightShadowMapChannelMask;
	uint PrePadding_OpaqueBasePass_Shared_Forward_100;
	float2 OpaqueBasePass_Shared_Forward_DirectionalLightDistanceFadeMAD;
	uint OpaqueBasePass_Shared_Forward_NumDirectionalLightCascades;
	uint PrePadding_OpaqueBasePass_Shared_Forward_116;
	uint PrePadding_OpaqueBasePass_Shared_Forward_120;
	uint PrePadding_OpaqueBasePass_Shared_Forward_124;
	float4 OpaqueBasePass_Shared_Forward_CascadeEndDepths;
	float4x4 OpaqueBasePass_Shared_Forward_DirectionalLightWorldToShadowMatrix[4];
	float4 OpaqueBasePass_Shared_Forward_DirectionalLightShadowmapMinMax[4];
	float4 OpaqueBasePass_Shared_Forward_DirectionalLightShadowmapAtlasBufferSize;
	float OpaqueBasePass_Shared_Forward_DirectionalLightDepthBias;
	uint OpaqueBasePass_Shared_Forward_DirectionalLightUseStaticShadowing;
	uint PrePadding_OpaqueBasePass_Shared_Forward_488;
	uint PrePadding_OpaqueBasePass_Shared_Forward_492;
	float4 OpaqueBasePass_Shared_Forward_DirectionalLightStaticShadowBufferSize;
	float4x4 OpaqueBasePass_Shared_Forward_DirectionalLightWorldToStaticShadow;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_576;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_580;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_584;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_588;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_592;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_596;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_600;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_604;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_608;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_612;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_616;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_620;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_624;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_628;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_632;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_636;
	uint OpaqueBasePass_Shared_ForwardISR_NumLocalLights;
	uint OpaqueBasePass_Shared_ForwardISR_NumReflectionCaptures;
	uint OpaqueBasePass_Shared_ForwardISR_HasDirectionalLight;
	uint OpaqueBasePass_Shared_ForwardISR_NumGridCells;
	int3 OpaqueBasePass_Shared_ForwardISR_CulledGridSize;
	uint OpaqueBasePass_Shared_ForwardISR_MaxCulledLightsPerCell;
	uint OpaqueBasePass_Shared_ForwardISR_LightGridPixelSizeShift;
	uint PrePadding_OpaqueBasePass_Shared_ForwardISR_676;
	uint PrePadding_OpaqueBasePass_Shared_ForwardISR_680;
	uint PrePadding_OpaqueBasePass_Shared_ForwardISR_684;
	float3 OpaqueBasePass_Shared_ForwardISR_LightGridZParams;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_700;
	float3 OpaqueBasePass_Shared_ForwardISR_DirectionalLightDirection;
	float PrePadding_OpaqueBasePass_Shared_ForwardISR_716;
	float3 OpaqueBasePass_Shared_ForwardISR_DirectionalLightColor;
	float OpaqueBasePass_Shared_ForwardISR_DirectionalLightVolumetricScatteringIntensity;
	uint OpaqueBasePass_Shared_ForwardISR_DirectionalLightShadowMapChannelMask;
	uint PrePadding_OpaqueBasePass_Shared_ForwardISR_740;
	float2 OpaqueBasePass_Shared_ForwardISR_DirectionalLightDistanceFadeMAD;
	uint OpaqueBasePass_Shared_ForwardISR_NumDirectionalLightCascades;
	uint PrePadding_OpaqueBasePass_Shared_ForwardISR_756;
	uint PrePadding_OpaqueBasePass_Shared_ForwardISR_760;
	uint PrePadding_OpaqueBasePass_Shared_ForwardISR_764;
	float4 OpaqueBasePass_Shared_ForwardISR_CascadeEndDepths;
	float4x4 OpaqueBasePass_Shared_ForwardISR_DirectionalLightWorldToShadowMatrix[4];
	float4 OpaqueBasePass_Shared_ForwardISR_DirectionalLightShadowmapMinMax[4];
	float4 OpaqueBasePass_Shared_ForwardISR_DirectionalLightShadowmapAtlasBufferSize;
	float OpaqueBasePass_Shared_ForwardISR_DirectionalLightDepthBias;
	uint OpaqueBasePass_Shared_ForwardISR_DirectionalLightUseStaticShadowing;
	uint PrePadding_OpaqueBasePass_Shared_ForwardISR_1128;
	uint PrePadding_OpaqueBasePass_Shared_ForwardISR_1132;
	float4 OpaqueBasePass_Shared_ForwardISR_DirectionalLightStaticShadowBufferSize;
	float4x4 OpaqueBasePass_Shared_ForwardISR_DirectionalLightWorldToStaticShadow;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1216;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1220;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1224;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1228;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1232;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1236;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1240;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1244;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1248;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1252;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1256;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1260;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1264;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1268;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1272;
	float PrePadding_OpaqueBasePass_Shared_Reflection_1276;
	float4 OpaqueBasePass_Shared_Reflection_SkyLightParameters;
	float OpaqueBasePass_Shared_Reflection_SkyLightCubemapBrightness;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1300;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1304;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1308;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1312;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1316;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1320;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1324;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1328;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1332;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1336;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1340;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1344;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1348;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1352;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1356;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1360;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1364;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1368;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1372;
	float4 OpaqueBasePass_Shared_PlanarReflection_ReflectionPlane;
	float4 OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionOrigin;
	float4 OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionXAxis;
	float4 OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionYAxis;
	float3x4 OpaqueBasePass_Shared_PlanarReflection_InverseTransposeMirrorMatrix;
	float3 OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionParameters;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1500;
	float2 OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionParameters2;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1512;
	float PrePadding_OpaqueBasePass_Shared_PlanarReflection_1516;
	float4x4 OpaqueBasePass_Shared_PlanarReflection_ProjectionWithExtraFOV[2];
	float4 OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionScreenScaleBias[2];
	float2 OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionScreenBound;
	bool OpaqueBasePass_Shared_PlanarReflection_bIsStereo;
	float PrePadding_OpaqueBasePass_Shared_Fog_1692;
	float PrePadding_OpaqueBasePass_Shared_Fog_1696;
	float PrePadding_OpaqueBasePass_Shared_Fog_1700;
	float PrePadding_OpaqueBasePass_Shared_Fog_1704;
	float PrePadding_OpaqueBasePass_Shared_Fog_1708;
	float4 OpaqueBasePass_Shared_Fog_ExponentialFogParameters;
	float4 OpaqueBasePass_Shared_Fog_ExponentialFogParameters2;
	float4 OpaqueBasePass_Shared_Fog_ExponentialFogColorParameter;
	float4 OpaqueBasePass_Shared_Fog_ExponentialFogParameters3;
	float4 OpaqueBasePass_Shared_Fog_InscatteringLightDirection;
	float4 OpaqueBasePass_Shared_Fog_DirectionalInscatteringColor;
	float2 OpaqueBasePass_Shared_Fog_SinCosInscatteringColorCubemapRotation;
	float PrePadding_OpaqueBasePass_Shared_Fog_1816;
	float PrePadding_OpaqueBasePass_Shared_Fog_1820;
	float3 OpaqueBasePass_Shared_Fog_FogInscatteringTextureParameters;
	float OpaqueBasePass_Shared_Fog_ApplyVolumetricFog;
	float PrePadding_OpaqueBasePass_1840;
	float PrePadding_OpaqueBasePass_1844;
	float PrePadding_OpaqueBasePass_1848;
	float PrePadding_OpaqueBasePass_1852;
	float PrePadding_OpaqueBasePass_1856;
	float PrePadding_OpaqueBasePass_1860;
	float PrePadding_OpaqueBasePass_1864;
	float PrePadding_OpaqueBasePass_1868;
	float PrePadding_OpaqueBasePass_1872;
	float PrePadding_OpaqueBasePass_1876;
	float PrePadding_OpaqueBasePass_1880;
	float PrePadding_OpaqueBasePass_1884;
	int OpaqueBasePass_UseForwardScreenSpaceShadowMask;
}
Texture2D OpaqueBasePass_Shared_Forward_DirectionalLightShadowmapAtlas;
SamplerState OpaqueBasePass_Shared_Forward_ShadowmapSampler;
Texture2D OpaqueBasePass_Shared_Forward_DirectionalLightStaticShadowmap;
SamplerState OpaqueBasePass_Shared_Forward_StaticShadowmapSampler;
Buffer <float4> OpaqueBasePass_Shared_Forward_ForwardLocalLightBuffer;
Buffer <uint> OpaqueBasePass_Shared_Forward_NumCulledLightsGrid;
Buffer <uint> OpaqueBasePass_Shared_Forward_CulledLightDataGrid;
Texture2D OpaqueBasePass_Shared_ForwardISR_DirectionalLightShadowmapAtlas;
SamplerState OpaqueBasePass_Shared_ForwardISR_ShadowmapSampler;
Texture2D OpaqueBasePass_Shared_ForwardISR_DirectionalLightStaticShadowmap;
SamplerState OpaqueBasePass_Shared_ForwardISR_StaticShadowmapSampler;
Buffer <float4> OpaqueBasePass_Shared_ForwardISR_ForwardLocalLightBuffer;
Buffer <uint> OpaqueBasePass_Shared_ForwardISR_NumCulledLightsGrid;
Buffer <uint> OpaqueBasePass_Shared_ForwardISR_CulledLightDataGrid;
TextureCube OpaqueBasePass_Shared_Reflection_SkyLightCubemap;
SamplerState OpaqueBasePass_Shared_Reflection_SkyLightCubemapSampler;
TextureCube OpaqueBasePass_Shared_Reflection_SkyLightBlendDestinationCubemap;
SamplerState OpaqueBasePass_Shared_Reflection_SkyLightBlendDestinationCubemapSampler;
TextureCubeArray OpaqueBasePass_Shared_Reflection_ReflectionCubemap;
SamplerState OpaqueBasePass_Shared_Reflection_ReflectionCubemapSampler;
Texture2D OpaqueBasePass_Shared_Reflection_PreIntegratedGF;
SamplerState OpaqueBasePass_Shared_Reflection_PreIntegratedGFSampler;
Texture2D OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionTexture;
SamplerState OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionSampler;
TextureCube OpaqueBasePass_Shared_Fog_FogInscatteringColorCubemap;
SamplerState OpaqueBasePass_Shared_Fog_FogInscatteringColorSampler;
Texture3D OpaqueBasePass_Shared_Fog_IntegratedLightScattering;
SamplerState OpaqueBasePass_Shared_Fog_IntegratedLightScatteringSampler;
Texture2D OpaqueBasePass_Shared_SSProfilesTexture;
Texture2D OpaqueBasePass_ForwardScreenSpaceShadowMaskTexture;
Texture2D OpaqueBasePass_IndirectOcclusionTexture;
Texture2D OpaqueBasePass_ResolvedSceneDepthTexture;
Texture2D OpaqueBasePass_DBufferATexture;
SamplerState OpaqueBasePass_DBufferATextureSampler;
Texture2D OpaqueBasePass_DBufferBTexture;
SamplerState OpaqueBasePass_DBufferBTextureSampler;
Texture2D OpaqueBasePass_DBufferCTexture;
SamplerState OpaqueBasePass_DBufferCTextureSampler;
Texture2D<uint> OpaqueBasePass_DBufferRenderMask;
Texture2D OpaqueBasePass_EyeAdaptation;
/*atic const struct
{
struct {
struct {
	uint NumLocalLights;
	uint NumReflectionCaptures;
	uint HasDirectionalLight;
	uint NumGridCells;
	int3 CulledGridSize;
	uint MaxCulledLightsPerCell;
	uint LightGridPixelSizeShift;
	float3 LightGridZParams;
	float3 DirectionalLightDirection;
	float3 DirectionalLightColor;
	float DirectionalLightVolumetricScatteringIntensity;
	uint DirectionalLightShadowMapChannelMask;
	float2 DirectionalLightDistanceFadeMAD;
	uint NumDirectionalLightCascades;
	float4 CascadeEndDepths;
	float4x4 DirectionalLightWorldToShadowMatrix[4];
	float4 DirectionalLightShadowmapMinMax[4];
	float4 DirectionalLightShadowmapAtlasBufferSize;
	float DirectionalLightDepthBias;
	uint DirectionalLightUseStaticShadowing;
	float4 DirectionalLightStaticShadowBufferSize;
	float4x4 DirectionalLightWorldToStaticShadow;
	Texture2D DirectionalLightShadowmapAtlas;
	SamplerState ShadowmapSampler;
	Texture2D DirectionalLightStaticShadowmap;
	SamplerState StaticShadowmapSampler;
	Buffer <float4> ForwardLocalLightBuffer;
	Buffer <uint> NumCulledLightsGrid;
	Buffer <uint> CulledLightDataGrid;
} Forward;
struct {
	uint NumLocalLights;
	uint NumReflectionCaptures;
	uint HasDirectionalLight;
	uint NumGridCells;
	int3 CulledGridSize;
	uint MaxCulledLightsPerCell;
	uint LightGridPixelSizeShift;
	float3 LightGridZParams;
	float3 DirectionalLightDirection;
	float3 DirectionalLightColor;
	float DirectionalLightVolumetricScatteringIntensity;
	uint DirectionalLightShadowMapChannelMask;
	float2 DirectionalLightDistanceFadeMAD;
	uint NumDirectionalLightCascades;
	float4 CascadeEndDepths;
	float4x4 DirectionalLightWorldToShadowMatrix[4];
	float4 DirectionalLightShadowmapMinMax[4];
	float4 DirectionalLightShadowmapAtlasBufferSize;
	float DirectionalLightDepthBias;
	uint DirectionalLightUseStaticShadowing;
	float4 DirectionalLightStaticShadowBufferSize;
	float4x4 DirectionalLightWorldToStaticShadow;
	Texture2D DirectionalLightShadowmapAtlas;
	SamplerState ShadowmapSampler;
	Texture2D DirectionalLightStaticShadowmap;
	SamplerState StaticShadowmapSampler;
	Buffer <float4> ForwardLocalLightBuffer;
	Buffer <uint> NumCulledLightsGrid;
	Buffer <uint> CulledLightDataGrid;
} ForwardISR;
struct {
	float4 SkyLightParameters;
	float SkyLightCubemapBrightness;
	TextureCube SkyLightCubemap;
	SamplerState SkyLightCubemapSampler;
	TextureCube SkyLightBlendDestinationCubemap;
	SamplerState SkyLightBlendDestinationCubemapSampler;
	TextureCubeArray ReflectionCubemap;
	SamplerState ReflectionCubemapSampler;
	Texture2D PreIntegratedGF;
	SamplerState PreIntegratedGFSampler;
} Reflection;
struct {
	float4 ReflectionPlane;
	float4 PlanarReflectionOrigin;
	float4 PlanarReflectionXAxis;
	float4 PlanarReflectionYAxis;
	float3x4 InverseTransposeMirrorMatrix;
	float3 PlanarReflectionParameters;
	float2 PlanarReflectionParameters2;
	float4x4 ProjectionWithExtraFOV[2];
	float4 PlanarReflectionScreenScaleBias[2];
	float2 PlanarReflectionScreenBound;
	bool bIsStereo;
	Texture2D PlanarReflectionTexture;
	SamplerState PlanarReflectionSampler;
} PlanarReflection;
struct {
	float4 ExponentialFogParameters;
	float4 ExponentialFogParameters2;
	float4 ExponentialFogColorParameter;
	float4 ExponentialFogParameters3;
	float4 InscatteringLightDirection;
	float4 DirectionalInscatteringColor;
	float2 SinCosInscatteringColorCubemapRotation;
	float3 FogInscatteringTextureParameters;
	float ApplyVolumetricFog;
	TextureCube FogInscatteringColorCubemap;
	SamplerState FogInscatteringColorSampler;
	Texture3D IntegratedLightScattering;
	SamplerState IntegratedLightScatteringSampler;
} Fog;
	Texture2D SSProfilesTexture;
} Shared;
	int UseForwardScreenSpaceShadowMask;
	Texture2D ForwardScreenSpaceShadowMaskTexture;
	Texture2D IndirectOcclusionTexture;
	Texture2D ResolvedSceneDepthTexture;
	Texture2D DBufferATexture;
	SamplerState DBufferATextureSampler;
	Texture2D DBufferBTexture;
	SamplerState DBufferBTextureSampler;
	Texture2D DBufferCTexture;
	SamplerState DBufferCTextureSampler;
	Texture2D<uint> DBufferRenderMask;
	Texture2D EyeAdaptation;
} OpaqueBasePass = { { { OpaqueBasePass_Shared_Forward_NumLocalLights,OpaqueBasePass_Shared_Forward_NumReflectionCaptures,OpaqueBasePass_Shared_Forward_HasDirectionalLight,OpaqueBasePass_Shared_Forward_NumGridCells,OpaqueBasePass_Shared_Forward_CulledGridSize,OpaqueBasePass_Shared_Forward_MaxCulledLightsPerCell,OpaqueBasePass_Shared_Forward_LightGridPixelSizeShift,OpaqueBasePass_Shared_Forward_LightGridZParams,OpaqueBasePass_Shared_Forward_DirectionalLightDirection,OpaqueBasePass_Shared_Forward_DirectionalLightColor,OpaqueBasePass_Shared_Forward_DirectionalLightVolumetricScatteringIntensity,OpaqueBasePass_Shared_Forward_DirectionalLightShadowMapChannelMask,OpaqueBasePass_Shared_Forward_DirectionalLightDistanceFadeMAD,OpaqueBasePass_Shared_Forward_NumDirectionalLightCascades,OpaqueBasePass_Shared_Forward_CascadeEndDepths,OpaqueBasePass_Shared_Forward_DirectionalLightWorldToShadowMatrix,OpaqueBasePass_Shared_Forward_DirectionalLightShadowmapMinMax,OpaqueBasePass_Shared_Forward_DirectionalLightShadowmapAtlasBufferSize,OpaqueBasePass_Shared_Forward_DirectionalLightDepthBias,OpaqueBasePass_Shared_Forward_DirectionalLightUseStaticShadowing,OpaqueBasePass_Shared_Forward_DirectionalLightStaticShadowBufferSize,OpaqueBasePass_Shared_Forward_DirectionalLightWorldToStaticShadow,OpaqueBasePass_Shared_Forward_DirectionalLightShadowmapAtlas,OpaqueBasePass_Shared_Forward_ShadowmapSampler,OpaqueBasePass_Shared_Forward_DirectionalLightStaticShadowmap,OpaqueBasePass_Shared_Forward_StaticShadowmapSampler  ,OpaqueBasePass_Shared_Forward_ForwardLocalLightBuffer   ,OpaqueBasePass_Shared_Forward_NumCulledLightsGrid   ,OpaqueBasePass_Shared_Forward_CulledLightDataGrid  },{ OpaqueBasePass_Shared_ForwardISR_NumLocalLights,OpaqueBasePass_Shared_ForwardISR_NumReflectionCaptures,OpaqueBasePass_Shared_ForwardISR_HasDirectionalLight,OpaqueBasePass_Shared_ForwardISR_NumGridCells,OpaqueBasePass_Shared_ForwardISR_CulledGridSize,OpaqueBasePass_Shared_ForwardISR_MaxCulledLightsPerCell,OpaqueBasePass_Shared_ForwardISR_LightGridPixelSizeShift,OpaqueBasePass_Shared_ForwardISR_LightGridZParams,OpaqueBasePass_Shared_ForwardISR_DirectionalLightDirection,OpaqueBasePass_Shared_ForwardISR_DirectionalLightColor,OpaqueBasePass_Shared_ForwardISR_DirectionalLightVolumetricScatteringIntensity,OpaqueBasePass_Shared_ForwardISR_DirectionalLightShadowMapChannelMask,OpaqueBasePass_Shared_ForwardISR_DirectionalLightDistanceFadeMAD,OpaqueBasePass_Shared_ForwardISR_NumDirectionalLightCascades,OpaqueBasePass_Shared_ForwardISR_CascadeEndDepths,OpaqueBasePass_Shared_ForwardISR_DirectionalLightWorldToShadowMatrix,OpaqueBasePass_Shared_ForwardISR_DirectionalLightShadowmapMinMax,OpaqueBasePass_Shared_ForwardISR_DirectionalLightShadowmapAtlasBufferSize,OpaqueBasePass_Shared_ForwardISR_DirectionalLightDepthBias,OpaqueBasePass_Shared_ForwardISR_DirectionalLightUseStaticShadowing,OpaqueBasePass_Shared_ForwardISR_DirectionalLightStaticShadowBufferSize,OpaqueBasePass_Shared_ForwardISR_DirectionalLightWorldToStaticShadow,OpaqueBasePass_Shared_ForwardISR_DirectionalLightShadowmapAtlas,OpaqueBasePass_Shared_ForwardISR_ShadowmapSampler,OpaqueBasePass_Shared_ForwardISR_DirectionalLightStaticShadowmap,OpaqueBasePass_Shared_ForwardISR_StaticShadowmapSampler  ,OpaqueBasePass_Shared_ForwardISR_ForwardLocalLightBuffer   ,OpaqueBasePass_Shared_ForwardISR_NumCulledLightsGrid   ,OpaqueBasePass_Shared_ForwardISR_CulledLightDataGrid  },{ OpaqueBasePass_Shared_Reflection_SkyLightParameters,OpaqueBasePass_Shared_Reflection_SkyLightCubemapBrightness,OpaqueBasePass_Shared_Reflection_SkyLightCubemap,OpaqueBasePass_Shared_Reflection_SkyLightCubemapSampler,OpaqueBasePass_Shared_Reflection_SkyLightBlendDestinationCubemap,OpaqueBasePass_Shared_Reflection_SkyLightBlendDestinationCubemapSampler,OpaqueBasePass_Shared_Reflection_ReflectionCubemap,OpaqueBasePass_Shared_Reflection_ReflectionCubemapSampler,OpaqueBasePass_Shared_Reflection_PreIntegratedGF,OpaqueBasePass_Shared_Reflection_PreIntegratedGFSampler},{ OpaqueBasePass_Shared_PlanarReflection_ReflectionPlane,OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionOrigin,OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionXAxis,OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionYAxis,OpaqueBasePass_Shared_PlanarReflection_InverseTransposeMirrorMatrix,OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionParameters,OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionParameters2,OpaqueBasePass_Shared_PlanarReflection_ProjectionWithExtraFOV,OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionScreenScaleBias,OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionScreenBound,OpaqueBasePass_Shared_PlanarReflection_bIsStereo,OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionTexture,OpaqueBasePass_Shared_PlanarReflection_PlanarReflectionSampler},{ OpaqueBasePass_Shared_Fog_ExponentialFogParameters,OpaqueBasePass_Shared_Fog_ExponentialFogParameters2,OpaqueBasePass_Shared_Fog_ExponentialFogColorParameter,OpaqueBasePass_Shared_Fog_ExponentialFogParameters3,OpaqueBasePass_Shared_Fog_InscatteringLightDirection,OpaqueBasePass_Shared_Fog_DirectionalInscatteringColor,OpaqueBasePass_Shared_Fog_SinCosInscatteringColorCubemapRotation,OpaqueBasePass_Shared_Fog_FogInscatteringTextureParameters,OpaqueBasePass_Shared_Fog_ApplyVolumetricFog,OpaqueBasePass_Shared_Fog_FogInscatteringColorCubemap,OpaqueBasePass_Shared_Fog_FogInscatteringColorSampler,OpaqueBasePass_Shared_Fog_IntegratedLightScattering,OpaqueBasePass_Shared_Fog_IntegratedLightScatteringSampler},OpaqueBasePass_Shared_SSProfilesTexture},OpaqueBasePass_UseForwardScreenSpaceShadowMask,OpaqueBasePass_ForwardScreenSpaceShadowMaskTexture,OpaqueBasePass_IndirectOcclusionTexture,OpaqueBasePass_ResolvedSceneDepthTexture,OpaqueBasePass_DBufferATexture,OpaqueBasePass_DBufferATextureSampler,OpaqueBasePass_DBufferBTexture,OpaqueBasePass_DBufferBTextureSampler,OpaqueBasePass_DBufferCTexture,OpaqueBasePass_DBufferCTextureSampler,OpaqueBasePass_DBufferRenderMask,OpaqueBasePass_EyeAdaptation*/
#line 12 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/BasePass.ush"


cbuffer BasePass
{
	uint BasePass_Forward_NumLocalLights;
	uint BasePass_Forward_NumReflectionCaptures;
	uint BasePass_Forward_HasDirectionalLight;
	uint BasePass_Forward_NumGridCells;
	int3 BasePass_Forward_CulledGridSize;
	uint BasePass_Forward_MaxCulledLightsPerCell;
	uint BasePass_Forward_LightGridPixelSizeShift;
	uint PrePadding_BasePass_Forward_36;
	uint PrePadding_BasePass_Forward_40;
	uint PrePadding_BasePass_Forward_44;
	float3 BasePass_Forward_LightGridZParams;
	float PrePadding_BasePass_Forward_60;
	float3 BasePass_Forward_DirectionalLightDirection;
	float PrePadding_BasePass_Forward_76;
	float3 BasePass_Forward_DirectionalLightColor;
	float BasePass_Forward_DirectionalLightVolumetricScatteringIntensity;
	uint BasePass_Forward_DirectionalLightShadowMapChannelMask;
	uint PrePadding_BasePass_Forward_100;
	float2 BasePass_Forward_DirectionalLightDistanceFadeMAD;
	uint BasePass_Forward_NumDirectionalLightCascades;
	uint PrePadding_BasePass_Forward_116;
	uint PrePadding_BasePass_Forward_120;
	uint PrePadding_BasePass_Forward_124;
	float4 BasePass_Forward_CascadeEndDepths;
	float4x4 BasePass_Forward_DirectionalLightWorldToShadowMatrix[4];
	float4 BasePass_Forward_DirectionalLightShadowmapMinMax[4];
	float4 BasePass_Forward_DirectionalLightShadowmapAtlasBufferSize;
	float BasePass_Forward_DirectionalLightDepthBias;
	uint BasePass_Forward_DirectionalLightUseStaticShadowing;
	uint PrePadding_BasePass_Forward_488;
	uint PrePadding_BasePass_Forward_492;
	float4 BasePass_Forward_DirectionalLightStaticShadowBufferSize;
	float4x4 BasePass_Forward_DirectionalLightWorldToStaticShadow;
	float PrePadding_BasePass_ForwardISR_576;
	float PrePadding_BasePass_ForwardISR_580;
	float PrePadding_BasePass_ForwardISR_584;
	float PrePadding_BasePass_ForwardISR_588;
	float PrePadding_BasePass_ForwardISR_592;
	float PrePadding_BasePass_ForwardISR_596;
	float PrePadding_BasePass_ForwardISR_600;
	float PrePadding_BasePass_ForwardISR_604;
	float PrePadding_BasePass_ForwardISR_608;
	float PrePadding_BasePass_ForwardISR_612;
	float PrePadding_BasePass_ForwardISR_616;
	float PrePadding_BasePass_ForwardISR_620;
	float PrePadding_BasePass_ForwardISR_624;
	float PrePadding_BasePass_ForwardISR_628;
	float PrePadding_BasePass_ForwardISR_632;
	float PrePadding_BasePass_ForwardISR_636;
	uint BasePass_ForwardISR_NumLocalLights;
	uint BasePass_ForwardISR_NumReflectionCaptures;
	uint BasePass_ForwardISR_HasDirectionalLight;
	uint BasePass_ForwardISR_NumGridCells;
	int3 BasePass_ForwardISR_CulledGridSize;
	uint BasePass_ForwardISR_MaxCulledLightsPerCell;
	uint BasePass_ForwardISR_LightGridPixelSizeShift;
	uint PrePadding_BasePass_ForwardISR_676;
	uint PrePadding_BasePass_ForwardISR_680;
	uint PrePadding_BasePass_ForwardISR_684;
	float3 BasePass_ForwardISR_LightGridZParams;
	float PrePadding_BasePass_ForwardISR_700;
	float3 BasePass_ForwardISR_DirectionalLightDirection;
	float PrePadding_BasePass_ForwardISR_716;
	float3 BasePass_ForwardISR_DirectionalLightColor;
	float BasePass_ForwardISR_DirectionalLightVolumetricScatteringIntensity;
	uint BasePass_ForwardISR_DirectionalLightShadowMapChannelMask;
	uint PrePadding_BasePass_ForwardISR_740;
	float2 BasePass_ForwardISR_DirectionalLightDistanceFadeMAD;
	uint BasePass_ForwardISR_NumDirectionalLightCascades;
	uint PrePadding_BasePass_ForwardISR_756;
	uint PrePadding_BasePass_ForwardISR_760;
	uint PrePadding_BasePass_ForwardISR_764;
	float4 BasePass_ForwardISR_CascadeEndDepths;
	float4x4 BasePass_ForwardISR_DirectionalLightWorldToShadowMatrix[4];
	float4 BasePass_ForwardISR_DirectionalLightShadowmapMinMax[4];
	float4 BasePass_ForwardISR_DirectionalLightShadowmapAtlasBufferSize;
	float BasePass_ForwardISR_DirectionalLightDepthBias;
	uint BasePass_ForwardISR_DirectionalLightUseStaticShadowing;
	uint PrePadding_BasePass_ForwardISR_1128;
	uint PrePadding_BasePass_ForwardISR_1132;
	float4 BasePass_ForwardISR_DirectionalLightStaticShadowBufferSize;
	float4x4 BasePass_ForwardISR_DirectionalLightWorldToStaticShadow;
	float PrePadding_BasePass_Reflection_1216;
	float PrePadding_BasePass_Reflection_1220;
	float PrePadding_BasePass_Reflection_1224;
	float PrePadding_BasePass_Reflection_1228;
	float PrePadding_BasePass_Reflection_1232;
	float PrePadding_BasePass_Reflection_1236;
	float PrePadding_BasePass_Reflection_1240;
	float PrePadding_BasePass_Reflection_1244;
	float PrePadding_BasePass_Reflection_1248;
	float PrePadding_BasePass_Reflection_1252;
	float PrePadding_BasePass_Reflection_1256;
	float PrePadding_BasePass_Reflection_1260;
	float PrePadding_BasePass_Reflection_1264;
	float PrePadding_BasePass_Reflection_1268;
	float PrePadding_BasePass_Reflection_1272;
	float PrePadding_BasePass_Reflection_1276;
	float4 BasePass_Reflection_SkyLightParameters;
	float BasePass_Reflection_SkyLightCubemapBrightness;
	float PrePadding_BasePass_PlanarReflection_1300;
	float PrePadding_BasePass_PlanarReflection_1304;
	float PrePadding_BasePass_PlanarReflection_1308;
	float PrePadding_BasePass_PlanarReflection_1312;
	float PrePadding_BasePass_PlanarReflection_1316;
	float PrePadding_BasePass_PlanarReflection_1320;
	float PrePadding_BasePass_PlanarReflection_1324;
	float PrePadding_BasePass_PlanarReflection_1328;
	float PrePadding_BasePass_PlanarReflection_1332;
	float PrePadding_BasePass_PlanarReflection_1336;
	float PrePadding_BasePass_PlanarReflection_1340;
	float PrePadding_BasePass_PlanarReflection_1344;
	float PrePadding_BasePass_PlanarReflection_1348;
	float PrePadding_BasePass_PlanarReflection_1352;
	float PrePadding_BasePass_PlanarReflection_1356;
	float PrePadding_BasePass_PlanarReflection_1360;
	float PrePadding_BasePass_PlanarReflection_1364;
	float PrePadding_BasePass_PlanarReflection_1368;
	float PrePadding_BasePass_PlanarReflection_1372;
	float4 BasePass_PlanarReflection_ReflectionPlane;
	float4 BasePass_PlanarReflection_PlanarReflectionOrigin;
	float4 BasePass_PlanarReflection_PlanarReflectionXAxis;
	float4 BasePass_PlanarReflection_PlanarReflectionYAxis;
	float3x4 BasePass_PlanarReflection_InverseTransposeMirrorMatrix;
	float3 BasePass_PlanarReflection_PlanarReflectionParameters;
	float PrePadding_BasePass_PlanarReflection_1500;
	float2 BasePass_PlanarReflection_PlanarReflectionParameters2;
	float PrePadding_BasePass_PlanarReflection_1512;
	float PrePadding_BasePass_PlanarReflection_1516;
	float4x4 BasePass_PlanarReflection_ProjectionWithExtraFOV[2];
	float4 BasePass_PlanarReflection_PlanarReflectionScreenScaleBias[2];
	float2 BasePass_PlanarReflection_PlanarReflectionScreenBound;
	bool BasePass_PlanarReflection_bIsStereo;
	float PrePadding_BasePass_Fog_1692;
	float PrePadding_BasePass_Fog_1696;
	float PrePadding_BasePass_Fog_1700;
	float PrePadding_BasePass_Fog_1704;
	float PrePadding_BasePass_Fog_1708;
	float4 BasePass_Fog_ExponentialFogParameters;
	float4 BasePass_Fog_ExponentialFogParameters2;
	float4 BasePass_Fog_ExponentialFogColorParameter;
	float4 BasePass_Fog_ExponentialFogParameters3;
	float4 BasePass_Fog_InscatteringLightDirection;
	float4 BasePass_Fog_DirectionalInscatteringColor;
	float2 BasePass_Fog_SinCosInscatteringColorCubemapRotation;
	float PrePadding_BasePass_Fog_1816;
	float PrePadding_BasePass_Fog_1820;
	float3 BasePass_Fog_FogInscatteringTextureParameters;
	float BasePass_Fog_ApplyVolumetricFog;
}
Texture2D BasePass_Forward_DirectionalLightShadowmapAtlas;
SamplerState BasePass_Forward_ShadowmapSampler;
Texture2D BasePass_Forward_DirectionalLightStaticShadowmap;
SamplerState BasePass_Forward_StaticShadowmapSampler;
Buffer <float4> BasePass_Forward_ForwardLocalLightBuffer;
Buffer <uint> BasePass_Forward_NumCulledLightsGrid;
Buffer <uint> BasePass_Forward_CulledLightDataGrid;
Texture2D BasePass_ForwardISR_DirectionalLightShadowmapAtlas;
SamplerState BasePass_ForwardISR_ShadowmapSampler;
Texture2D BasePass_ForwardISR_DirectionalLightStaticShadowmap;
SamplerState BasePass_ForwardISR_StaticShadowmapSampler;
Buffer <float4> BasePass_ForwardISR_ForwardLocalLightBuffer;
Buffer <uint> BasePass_ForwardISR_NumCulledLightsGrid;
Buffer <uint> BasePass_ForwardISR_CulledLightDataGrid;
TextureCube BasePass_Reflection_SkyLightCubemap;
SamplerState BasePass_Reflection_SkyLightCubemapSampler;
TextureCube BasePass_Reflection_SkyLightBlendDestinationCubemap;
SamplerState BasePass_Reflection_SkyLightBlendDestinationCubemapSampler;
TextureCubeArray BasePass_Reflection_ReflectionCubemap;
SamplerState BasePass_Reflection_ReflectionCubemapSampler;
Texture2D BasePass_Reflection_PreIntegratedGF;
SamplerState BasePass_Reflection_PreIntegratedGFSampler;
Texture2D BasePass_PlanarReflection_PlanarReflectionTexture;
SamplerState BasePass_PlanarReflection_PlanarReflectionSampler;
TextureCube BasePass_Fog_FogInscatteringColorCubemap;
SamplerState BasePass_Fog_FogInscatteringColorSampler;
Texture3D BasePass_Fog_IntegratedLightScattering;
SamplerState BasePass_Fog_IntegratedLightScatteringSampler;
Texture2D BasePass_SSProfilesTexture;
/*atic const struct
{
struct {
	uint NumLocalLights;
	uint NumReflectionCaptures;
	uint HasDirectionalLight;
	uint NumGridCells;
	int3 CulledGridSize;
	uint MaxCulledLightsPerCell;
	uint LightGridPixelSizeShift;
	float3 LightGridZParams;
	float3 DirectionalLightDirection;
	float3 DirectionalLightColor;
	float DirectionalLightVolumetricScatteringIntensity;
	uint DirectionalLightShadowMapChannelMask;
	float2 DirectionalLightDistanceFadeMAD;
	uint NumDirectionalLightCascades;
	float4 CascadeEndDepths;
	float4x4 DirectionalLightWorldToShadowMatrix[4];
	float4 DirectionalLightShadowmapMinMax[4];
	float4 DirectionalLightShadowmapAtlasBufferSize;
	float DirectionalLightDepthBias;
	uint DirectionalLightUseStaticShadowing;
	float4 DirectionalLightStaticShadowBufferSize;
	float4x4 DirectionalLightWorldToStaticShadow;
	Texture2D DirectionalLightShadowmapAtlas;
	SamplerState ShadowmapSampler;
	Texture2D DirectionalLightStaticShadowmap;
	SamplerState StaticShadowmapSampler;
	Buffer <float4> ForwardLocalLightBuffer;
	Buffer <uint> NumCulledLightsGrid;
	Buffer <uint> CulledLightDataGrid;
} Forward;
struct {
	uint NumLocalLights;
	uint NumReflectionCaptures;
	uint HasDirectionalLight;
	uint NumGridCells;
	int3 CulledGridSize;
	uint MaxCulledLightsPerCell;
	uint LightGridPixelSizeShift;
	float3 LightGridZParams;
	float3 DirectionalLightDirection;
	float3 DirectionalLightColor;
	float DirectionalLightVolumetricScatteringIntensity;
	uint DirectionalLightShadowMapChannelMask;
	float2 DirectionalLightDistanceFadeMAD;
	uint NumDirectionalLightCascades;
	float4 CascadeEndDepths;
	float4x4 DirectionalLightWorldToShadowMatrix[4];
	float4 DirectionalLightShadowmapMinMax[4];
	float4 DirectionalLightShadowmapAtlasBufferSize;
	float DirectionalLightDepthBias;
	uint DirectionalLightUseStaticShadowing;
	float4 DirectionalLightStaticShadowBufferSize;
	float4x4 DirectionalLightWorldToStaticShadow;
	Texture2D DirectionalLightShadowmapAtlas;
	SamplerState ShadowmapSampler;
	Texture2D DirectionalLightStaticShadowmap;
	SamplerState StaticShadowmapSampler;
	Buffer <float4> ForwardLocalLightBuffer;
	Buffer <uint> NumCulledLightsGrid;
	Buffer <uint> CulledLightDataGrid;
} ForwardISR;
struct {
	float4 SkyLightParameters;
	float SkyLightCubemapBrightness;
	TextureCube SkyLightCubemap;
	SamplerState SkyLightCubemapSampler;
	TextureCube SkyLightBlendDestinationCubemap;
	SamplerState SkyLightBlendDestinationCubemapSampler;
	TextureCubeArray ReflectionCubemap;
	SamplerState ReflectionCubemapSampler;
	Texture2D PreIntegratedGF;
	SamplerState PreIntegratedGFSampler;
} Reflection;
struct {
	float4 ReflectionPlane;
	float4 PlanarReflectionOrigin;
	float4 PlanarReflectionXAxis;
	float4 PlanarReflectionYAxis;
	float3x4 InverseTransposeMirrorMatrix;
	float3 PlanarReflectionParameters;
	float2 PlanarReflectionParameters2;
	float4x4 ProjectionWithExtraFOV[2];
	float4 PlanarReflectionScreenScaleBias[2];
	float2 PlanarReflectionScreenBound;
	bool bIsStereo;
	Texture2D PlanarReflectionTexture;
	SamplerState PlanarReflectionSampler;
} PlanarReflection;
struct {
	float4 ExponentialFogParameters;
	float4 ExponentialFogParameters2;
	float4 ExponentialFogColorParameter;
	float4 ExponentialFogParameters3;
	float4 InscatteringLightDirection;
	float4 DirectionalInscatteringColor;
	float2 SinCosInscatteringColorCubemapRotation;
	float3 FogInscatteringTextureParameters;
	float ApplyVolumetricFog;
	TextureCube FogInscatteringColorCubemap;
	SamplerState FogInscatteringColorSampler;
	Texture3D IntegratedLightScattering;
	SamplerState IntegratedLightScatteringSampler;
} Fog;
	Texture2D SSProfilesTexture;
} BasePass = { { BasePass_Forward_NumLocalLights,BasePass_Forward_NumReflectionCaptures,BasePass_Forward_HasDirectionalLight,BasePass_Forward_NumGridCells,BasePass_Forward_CulledGridSize,BasePass_Forward_MaxCulledLightsPerCell,BasePass_Forward_LightGridPixelSizeShift,BasePass_Forward_LightGridZParams,BasePass_Forward_DirectionalLightDirection,BasePass_Forward_DirectionalLightColor,BasePass_Forward_DirectionalLightVolumetricScatteringIntensity,BasePass_Forward_DirectionalLightShadowMapChannelMask,BasePass_Forward_DirectionalLightDistanceFadeMAD,BasePass_Forward_NumDirectionalLightCascades,BasePass_Forward_CascadeEndDepths,BasePass_Forward_DirectionalLightWorldToShadowMatrix,BasePass_Forward_DirectionalLightShadowmapMinMax,BasePass_Forward_DirectionalLightShadowmapAtlasBufferSize,BasePass_Forward_DirectionalLightDepthBias,BasePass_Forward_DirectionalLightUseStaticShadowing,BasePass_Forward_DirectionalLightStaticShadowBufferSize,BasePass_Forward_DirectionalLightWorldToStaticShadow,BasePass_Forward_DirectionalLightShadowmapAtlas,BasePass_Forward_ShadowmapSampler,BasePass_Forward_DirectionalLightStaticShadowmap,BasePass_Forward_StaticShadowmapSampler  ,BasePass_Forward_ForwardLocalLightBuffer   ,BasePass_Forward_NumCulledLightsGrid   ,BasePass_Forward_CulledLightDataGrid  },{ BasePass_ForwardISR_NumLocalLights,BasePass_ForwardISR_NumReflectionCaptures,BasePass_ForwardISR_HasDirectionalLight,BasePass_ForwardISR_NumGridCells,BasePass_ForwardISR_CulledGridSize,BasePass_ForwardISR_MaxCulledLightsPerCell,BasePass_ForwardISR_LightGridPixelSizeShift,BasePass_ForwardISR_LightGridZParams,BasePass_ForwardISR_DirectionalLightDirection,BasePass_ForwardISR_DirectionalLightColor,BasePass_ForwardISR_DirectionalLightVolumetricScatteringIntensity,BasePass_ForwardISR_DirectionalLightShadowMapChannelMask,BasePass_ForwardISR_DirectionalLightDistanceFadeMAD,BasePass_ForwardISR_NumDirectionalLightCascades,BasePass_ForwardISR_CascadeEndDepths,BasePass_ForwardISR_DirectionalLightWorldToShadowMatrix,BasePass_ForwardISR_DirectionalLightShadowmapMinMax,BasePass_ForwardISR_DirectionalLightShadowmapAtlasBufferSize,BasePass_ForwardISR_DirectionalLightDepthBias,BasePass_ForwardISR_DirectionalLightUseStaticShadowing,BasePass_ForwardISR_DirectionalLightStaticShadowBufferSize,BasePass_ForwardISR_DirectionalLightWorldToStaticShadow,BasePass_ForwardISR_DirectionalLightShadowmapAtlas,BasePass_ForwardISR_ShadowmapSampler,BasePass_ForwardISR_DirectionalLightStaticShadowmap,BasePass_ForwardISR_StaticShadowmapSampler  ,BasePass_ForwardISR_ForwardLocalLightBuffer   ,BasePass_ForwardISR_NumCulledLightsGrid   ,BasePass_ForwardISR_CulledLightDataGrid  },{ BasePass_Reflection_SkyLightParameters,BasePass_Reflection_SkyLightCubemapBrightness,BasePass_Reflection_SkyLightCubemap,BasePass_Reflection_SkyLightCubemapSampler,BasePass_Reflection_SkyLightBlendDestinationCubemap,BasePass_Reflection_SkyLightBlendDestinationCubemapSampler,BasePass_Reflection_ReflectionCubemap,BasePass_Reflection_ReflectionCubemapSampler,BasePass_Reflection_PreIntegratedGF,BasePass_Reflection_PreIntegratedGFSampler},{ BasePass_PlanarReflection_ReflectionPlane,BasePass_PlanarReflection_PlanarReflectionOrigin,BasePass_PlanarReflection_PlanarReflectionXAxis,BasePass_PlanarReflection_PlanarReflectionYAxis,BasePass_PlanarReflection_InverseTransposeMirrorMatrix,BasePass_PlanarReflection_PlanarReflectionParameters,BasePass_PlanarReflection_PlanarReflectionParameters2,BasePass_PlanarReflection_ProjectionWithExtraFOV,BasePass_PlanarReflection_PlanarReflectionScreenScaleBias,BasePass_PlanarReflection_PlanarReflectionScreenBound,BasePass_PlanarReflection_bIsStereo,BasePass_PlanarReflection_PlanarReflectionTexture,BasePass_PlanarReflection_PlanarReflectionSampler},{ BasePass_Fog_ExponentialFogParameters,BasePass_Fog_ExponentialFogParameters2,BasePass_Fog_ExponentialFogColorParameter,BasePass_Fog_ExponentialFogParameters3,BasePass_Fog_InscatteringLightDirection,BasePass_Fog_DirectionalInscatteringColor,BasePass_Fog_SinCosInscatteringColorCubemapRotation,BasePass_Fog_FogInscatteringTextureParameters,BasePass_Fog_ApplyVolumetricFog,BasePass_Fog_FogInscatteringColorCubemap,BasePass_Fog_FogInscatteringColorSampler,BasePass_Fog_IntegratedLightScattering,BasePass_Fog_IntegratedLightScatteringSampler},BasePass_SSProfilesTexture*/
#line 13 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 1 "/Engine/Generated/UniformBuffers/ReflectionCapture.ush"


cbuffer ReflectionCapture
{
	float4 ReflectionCapture_PositionAndRadius[341];
	float4 ReflectionCapture_CaptureProperties[341];
	float4 ReflectionCapture_CaptureOffsetAndAverageBrightness[341];
	float4x4 ReflectionCapture_BoxTransform[341];
	float4 ReflectionCapture_BoxScales[341];
}
/*atic const struct
{
	float4 PositionAndRadius[341];
	float4 CaptureProperties[341];
	float4 CaptureOffsetAndAverageBrightness[341];
	float4x4 BoxTransform[341];
	float4 BoxScales[341];
} ReflectionCapture = { ReflectionCapture_PositionAndRadius,ReflectionCapture_CaptureProperties,ReflectionCapture_CaptureOffsetAndAverageBrightness,ReflectionCapture_BoxTransform,ReflectionCapture_BoxScales*/
#line 14 "/Engine/Generated/GeneratedUniformBuffers.ush"
#line 56 "/Engine/Private/Common.ush"
#line 58 "/Engine/Private/Common.ush"
#line 1 "CommonViewUniformBuffer.ush"
#line 12 "/Engine/Private/CommonViewUniformBuffer.ush"
float2 GetTanHalfFieldOfView()
{
	return float2(View_ClipToView[0][0], View_ClipToView[1][1]);
}

float2 GetPrevTanHalfFieldOfView()
{
	return float2(View_PrevClipToView[0][0], View_PrevClipToView[1][1]);
}



float2 GetCotanHalfFieldOfView()
{
	return float2(View_ViewToClip[0][0], View_ViewToClip[1][1]);
}



float2 GetPrevCotanHalfFieldOfView()
{
	return float2(View_PrevViewToClip[0][0], View_PrevViewToClip[1][1]);
}


uint GetPowerOfTwoModulatedFrameIndex(uint Pow2Modulus)
{

	return View_StateFrameIndex & uint(Pow2Modulus - 1);
}
#line 59 "/Engine/Private/Common.ush"
#line 60 "/Engine/Private/Common.ush"
#line 1 "InstancedStereo.ush"
#line 10 "/Engine/Private/InstancedStereo.ush"
#line 1 "/Engine/Generated/UniformBuffers/View.ush"
#line 11 "/Engine/Private/InstancedStereo.ush"
#line 1 "/Engine/Generated/UniformBuffers/InstancedView.ush"
#line 12 "/Engine/Private/InstancedStereo.ush"
#line 15 "/Engine/Private/InstancedStereo.ush"
#line 1 "/Engine/Generated/GeneratedInstancedStereo.ush"
struct ViewState
{
	float4x4 TranslatedWorldToClip;
	float4x4 WorldToClip;
	float4x4 ClipToWorld;
	float4x4 TranslatedWorldToView;
	float4x4 ViewToTranslatedWorld;
	float4x4 TranslatedWorldToCameraView;
	float4x4 CameraViewToTranslatedWorld;
	float4x4 ViewToClip;
	float4x4 ViewToClipNoAA;
	float4x4 ClipToView;
	float4x4 ClipToTranslatedWorld;
	float4x4 SVPositionToTranslatedWorld;
	float4x4 ScreenToWorld;
	float4x4 ScreenToTranslatedWorld;
	float3  ViewForward;
	float3  ViewUp;
	float3  ViewRight;
	float3  HMDViewNoRollUp;
	float3  HMDViewNoRollRight;
	float4 InvDeviceZToWorldZTransform;
	float4  ScreenPositionScaleBias;
	float3 WorldCameraOrigin;
	float3 TranslatedWorldCameraOrigin;
	float3 WorldViewOrigin;
	float3 PreViewTranslation;
	float4x4 PrevProjection;
	float4x4 PrevViewProj;
	float4x4 PrevViewRotationProj;
	float4x4 PrevViewToClip;
	float4x4 PrevClipToView;
	float4x4 PrevTranslatedWorldToClip;
	float4x4 PrevTranslatedWorldToView;
	float4x4 PrevViewToTranslatedWorld;
	float4x4 PrevTranslatedWorldToCameraView;
	float4x4 PrevCameraViewToTranslatedWorld;
	float3 PrevWorldCameraOrigin;
	float3 PrevWorldViewOrigin;
	float3 PrevPreViewTranslation;
	float4x4 PrevInvViewProj;
	float4x4 PrevScreenToTranslatedWorld;
	float4x4 ClipToPrevClip;
	float4 TemporalAAJitter;
	float4 GlobalClippingPlane;
	float2 FieldOfViewWideAngles;
	float2 PrevFieldOfViewWideAngles;
	float4  ViewRectMin;
	float4 ViewSizeAndInvSize;
	float4 BufferSizeAndInvSize;
	float4 BufferBilinearUVMinMax;
	int NumSceneColorMSAASamples;
	float  PreExposure;
	float  OneOverPreExposure;
	float4  DiffuseOverrideParameter;
	float4  SpecularOverrideParameter;
	float4  NormalOverrideParameter;
	float2  RoughnessOverrideParameter;
	float PrevFrameGameTime;
	float PrevFrameRealTime;
	float  OutOfBoundsMask;
	float3 WorldCameraMovementSinceLastFrame;
	float CullingSign;
	float  NearPlane;
	float AdaptiveTessellationFactor;
	float GameTime;
	float RealTime;
	float DeltaTime;
	float MaterialTextureMipBias;
	float MaterialTextureDerivativeMultiply;
	uint Random;
	uint FrameNumber;
	uint StateFrameIndexMod8;
	uint StateFrameIndex;
	float  CameraCut;
	float  UnlitViewmodeMask;
	float4  DirectionalLightColor;
	float3  DirectionalLightDirection;
	float4 TranslucencyLightingVolumeMin[2];
	float4 TranslucencyLightingVolumeInvSize[2];
	float4 TemporalAAParams;
	float4 CircleDOFParams;
	float DepthOfFieldSensorWidth;
	float DepthOfFieldFocalDistance;
	float DepthOfFieldScale;
	float DepthOfFieldFocalLength;
	float DepthOfFieldFocalRegion;
	float DepthOfFieldNearTransitionRegion;
	float DepthOfFieldFarTransitionRegion;
	float MotionBlurNormalizedToPixel;
	float bSubsurfacePostprocessEnabled;
	float GeneralPurposeTweak;
	float  DemosaicVposOffset;
	float3 IndirectLightingColorScale;
	float  HDR32bppEncodingMode;
	float3 AtmosphericFogSunDirection;
	float  AtmosphericFogSunPower;
	float  AtmosphericFogPower;
	float  AtmosphericFogDensityScale;
	float  AtmosphericFogDensityOffset;
	float  AtmosphericFogGroundOffset;
	float  AtmosphericFogDistanceScale;
	float  AtmosphericFogAltitudeScale;
	float  AtmosphericFogHeightScaleRayleigh;
	float  AtmosphericFogStartDistance;
	float  AtmosphericFogDistanceOffset;
	float  AtmosphericFogSunDiscScale;
	uint AtmosphericFogRenderMask;
	uint AtmosphericFogInscatterAltitudeSampleNum;
	float4 AtmosphericFogSunColor;
	float3 NormalCurvatureToRoughnessScaleBias;
	float RenderingReflectionCaptureMask;
	float4 AmbientCubemapTint;
	float AmbientCubemapIntensity;
	float SkyLightParameters;
	float4 SkyLightColor;
	float4 SkyIrradianceEnvironmentMap[7];
	float MobilePreviewMode;
	float HMDEyePaddingOffset;
	float  ReflectionCubemapMaxMip;
	float ShowDecalsMask;
	uint DistanceFieldAOSpecularOcclusionMode;
	float IndirectCapsuleSelfShadowingIntensity;
	float3 ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	int StereoPassIndex;
	float4 GlobalVolumeCenterAndExtent[4];
	float4 GlobalVolumeWorldToUVAddAndMul[4];
	float GlobalVolumeDimension;
	float GlobalVolumeTexelSize;
	float MaxGlobalDistance;
	float bCheckerboardSubsurfaceProfileRendering;
	float3 VolumetricFogInvGridSize;
	float3 VolumetricFogGridZParams;
	float2 VolumetricFogSVPosToVolumeUV;
	float VolumetricFogMaxDistance;
	float3 VolumetricLightmapWorldToUVScale;
	float3 VolumetricLightmapWorldToUVAdd;
	float3 VolumetricLightmapIndirectionTextureSize;
	float VolumetricLightmapBrickSize;
	float3 VolumetricLightmapBrickTexelSize;
	float StereoIPD;
	float IndirectLightingCacheShowFlag;
	float EyeToPixelSpreadAngle;
};
ViewState GetPrimaryView()
{
	ViewState Result;
	Result.TranslatedWorldToClip = View_TranslatedWorldToClip;
	Result.WorldToClip = View_WorldToClip;
	Result.ClipToWorld = View_ClipToWorld;
	Result.TranslatedWorldToView = View_TranslatedWorldToView;
	Result.ViewToTranslatedWorld = View_ViewToTranslatedWorld;
	Result.TranslatedWorldToCameraView = View_TranslatedWorldToCameraView;
	Result.CameraViewToTranslatedWorld = View_CameraViewToTranslatedWorld;
	Result.ViewToClip = View_ViewToClip;
	Result.ViewToClipNoAA = View_ViewToClipNoAA;
	Result.ClipToView = View_ClipToView;
	Result.ClipToTranslatedWorld = View_ClipToTranslatedWorld;
	Result.SVPositionToTranslatedWorld = View_SVPositionToTranslatedWorld;
	Result.ScreenToWorld = View_ScreenToWorld;
	Result.ScreenToTranslatedWorld = View_ScreenToTranslatedWorld;
	Result.ViewForward = View_ViewForward;
	Result.ViewUp = View_ViewUp;
	Result.ViewRight = View_ViewRight;
	Result.HMDViewNoRollUp = View_HMDViewNoRollUp;
	Result.HMDViewNoRollRight = View_HMDViewNoRollRight;
	Result.InvDeviceZToWorldZTransform = View_InvDeviceZToWorldZTransform;
	Result.ScreenPositionScaleBias = View_ScreenPositionScaleBias;
	Result.WorldCameraOrigin = View_WorldCameraOrigin;
	Result.TranslatedWorldCameraOrigin = View_TranslatedWorldCameraOrigin;
	Result.WorldViewOrigin = View_WorldViewOrigin;
	Result.PreViewTranslation = View_PreViewTranslation;
	Result.PrevProjection = View_PrevProjection;
	Result.PrevViewProj = View_PrevViewProj;
	Result.PrevViewRotationProj = View_PrevViewRotationProj;
	Result.PrevViewToClip = View_PrevViewToClip;
	Result.PrevClipToView = View_PrevClipToView;
	Result.PrevTranslatedWorldToClip = View_PrevTranslatedWorldToClip;
	Result.PrevTranslatedWorldToView = View_PrevTranslatedWorldToView;
	Result.PrevViewToTranslatedWorld = View_PrevViewToTranslatedWorld;
	Result.PrevTranslatedWorldToCameraView = View_PrevTranslatedWorldToCameraView;
	Result.PrevCameraViewToTranslatedWorld = View_PrevCameraViewToTranslatedWorld;
	Result.PrevWorldCameraOrigin = View_PrevWorldCameraOrigin;
	Result.PrevWorldViewOrigin = View_PrevWorldViewOrigin;
	Result.PrevPreViewTranslation = View_PrevPreViewTranslation;
	Result.PrevInvViewProj = View_PrevInvViewProj;
	Result.PrevScreenToTranslatedWorld = View_PrevScreenToTranslatedWorld;
	Result.ClipToPrevClip = View_ClipToPrevClip;
	Result.TemporalAAJitter = View_TemporalAAJitter;
	Result.GlobalClippingPlane = View_GlobalClippingPlane;
	Result.FieldOfViewWideAngles = View_FieldOfViewWideAngles;
	Result.PrevFieldOfViewWideAngles = View_PrevFieldOfViewWideAngles;
	Result.ViewRectMin = View_ViewRectMin;
	Result.ViewSizeAndInvSize = View_ViewSizeAndInvSize;
	Result.BufferSizeAndInvSize = View_BufferSizeAndInvSize;
	Result.BufferBilinearUVMinMax = View_BufferBilinearUVMinMax;
	Result.NumSceneColorMSAASamples = View_NumSceneColorMSAASamples;
	Result.PreExposure = View_PreExposure;
	Result.OneOverPreExposure = View_OneOverPreExposure;
	Result.DiffuseOverrideParameter = View_DiffuseOverrideParameter;
	Result.SpecularOverrideParameter = View_SpecularOverrideParameter;
	Result.NormalOverrideParameter = View_NormalOverrideParameter;
	Result.RoughnessOverrideParameter = View_RoughnessOverrideParameter;
	Result.PrevFrameGameTime = View_PrevFrameGameTime;
	Result.PrevFrameRealTime = View_PrevFrameRealTime;
	Result.OutOfBoundsMask = View_OutOfBoundsMask;
	Result.WorldCameraMovementSinceLastFrame = View_WorldCameraMovementSinceLastFrame;
	Result.CullingSign = View_CullingSign;
	Result.NearPlane = View_NearPlane;
	Result.AdaptiveTessellationFactor = View_AdaptiveTessellationFactor;
	Result.GameTime = View_GameTime;
	Result.RealTime = View_RealTime;
	Result.DeltaTime = View_DeltaTime;
	Result.MaterialTextureMipBias = View_MaterialTextureMipBias;
	Result.MaterialTextureDerivativeMultiply = View_MaterialTextureDerivativeMultiply;
	Result.Random = View_Random;
	Result.FrameNumber = View_FrameNumber;
	Result.StateFrameIndexMod8 = View_StateFrameIndexMod8;
	Result.StateFrameIndex = View_StateFrameIndex;
	Result.CameraCut = View_CameraCut;
	Result.UnlitViewmodeMask = View_UnlitViewmodeMask;
	Result.DirectionalLightColor = View_DirectionalLightColor;
	Result.DirectionalLightDirection = View_DirectionalLightDirection;
	Result.TranslucencyLightingVolumeMin = View_TranslucencyLightingVolumeMin;
	Result.TranslucencyLightingVolumeInvSize = View_TranslucencyLightingVolumeInvSize;
	Result.TemporalAAParams = View_TemporalAAParams;
	Result.CircleDOFParams = View_CircleDOFParams;
	Result.DepthOfFieldSensorWidth = View_DepthOfFieldSensorWidth;
	Result.DepthOfFieldFocalDistance = View_DepthOfFieldFocalDistance;
	Result.DepthOfFieldScale = View_DepthOfFieldScale;
	Result.DepthOfFieldFocalLength = View_DepthOfFieldFocalLength;
	Result.DepthOfFieldFocalRegion = View_DepthOfFieldFocalRegion;
	Result.DepthOfFieldNearTransitionRegion = View_DepthOfFieldNearTransitionRegion;
	Result.DepthOfFieldFarTransitionRegion = View_DepthOfFieldFarTransitionRegion;
	Result.MotionBlurNormalizedToPixel = View_MotionBlurNormalizedToPixel;
	Result.bSubsurfacePostprocessEnabled = View_bSubsurfacePostprocessEnabled;
	Result.GeneralPurposeTweak = View_GeneralPurposeTweak;
	Result.DemosaicVposOffset = View_DemosaicVposOffset;
	Result.IndirectLightingColorScale = View_IndirectLightingColorScale;
	Result.HDR32bppEncodingMode = View_HDR32bppEncodingMode;
	Result.AtmosphericFogSunDirection = View_AtmosphericFogSunDirection;
	Result.AtmosphericFogSunPower = View_AtmosphericFogSunPower;
	Result.AtmosphericFogPower = View_AtmosphericFogPower;
	Result.AtmosphericFogDensityScale = View_AtmosphericFogDensityScale;
	Result.AtmosphericFogDensityOffset = View_AtmosphericFogDensityOffset;
	Result.AtmosphericFogGroundOffset = View_AtmosphericFogGroundOffset;
	Result.AtmosphericFogDistanceScale = View_AtmosphericFogDistanceScale;
	Result.AtmosphericFogAltitudeScale = View_AtmosphericFogAltitudeScale;
	Result.AtmosphericFogHeightScaleRayleigh = View_AtmosphericFogHeightScaleRayleigh;
	Result.AtmosphericFogStartDistance = View_AtmosphericFogStartDistance;
	Result.AtmosphericFogDistanceOffset = View_AtmosphericFogDistanceOffset;
	Result.AtmosphericFogSunDiscScale = View_AtmosphericFogSunDiscScale;
	Result.AtmosphericFogRenderMask = View_AtmosphericFogRenderMask;
	Result.AtmosphericFogInscatterAltitudeSampleNum = View_AtmosphericFogInscatterAltitudeSampleNum;
	Result.AtmosphericFogSunColor = View_AtmosphericFogSunColor;
	Result.NormalCurvatureToRoughnessScaleBias = View_NormalCurvatureToRoughnessScaleBias;
	Result.RenderingReflectionCaptureMask = View_RenderingReflectionCaptureMask;
	Result.AmbientCubemapTint = View_AmbientCubemapTint;
	Result.AmbientCubemapIntensity = View_AmbientCubemapIntensity;
	Result.SkyLightParameters = View_SkyLightParameters;
	Result.SkyLightColor = View_SkyLightColor;
	Result.SkyIrradianceEnvironmentMap = View_SkyIrradianceEnvironmentMap;
	Result.MobilePreviewMode = View_MobilePreviewMode;
	Result.HMDEyePaddingOffset = View_HMDEyePaddingOffset;
	Result.ReflectionCubemapMaxMip = View_ReflectionCubemapMaxMip;
	Result.ShowDecalsMask = View_ShowDecalsMask;
	Result.DistanceFieldAOSpecularOcclusionMode = View_DistanceFieldAOSpecularOcclusionMode;
	Result.IndirectCapsuleSelfShadowingIntensity = View_IndirectCapsuleSelfShadowingIntensity;
	Result.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight = View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	Result.StereoPassIndex = View_StereoPassIndex;
	Result.GlobalVolumeCenterAndExtent = View_GlobalVolumeCenterAndExtent;
	Result.GlobalVolumeWorldToUVAddAndMul = View_GlobalVolumeWorldToUVAddAndMul;
	Result.GlobalVolumeDimension = View_GlobalVolumeDimension;
	Result.GlobalVolumeTexelSize = View_GlobalVolumeTexelSize;
	Result.MaxGlobalDistance = View_MaxGlobalDistance;
	Result.bCheckerboardSubsurfaceProfileRendering = View_bCheckerboardSubsurfaceProfileRendering;
	Result.VolumetricFogInvGridSize = View_VolumetricFogInvGridSize;
	Result.VolumetricFogGridZParams = View_VolumetricFogGridZParams;
	Result.VolumetricFogSVPosToVolumeUV = View_VolumetricFogSVPosToVolumeUV;
	Result.VolumetricFogMaxDistance = View_VolumetricFogMaxDistance;
	Result.VolumetricLightmapWorldToUVScale = View_VolumetricLightmapWorldToUVScale;
	Result.VolumetricLightmapWorldToUVAdd = View_VolumetricLightmapWorldToUVAdd;
	Result.VolumetricLightmapIndirectionTextureSize = View_VolumetricLightmapIndirectionTextureSize;
	Result.VolumetricLightmapBrickSize = View_VolumetricLightmapBrickSize;
	Result.VolumetricLightmapBrickTexelSize = View_VolumetricLightmapBrickTexelSize;
	Result.StereoIPD = View_StereoIPD;
	Result.IndirectLightingCacheShowFlag = View_IndirectLightingCacheShowFlag;
	Result.EyeToPixelSpreadAngle = View_EyeToPixelSpreadAngle;
	return Result;
}
ViewState GetInstancedView()
{
	ViewState Result;
	Result.TranslatedWorldToClip = InstancedView_TranslatedWorldToClip;
	Result.WorldToClip = InstancedView_WorldToClip;
	Result.ClipToWorld = InstancedView_ClipToWorld;
	Result.TranslatedWorldToView = InstancedView_TranslatedWorldToView;
	Result.ViewToTranslatedWorld = InstancedView_ViewToTranslatedWorld;
	Result.TranslatedWorldToCameraView = InstancedView_TranslatedWorldToCameraView;
	Result.CameraViewToTranslatedWorld = InstancedView_CameraViewToTranslatedWorld;
	Result.ViewToClip = InstancedView_ViewToClip;
	Result.ViewToClipNoAA = InstancedView_ViewToClipNoAA;
	Result.ClipToView = InstancedView_ClipToView;
	Result.ClipToTranslatedWorld = InstancedView_ClipToTranslatedWorld;
	Result.SVPositionToTranslatedWorld = InstancedView_SVPositionToTranslatedWorld;
	Result.ScreenToWorld = InstancedView_ScreenToWorld;
	Result.ScreenToTranslatedWorld = InstancedView_ScreenToTranslatedWorld;
	Result.ViewForward = InstancedView_ViewForward;
	Result.ViewUp = InstancedView_ViewUp;
	Result.ViewRight = InstancedView_ViewRight;
	Result.HMDViewNoRollUp = InstancedView_HMDViewNoRollUp;
	Result.HMDViewNoRollRight = InstancedView_HMDViewNoRollRight;
	Result.InvDeviceZToWorldZTransform = InstancedView_InvDeviceZToWorldZTransform;
	Result.ScreenPositionScaleBias = InstancedView_ScreenPositionScaleBias;
	Result.WorldCameraOrigin = InstancedView_WorldCameraOrigin;
	Result.TranslatedWorldCameraOrigin = InstancedView_TranslatedWorldCameraOrigin;
	Result.WorldViewOrigin = InstancedView_WorldViewOrigin;
	Result.PreViewTranslation = InstancedView_PreViewTranslation;
	Result.PrevProjection = InstancedView_PrevProjection;
	Result.PrevViewProj = InstancedView_PrevViewProj;
	Result.PrevViewRotationProj = InstancedView_PrevViewRotationProj;
	Result.PrevViewToClip = InstancedView_PrevViewToClip;
	Result.PrevClipToView = InstancedView_PrevClipToView;
	Result.PrevTranslatedWorldToClip = InstancedView_PrevTranslatedWorldToClip;
	Result.PrevTranslatedWorldToView = InstancedView_PrevTranslatedWorldToView;
	Result.PrevViewToTranslatedWorld = InstancedView_PrevViewToTranslatedWorld;
	Result.PrevTranslatedWorldToCameraView = InstancedView_PrevTranslatedWorldToCameraView;
	Result.PrevCameraViewToTranslatedWorld = InstancedView_PrevCameraViewToTranslatedWorld;
	Result.PrevWorldCameraOrigin = InstancedView_PrevWorldCameraOrigin;
	Result.PrevWorldViewOrigin = InstancedView_PrevWorldViewOrigin;
	Result.PrevPreViewTranslation = InstancedView_PrevPreViewTranslation;
	Result.PrevInvViewProj = InstancedView_PrevInvViewProj;
	Result.PrevScreenToTranslatedWorld = InstancedView_PrevScreenToTranslatedWorld;
	Result.ClipToPrevClip = InstancedView_ClipToPrevClip;
	Result.TemporalAAJitter = InstancedView_TemporalAAJitter;
	Result.GlobalClippingPlane = InstancedView_GlobalClippingPlane;
	Result.FieldOfViewWideAngles = InstancedView_FieldOfViewWideAngles;
	Result.PrevFieldOfViewWideAngles = InstancedView_PrevFieldOfViewWideAngles;
	Result.ViewRectMin = InstancedView_ViewRectMin;
	Result.ViewSizeAndInvSize = InstancedView_ViewSizeAndInvSize;
	Result.BufferSizeAndInvSize = InstancedView_BufferSizeAndInvSize;
	Result.BufferBilinearUVMinMax = InstancedView_BufferBilinearUVMinMax;
	Result.NumSceneColorMSAASamples = InstancedView_NumSceneColorMSAASamples;
	Result.PreExposure = InstancedView_PreExposure;
	Result.OneOverPreExposure = InstancedView_OneOverPreExposure;
	Result.DiffuseOverrideParameter = InstancedView_DiffuseOverrideParameter;
	Result.SpecularOverrideParameter = InstancedView_SpecularOverrideParameter;
	Result.NormalOverrideParameter = InstancedView_NormalOverrideParameter;
	Result.RoughnessOverrideParameter = InstancedView_RoughnessOverrideParameter;
	Result.PrevFrameGameTime = InstancedView_PrevFrameGameTime;
	Result.PrevFrameRealTime = InstancedView_PrevFrameRealTime;
	Result.OutOfBoundsMask = InstancedView_OutOfBoundsMask;
	Result.WorldCameraMovementSinceLastFrame = InstancedView_WorldCameraMovementSinceLastFrame;
	Result.CullingSign = InstancedView_CullingSign;
	Result.NearPlane = InstancedView_NearPlane;
	Result.AdaptiveTessellationFactor = InstancedView_AdaptiveTessellationFactor;
	Result.GameTime = InstancedView_GameTime;
	Result.RealTime = InstancedView_RealTime;
	Result.DeltaTime = InstancedView_DeltaTime;
	Result.MaterialTextureMipBias = InstancedView_MaterialTextureMipBias;
	Result.MaterialTextureDerivativeMultiply = InstancedView_MaterialTextureDerivativeMultiply;
	Result.Random = InstancedView_Random;
	Result.FrameNumber = InstancedView_FrameNumber;
	Result.StateFrameIndexMod8 = InstancedView_StateFrameIndexMod8;
	Result.StateFrameIndex = InstancedView_StateFrameIndex;
	Result.CameraCut = InstancedView_CameraCut;
	Result.UnlitViewmodeMask = InstancedView_UnlitViewmodeMask;
	Result.DirectionalLightColor = InstancedView_DirectionalLightColor;
	Result.DirectionalLightDirection = InstancedView_DirectionalLightDirection;
	Result.TranslucencyLightingVolumeMin = InstancedView_TranslucencyLightingVolumeMin;
	Result.TranslucencyLightingVolumeInvSize = InstancedView_TranslucencyLightingVolumeInvSize;
	Result.TemporalAAParams = InstancedView_TemporalAAParams;
	Result.CircleDOFParams = InstancedView_CircleDOFParams;
	Result.DepthOfFieldSensorWidth = InstancedView_DepthOfFieldSensorWidth;
	Result.DepthOfFieldFocalDistance = InstancedView_DepthOfFieldFocalDistance;
	Result.DepthOfFieldScale = InstancedView_DepthOfFieldScale;
	Result.DepthOfFieldFocalLength = InstancedView_DepthOfFieldFocalLength;
	Result.DepthOfFieldFocalRegion = InstancedView_DepthOfFieldFocalRegion;
	Result.DepthOfFieldNearTransitionRegion = InstancedView_DepthOfFieldNearTransitionRegion;
	Result.DepthOfFieldFarTransitionRegion = InstancedView_DepthOfFieldFarTransitionRegion;
	Result.MotionBlurNormalizedToPixel = InstancedView_MotionBlurNormalizedToPixel;
	Result.bSubsurfacePostprocessEnabled = InstancedView_bSubsurfacePostprocessEnabled;
	Result.GeneralPurposeTweak = InstancedView_GeneralPurposeTweak;
	Result.DemosaicVposOffset = InstancedView_DemosaicVposOffset;
	Result.IndirectLightingColorScale = InstancedView_IndirectLightingColorScale;
	Result.HDR32bppEncodingMode = InstancedView_HDR32bppEncodingMode;
	Result.AtmosphericFogSunDirection = InstancedView_AtmosphericFogSunDirection;
	Result.AtmosphericFogSunPower = InstancedView_AtmosphericFogSunPower;
	Result.AtmosphericFogPower = InstancedView_AtmosphericFogPower;
	Result.AtmosphericFogDensityScale = InstancedView_AtmosphericFogDensityScale;
	Result.AtmosphericFogDensityOffset = InstancedView_AtmosphericFogDensityOffset;
	Result.AtmosphericFogGroundOffset = InstancedView_AtmosphericFogGroundOffset;
	Result.AtmosphericFogDistanceScale = InstancedView_AtmosphericFogDistanceScale;
	Result.AtmosphericFogAltitudeScale = InstancedView_AtmosphericFogAltitudeScale;
	Result.AtmosphericFogHeightScaleRayleigh = InstancedView_AtmosphericFogHeightScaleRayleigh;
	Result.AtmosphericFogStartDistance = InstancedView_AtmosphericFogStartDistance;
	Result.AtmosphericFogDistanceOffset = InstancedView_AtmosphericFogDistanceOffset;
	Result.AtmosphericFogSunDiscScale = InstancedView_AtmosphericFogSunDiscScale;
	Result.AtmosphericFogRenderMask = InstancedView_AtmosphericFogRenderMask;
	Result.AtmosphericFogInscatterAltitudeSampleNum = InstancedView_AtmosphericFogInscatterAltitudeSampleNum;
	Result.AtmosphericFogSunColor = InstancedView_AtmosphericFogSunColor;
	Result.NormalCurvatureToRoughnessScaleBias = InstancedView_NormalCurvatureToRoughnessScaleBias;
	Result.RenderingReflectionCaptureMask = InstancedView_RenderingReflectionCaptureMask;
	Result.AmbientCubemapTint = InstancedView_AmbientCubemapTint;
	Result.AmbientCubemapIntensity = InstancedView_AmbientCubemapIntensity;
	Result.SkyLightParameters = InstancedView_SkyLightParameters;
	Result.SkyLightColor = InstancedView_SkyLightColor;
	Result.SkyIrradianceEnvironmentMap = InstancedView_SkyIrradianceEnvironmentMap;
	Result.MobilePreviewMode = InstancedView_MobilePreviewMode;
	Result.HMDEyePaddingOffset = InstancedView_HMDEyePaddingOffset;
	Result.ReflectionCubemapMaxMip = InstancedView_ReflectionCubemapMaxMip;
	Result.ShowDecalsMask = InstancedView_ShowDecalsMask;
	Result.DistanceFieldAOSpecularOcclusionMode = InstancedView_DistanceFieldAOSpecularOcclusionMode;
	Result.IndirectCapsuleSelfShadowingIntensity = InstancedView_IndirectCapsuleSelfShadowingIntensity;
	Result.ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight = InstancedView_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight;
	Result.StereoPassIndex = InstancedView_StereoPassIndex;
	Result.GlobalVolumeCenterAndExtent = InstancedView_GlobalVolumeCenterAndExtent;
	Result.GlobalVolumeWorldToUVAddAndMul = InstancedView_GlobalVolumeWorldToUVAddAndMul;
	Result.GlobalVolumeDimension = InstancedView_GlobalVolumeDimension;
	Result.GlobalVolumeTexelSize = InstancedView_GlobalVolumeTexelSize;
	Result.MaxGlobalDistance = InstancedView_MaxGlobalDistance;
	Result.bCheckerboardSubsurfaceProfileRendering = InstancedView_bCheckerboardSubsurfaceProfileRendering;
	Result.VolumetricFogInvGridSize = InstancedView_VolumetricFogInvGridSize;
	Result.VolumetricFogGridZParams = InstancedView_VolumetricFogGridZParams;
	Result.VolumetricFogSVPosToVolumeUV = InstancedView_VolumetricFogSVPosToVolumeUV;
	Result.VolumetricFogMaxDistance = InstancedView_VolumetricFogMaxDistance;
	Result.VolumetricLightmapWorldToUVScale = InstancedView_VolumetricLightmapWorldToUVScale;
	Result.VolumetricLightmapWorldToUVAdd = InstancedView_VolumetricLightmapWorldToUVAdd;
	Result.VolumetricLightmapIndirectionTextureSize = InstancedView_VolumetricLightmapIndirectionTextureSize;
	Result.VolumetricLightmapBrickSize = InstancedView_VolumetricLightmapBrickSize;
	Result.VolumetricLightmapBrickTexelSize = InstancedView_VolumetricLightmapBrickTexelSize;
	Result.StereoIPD = InstancedView_StereoIPD;
	Result.IndirectLightingCacheShowFlag = InstancedView_IndirectLightingCacheShowFlag;
	Result.EyeToPixelSpreadAngle = InstancedView_EyeToPixelSpreadAngle;
	return Result;
}
#line 16 "/Engine/Private/InstancedStereo.ush"

static ViewState ResolvedView;

ViewState ResolveView()
{
	return GetPrimaryView();
}
#line 44 "/Engine/Private/InstancedStereo.ush"
bool IsInstancedStereo()
{



	return false;

}

uint GetEyeIndex(uint InstanceId)
{



	return 0;

}

uint GetInstanceId(uint InstanceId)
{



	return InstanceId;

}
#line 61 "/Engine/Private/Common.ush"
#line 62 "/Engine/Private/Common.ush"
#line 1 "Definitions.usf"
#line 63 "/Engine/Private/Common.ush"










const static  float  PI = 3.1415926535897932f;
const static float MaxHalfFloat = 65504.0f;








static float GlobalRayCone_TexArea;
float ComputeRayConeLod(Texture2D Tex)
{






    return 0;

}


float ClampToHalfFloatRange(float X) { return clamp(X, float(0), MaxHalfFloat); }
float2 ClampToHalfFloatRange(float2 X) { return clamp(X, float(0).xx, MaxHalfFloat.xx); }
float3 ClampToHalfFloatRange(float3 X) { return clamp(X, float(0).xxx, MaxHalfFloat.xxx); }
float4 ClampToHalfFloatRange(float4 X) { return clamp(X, float(0).xxxx, MaxHalfFloat.xxxx); }



float4  Texture1DSample(Texture1D Tex, SamplerState Sampler, float UV)
{



	return Tex.Sample(Sampler, UV);

}
float4  Texture2DSample(Texture2D Tex, SamplerState Sampler, float2 UV)
{



	return Tex.Sample(Sampler, UV);

}
float  Texture2DSample_A8(Texture2D Tex, SamplerState Sampler, float2 UV)
{



	return Tex.Sample(Sampler, UV)  .a ;

}
float4  Texture3DSample(Texture3D Tex, SamplerState Sampler, float3 UV)
{



	return Tex.Sample(Sampler, UV);

}
float4  TextureCubeSample(TextureCube Tex, SamplerState Sampler, float3 UV)
{



	return Tex.Sample(Sampler, UV);

}
float4  Texture1DSampleLevel(Texture1D Tex, SamplerState Sampler, float UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture2DSampleLevel(Texture2D Tex, SamplerState Sampler, float2 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture2DSampleBias(Texture2D Tex, SamplerState Sampler, float2 UV,  float  MipBias)
{



	return Tex.SampleBias(Sampler, UV, MipBias);

}
float4  Texture2DSampleGrad(Texture2D Tex, SamplerState Sampler, float2 UV,  float2  DDX,  float2  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  Texture3DSampleLevel(Texture3D Tex, SamplerState Sampler, float3 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float4  Texture3DSampleBias(Texture3D Tex, SamplerState Sampler, float3 UV,  float  MipBias)
{



	return Tex.SampleBias(Sampler, UV, MipBias);

}
float4  Texture3DSampleGrad(Texture3D Tex, SamplerState Sampler, float3 UV,  float3  DDX,  float3  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  TextureCubeSampleLevel(TextureCube Tex, SamplerState Sampler, float3 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}
float  TextureCubeSampleDepthLevel(TextureCube TexDepth, SamplerState Sampler, float3 UV,  float  Mip)
{
	return TexDepth.SampleLevel(Sampler, UV, Mip).x;
}
float4  TextureCubeSampleBias(TextureCube Tex, SamplerState Sampler, float3 UV,  float  MipBias)
{



	return Tex.SampleBias(Sampler, UV, MipBias);

}
float4  TextureCubeSampleGrad(TextureCube Tex, SamplerState Sampler, float3 UV,  float3  DDX,  float3  DDY)
{
	return Tex.SampleGrad(Sampler, UV, DDX, DDY);
}
float4  TextureExternalSample( Texture2D  Tex, SamplerState Sampler, float2 UV)
{



	return Tex.Sample(Sampler, UV);

}
float4  TextureExternalSampleLevel( Texture2D  Tex, SamplerState Sampler, float2 UV,  float  Mip)
{
	return Tex.SampleLevel(Sampler, UV, Mip);
}


float2 Tile1Dto2D(float xsize, float idx)
{
	float2 xyidx = 0;
	xyidx.y = floor(idx / xsize);
	xyidx.x = idx - xsize * xyidx.y;

	return xyidx;
}
#line 233 "/Engine/Private/Common.ush"
float4 PseudoVolumeTexture(Texture2D Tex, SamplerState TexSampler, float3 inPos, float2 xysize, float numframes,
	uint mipmode = 0, float miplevel = 0, float2 InDDX = 0, float2 InDDY = 0)
{
	float zframe = ceil(inPos.z * numframes);
	float zphase = frac(inPos.z * numframes);

	float2 uv = frac(inPos.xy) / xysize;

	float2 curframe = Tile1Dto2D(xysize.x, zframe) / xysize;
	float2 nextframe = Tile1Dto2D(xysize.x, zframe + 1) / xysize;

	float4 sampleA = 0, sampleB = 0;
	switch (mipmode)
	{
	case 0:
		sampleA = Tex.SampleLevel(TexSampler, uv + curframe, miplevel);
		sampleB = Tex.SampleLevel(TexSampler, uv + nextframe, miplevel);
		break;
	case 1:
		sampleA = Texture2DSample(Tex, TexSampler, uv + curframe);
		sampleB = Texture2DSample(Tex, TexSampler, uv + nextframe);
		break;
	case 2:
		sampleA = Tex.SampleGrad(TexSampler, uv + curframe, InDDX, InDDY);
		sampleB = Tex.SampleGrad(TexSampler, uv + nextframe, InDDX, InDDY);
		break;
	default:
		break;
	}

	return lerp(sampleA, sampleB, zphase);
}


	float4  TextureCubeArraySampleLevel(TextureCubeArray Tex, SamplerState Sampler, float3 UV, float ArrayIndex,  float  Mip)
	{
		return Tex.SampleLevel(Sampler, float4(UV, ArrayIndex), Mip);
	}
#line 310 "/Engine/Private/Common.ush"
float  Luminance(  float3  LinearColor )
{
	return dot( LinearColor,  float3 ( 0.3, 0.59, 0.11 ) );
}

float  length2( float2  v)
{
	return dot(v, v);
}
float  length2( float3  v)
{
	return dot(v, v);
}
float  length2( float4  v)
{
	return dot(v, v);
}

uint Mod(uint a, uint b)
{

	return a % b;
#line 335 "/Engine/Private/Common.ush"
}

uint2 Mod(uint2 a, uint2 b)
{

	return a % b;
#line 344 "/Engine/Private/Common.ush"
}

uint3 Mod(uint3 a, uint3 b)
{

	return a % b;
#line 353 "/Engine/Private/Common.ush"
}

float  UnClampedPow( float  X,  float  Y)
{
	return pow(X, Y);
}
float2  UnClampedPow( float2  X,  float2  Y)
{
	return pow(X, Y);
}
float3  UnClampedPow( float3  X,  float3  Y)
{
	return pow(X, Y);
}
float4  UnClampedPow( float4  X,  float4  Y)
{
	return pow(X, Y);
}


float  ClampedPow( float  X, float  Y)
{
	return pow(max(abs(X),0.000001f),Y);
}
float2  ClampedPow( float2  X, float2  Y)
{
	return pow(max(abs(X), float2 (0.000001f,0.000001f)),Y);
}
float3  ClampedPow( float3  X, float3  Y)
{
	return pow(max(abs(X), float3 (0.000001f,0.000001f,0.000001f)),Y);
}
float4  ClampedPow( float4  X, float4  Y)
{
	return pow(max(abs(X), float4 (0.000001f,0.000001f,0.000001f,0.000001f)),Y);
}

float  PositiveClampedPow( float  X, float  Y)
{
	return pow(max(X,0.0f),Y);
}
float2  PositiveClampedPow( float2  X, float2  Y)
{
	return pow(max(X, float2 (0.0f,0.0f)),Y);
}
float3  PositiveClampedPow( float3  X, float3  Y)
{
	return pow(max(X, float3 (0.0f,0.0f,0.0f)),Y);
}
float4  PositiveClampedPow( float4  X, float4  Y)
{
	return pow(max(X, float4 (0.0f,0.0f,0.0f,0.0f)),Y);
}

float DDX(float Input)
{



	return ddx(Input);

}

float2 DDX(float2 Input)
{



	return ddx(Input);

}

float3 DDX(float3 Input)
{



	return ddx(Input);

}

float4 DDX(float4 Input)
{



	return ddx(Input);

}

float DDY(float Input)
{



	return ddy(Input);

}

float2 DDY(float2 Input)
{



	return ddy(Input);

}

float3 DDY(float3 Input)
{



	return ddy(Input);

}

float4 DDY(float4 Input)
{



	return ddy(Input);

}
#line 479 "/Engine/Private/Common.ush"
#line 1 "FastMath.ush"
#line 46 "/Engine/Private/FastMath.ush"
float rsqrtFast( float x )
{

	int i = asint(x);
	i = 0x5f3759df - (i >> 1);
	return asfloat(i);
#line 55 "/Engine/Private/FastMath.ush"
}




float sqrtFast( float x )
{

	int i = asint(x);
	i = 0x1FBD1DF5 + (i >> 1);
	return asfloat(i);
#line 69 "/Engine/Private/FastMath.ush"
}




float rcpFast( float x )
{

	int i = asint(x);
	i = 0x7EF311C2 - i;
	return asfloat(i);
#line 83 "/Engine/Private/FastMath.ush"
}





float rcpFastNR1( float x )
{

	int i = asint(x);
	i = 0x7EF311C3 - i;
	float xRcp = asfloat(i);
	xRcp = xRcp * (-xRcp * x + 2.0f);
	return xRcp;
#line 100 "/Engine/Private/FastMath.ush"
}

float lengthFast( float3 v )
{
	float LengthSqr = dot(v,v);
	return sqrtFast( LengthSqr );
}

float3 normalizeFast( float3 v )
{
	float LengthSqr = dot(v,v);
	return v * rsqrtFast( LengthSqr );
}

float4 fastClamp(float4 x, float4 Min, float4 Max)
{




	return clamp(x, Min, Max);

}

float3 fastClamp(float3 x, float3 Min, float3 Max)
{




	return clamp(x, Min, Max);

}

float2 fastClamp(float2 x, float2 Min, float2 Max)
{




	return clamp(x, Min, Max);

}

float fastClamp(float x, float Min, float Max)
{




	return clamp(x, Min, Max);

}









float acosFast(float inX)
{
    float x = abs(inX);
    float res = -0.156583f * x + (0.5 * PI);
    res *= sqrt(1.0f - x);
    return (inX >= 0) ? res : PI - res;
}




float asinFast( float x )
{
    return (0.5 * PI) - acosFast(x);
}





float atanFastPos( float x )
{
    float t0 = (x < 1.0f) ? x : 1.0f / x;
    float t1 = t0 * t0;
    float poly = 0.0872929f;
    poly = -0.301895f + poly * t1;
    poly = 1.0f + poly * t1;
    poly = poly * t0;
    return (x < 1.0f) ? poly : (0.5 * PI) - poly;
}



float atanFast( float x )
{
    float t0 = atanFastPos( abs(x) );
    return (x < 0) ? -t0: t0;
}

float atan2Fast( float y, float x )
{
	float t0 = max( abs(x), abs(y) );
	float t1 = min( abs(x), abs(y) );
	float t3 = t1 / t0;
	float t4 = t3 * t3;


	t0 = + 0.0872929;
	t0 = t0 * t4 - 0.301895;
	t0 = t0 * t4 + 1.0;
	t3 = t0 * t3;

	t3 = abs(y) > abs(x) ? (0.5 * PI) - t3 : t3;
	t3 = x < 0 ? PI - t3 : t3;
	t3 = y < 0 ? -t3 : t3;

	return t3;
}





float acosFast4(float inX)
{
	float x1 = abs(inX);
	float x2 = x1 * x1;
	float x3 = x2 * x1;
	float s;

	s = -0.2121144f * x1 + 1.5707288f;
	s = 0.0742610f * x2 + s;
	s = -0.0187293f * x3 + s;
	s = sqrt(1.0f - x1) * s;



	return inX >= 0.0f ? s : PI - s;
}




float asinFast4( float x )
{
	return (0.5 * PI) - acosFast4(x);
}




float CosBetweenVectors(float3 A, float3 B)
{

	return dot(A, B) * rsqrt(length2(A) * length2(B));
}



float AngleBetweenVectors(float3 A, float3 B)
{
	return acos(CosBetweenVectors(A, B));
}


float AngleBetweenVectorsFast(float3 A, float3 B)
{
	return acosFast(CosBetweenVectors(A, B));
}


int SignFastInt(float v)
{
	return 1 - int((asuint(v) & 0x7fffffff) >> 30);
}

int2 SignFastInt(float2 v)
{
	return int2(SignFastInt(v.x), SignFastInt(v.y));
}
#line 480 "/Engine/Private/Common.ush"
#line 1 "Random.ush"
#line 13 "/Engine/Private/Random.ush"
float PseudoRandom(float2 xy)
{
	float2 pos = frac(xy / 128.0f) * 128.0f + float2(-64.340622f, -72.465622f);


	return frac(dot(pos.xyx * pos.xyy, float3(20.390625f, 60.703125f, 2.4281209f)));
}







float InterleavedGradientNoise( float2 uv, float FrameId )
{

	uv += FrameId * (float2(47, 17) * 0.695f);

    const float3 magic = float3( 0.06711056f, 0.00583715f, 52.9829189f );
    return frac(magic.z * frac(dot(uv, magic.xy)));
}



float RandFast( uint2 PixelPos, float Magic = 3571.0 )
{
	float2 Random2 = ( 1.0 / 4320.0 ) * PixelPos + float2( 0.25, 0.0 );
	float Random = frac( dot( Random2 * Random2, Magic ) );
	Random = frac( Random * Random * (2 * Magic) );
	return Random;
}
#line 57 "/Engine/Private/Random.ush"
float RandBBSfloat(float seed)
{
	float s = frac(seed /  4093 );
	s = frac(s * s *  4093 );
	s = frac(s * s *  4093 );
	return s;
}








uint3 Rand3DPCG16(int3 p)
{

	uint3 v = uint3(p);




	v = v * 1664525u + 1013904223u;
#line 95 "/Engine/Private/Random.ush"
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;


	return v >> 16u;
}








uint3 Rand3DPCG32(int3 p)
{

	uint3 v = uint3(p);


	v = v * 1664525u + 1013904223u;


	v = v * (1u << 16u) + (v >> 16u);


	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.x += v.y*v.z;
	v.y += v.z*v.x;
	v.z += v.x*v.y;

	return v;
}










uint4 Rand4DPCG32(int4 p)
{

	uint4 v = uint4(p);


	v = v * 1664525u + 1013904223u;


	v = v * (1u << 16u) + (v >> 16u);


	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;
	v.x += v.y*v.w;
	v.y += v.z*v.x;
	v.z += v.x*v.y;
	v.w += v.y*v.z;

	return v;
}
#line 175 "/Engine/Private/Random.ush"
void FindBestAxisVectors(float3 In, out float3 Axis1, out float3 Axis2 )
{
	const float3 N = abs(In);


	if( N.z > N.x && N.z > N.y )
	{
		Axis1 = float3(1, 0, 0);
	}
	else
	{
		Axis1 = float3(0, 0, 1);
	}

	Axis1 = normalize(Axis1 - In * dot(Axis1, In));
	Axis2 = cross(Axis1, In);
}
#line 216 "/Engine/Private/Random.ush"
uint2 ScrambleTEA(uint2 v, uint IterationCount = 3)
{

	uint k[4] ={ 0xA341316Cu , 0xC8013EA4u , 0xAD90777Du , 0x7E95761Eu };

	uint y = v[0];
	uint z = v[1];
	uint sum = 0;

	[unroll]  for(uint i = 0; i < IterationCount; ++i)
	{
		sum += 0x9e3779b9;
		y += ((z << 4u) + k[0]) ^ (z + sum) ^ ((z >> 5u) + k[1]);
		z += ((y << 4u) + k[2]) ^ (y + sum) ^ ((y >> 5u) + k[3]);
	}

	return uint2(y, z);
}






float3 NoiseTileWrap(float3 v, bool bTiling, float RepeatSize)
{
	return bTiling ? (frac(v / RepeatSize) * RepeatSize) : v;
}




float4 PerlinRamp(float4 t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}




float4 PerlinRampDerivative(float4 t)
{
	return t * t * (t * (t * 30 - 60) + 30);
}







float4 MGradient(int seed, float3 offset)
{
	uint rand = Rand3DPCG16(int3(seed,0,0)).x;
	float3 direction = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	return float4(direction, dot(direction, offset));
}







float3 NoiseSeeds(float3 v, bool bTiling, float RepeatSize,
	out float seed000, out float seed001, out float seed010, out float seed011,
	out float seed100, out float seed101, out float seed110, out float seed111)
{
	float3 fv = frac(v);
	float3 iv = floor(v);

	const float3 primes = float3(19, 47, 101);

	if (bTiling)
	{
		seed000 = dot(primes, NoiseTileWrap(iv, true, RepeatSize));
		seed100 = dot(primes, NoiseTileWrap(iv + float3(1, 0, 0), true, RepeatSize));
		seed010 = dot(primes, NoiseTileWrap(iv + float3(0, 1, 0), true, RepeatSize));
		seed110 = dot(primes, NoiseTileWrap(iv + float3(1, 1, 0), true, RepeatSize));
		seed001 = dot(primes, NoiseTileWrap(iv + float3(0, 0, 1), true, RepeatSize));
		seed101 = dot(primes, NoiseTileWrap(iv + float3(1, 0, 1), true, RepeatSize));
		seed011 = dot(primes, NoiseTileWrap(iv + float3(0, 1, 1), true, RepeatSize));
		seed111 = dot(primes, NoiseTileWrap(iv + float3(1, 1, 1), true, RepeatSize));
	}
	else
	{
		seed000 = dot(iv, primes);
		seed100 = seed000 + primes.x;
		seed010 = seed000 + primes.y;
		seed110 = seed100 + primes.y;
		seed001 = seed000 + primes.z;
		seed101 = seed100 + primes.z;
		seed011 = seed010 + primes.z;
		seed111 = seed110 + primes.z;
	}

	return fv;
}







float GradientNoise3D_ALU(float3 v, bool bTiling, float RepeatSize)
{
	float seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111;
	float3 fv = NoiseSeeds(v, bTiling, RepeatSize, seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111);

	float rand000 = MGradient(int(seed000), fv - float3(0, 0, 0)).w;
	float rand100 = MGradient(int(seed100), fv - float3(1, 0, 0)).w;
	float rand010 = MGradient(int(seed010), fv - float3(0, 1, 0)).w;
	float rand110 = MGradient(int(seed110), fv - float3(1, 1, 0)).w;
	float rand001 = MGradient(int(seed001), fv - float3(0, 0, 1)).w;
	float rand101 = MGradient(int(seed101), fv - float3(1, 0, 1)).w;
	float rand011 = MGradient(int(seed011), fv - float3(0, 1, 1)).w;
	float rand111 = MGradient(int(seed111), fv - float3(1, 1, 1)).w;

	float3 Weights = PerlinRamp(float4(fv, 0)).xyz;

	float i = lerp(lerp(rand000, rand100, Weights.x), lerp(rand010, rand110, Weights.x), Weights.y);
	float j = lerp(lerp(rand001, rand101, Weights.x), lerp(rand011, rand111, Weights.x), Weights.y);
	return lerp(i, j, Weights.z).x;
}





float4x3 SimplexCorners(float3 v)
{

	float3 tet = floor(v + v.x/3 + v.y/3 + v.z/3);
	float3 base = tet - tet.x/6 - tet.y/6 - tet.z/6;
	float3 f = v - base;



	float3 g = step(f.yzx, f.xyz), h = 1 - g.zxy;
	float3 a1 = min(g, h) - 1. / 6., a2 = max(g, h) - 1. / 3.;


	return float4x3(base, base + a1, base + a2, base + 0.5);
}




float4 SimplexSmooth(float4x3 f)
{
	const float scale = 1024. / 375.;
	float4 d = float4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));
	float4 s = saturate(2 * d);
	return (1 * scale + s*(-3 * scale + s*(3 * scale - s*scale)));
}




float3x4 SimplexDSmooth(float4x3 f)
{
	const float scale = 1024. / 375.;
	float4 d = float4(dot(f[0], f[0]), dot(f[1], f[1]), dot(f[2], f[2]), dot(f[3], f[3]));
	float4 s = saturate(2 * d);
	s = -12 * scale + s*(24 * scale - s * 12 * scale);

	return float3x4(
		s * float4(f[0][0], f[1][0], f[2][0], f[3][0]),
		s * float4(f[0][1], f[1][1], f[2][1], f[3][1]),
		s * float4(f[0][2], f[1][2], f[2][2], f[3][2]));
}
#line 404 "/Engine/Private/Random.ush"
float3x4 JacobianSimplex_ALU(float3 v, bool bTiling, float RepeatSize)
{

	float4x3 T = SimplexCorners(v);
	uint3 rand;
	float4x3 gvec[3], fv;
	float3x4 grad;



	fv[0] = v - T[0];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[0] + 0.5, bTiling, RepeatSize))));
	gvec[0][0] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][0] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][0] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][0] = dot(gvec[0][0], fv[0]);
	grad[1][0] = dot(gvec[1][0], fv[0]);
	grad[2][0] = dot(gvec[2][0], fv[0]);

	fv[1] = v - T[1];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[1] + 0.5, bTiling, RepeatSize))));
	gvec[0][1] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][1] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][1] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][1] = dot(gvec[0][1], fv[1]);
	grad[1][1] = dot(gvec[1][1], fv[1]);
	grad[2][1] = dot(gvec[2][1], fv[1]);

	fv[2] = v - T[2];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[2] + 0.5, bTiling, RepeatSize))));
	gvec[0][2] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][2] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][2] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][2] = dot(gvec[0][2], fv[2]);
	grad[1][2] = dot(gvec[1][2], fv[2]);
	grad[2][2] = dot(gvec[2][2], fv[2]);

	fv[3] = v - T[3];
	rand = Rand3DPCG16(int3(floor(NoiseTileWrap(6 * T[3] + 0.5, bTiling, RepeatSize))));
	gvec[0][3] = float3(rand.xxx &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[1][3] = float3(rand.yyy &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	gvec[2][3] = float3(rand.zzz &  int3(0x8000, 0x4000, 0x2000) ) *  float3(1. / 0x4000, 1. / 0x2000, 1. / 0x1000)  - 1;
	grad[0][3] = dot(gvec[0][3], fv[3]);
	grad[1][3] = dot(gvec[1][3], fv[3]);
	grad[2][3] = dot(gvec[2][3], fv[3]);


	float4 sv = SimplexSmooth(fv);
	float3x4 ds = SimplexDSmooth(fv);

	float3x4 jacobian;
	jacobian[0] = float4(mul(sv, gvec[0]) + mul(ds, grad[0]), dot(sv, grad[0]));
	jacobian[1] = float4(mul(sv, gvec[1]) + mul(ds, grad[1]), dot(sv, grad[1]));
	jacobian[2] = float4(mul(sv, gvec[2]) + mul(ds, grad[2]), dot(sv, grad[2]));

	return jacobian;
}






float ValueNoise3D_ALU(float3 v, bool bTiling, float RepeatSize)
{
	float seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111;
	float3 fv = NoiseSeeds(v, bTiling, RepeatSize, seed000, seed001, seed010, seed011, seed100, seed101, seed110, seed111);

	float rand000 = RandBBSfloat(seed000) * 2 - 1;
	float rand100 = RandBBSfloat(seed100) * 2 - 1;
	float rand010 = RandBBSfloat(seed010) * 2 - 1;
	float rand110 = RandBBSfloat(seed110) * 2 - 1;
	float rand001 = RandBBSfloat(seed001) * 2 - 1;
	float rand101 = RandBBSfloat(seed101) * 2 - 1;
	float rand011 = RandBBSfloat(seed011) * 2 - 1;
	float rand111 = RandBBSfloat(seed111) * 2 - 1;

	float3 Weights = PerlinRamp(float4(fv, 0)).xyz;

	float i = lerp(lerp(rand000, rand100, Weights.x), lerp(rand010, rand110, Weights.x), Weights.y);
	float j = lerp(lerp(rand001, rand101, Weights.x), lerp(rand011, rand111, Weights.x), Weights.y);
	return lerp(i, j, Weights.z).x;
}









float GradientNoise3D_TEX(float3 v, bool bTiling, float RepeatSize)
{
	bTiling = true;
	float3 fv = frac(v);
	float3 iv0 = NoiseTileWrap(floor(v), bTiling, RepeatSize);
	float3 iv1 = NoiseTileWrap(iv0 + 1, bTiling, RepeatSize);

	const int2 ZShear = int2(17, 89);

	float2 OffsetA = iv0.z * ZShear;
	float2 OffsetB = OffsetA + ZShear;
	if (bTiling)
	{
		OffsetB = iv1.z * ZShear;
	}


	float ts = 1 / 128.0f;


	float2 TexA0 = (iv0.xy + OffsetA + 0.5f) * ts;
	float2 TexB0 = (iv0.xy + OffsetB + 0.5f) * ts;


	float2 TexA1 = TexA0 + ts;
	float2 TexB1 = TexB0 + ts;
	if (bTiling)
	{
		TexA1 = (iv1.xy + OffsetA + 0.5f) * ts;
		TexB1 = (iv1.xy + OffsetB + 0.5f) * ts;
	}



	float3 A = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA0.x, TexA0.y), 0).xyz * 2 - 1;
	float3 B = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA1.x, TexA0.y), 0).xyz * 2 - 1;
	float3 C = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA0.x, TexA1.y), 0).xyz * 2 - 1;
	float3 D = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexA1.x, TexA1.y), 0).xyz * 2 - 1;
	float3 E = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB0.x, TexB0.y), 0).xyz * 2 - 1;
	float3 F = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB1.x, TexB0.y), 0).xyz * 2 - 1;
	float3 G = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB0.x, TexB1.y), 0).xyz * 2 - 1;
	float3 H = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, float2(TexB1.x, TexB1.y), 0).xyz * 2 - 1;

	float a = dot(A, fv - float3(0, 0, 0));
	float b = dot(B, fv - float3(1, 0, 0));
	float c = dot(C, fv - float3(0, 1, 0));
	float d = dot(D, fv - float3(1, 1, 0));
	float e = dot(E, fv - float3(0, 0, 1));
	float f = dot(F, fv - float3(1, 0, 1));
	float g = dot(G, fv - float3(0, 1, 1));
	float h = dot(H, fv - float3(1, 1, 1));

	float3 Weights = PerlinRamp(frac(float4(fv, 0))).xyz;

	float i = lerp(lerp(a, b, Weights.x), lerp(c, d, Weights.x), Weights.y);
	float j = lerp(lerp(e, f, Weights.x), lerp(g, h, Weights.x), Weights.y);

	return lerp(i, j, Weights.z);
}



float FastGradientPerlinNoise3D_TEX(float3 xyz)
{

	float Extent = 16;



	xyz = frac(xyz / (Extent - 1)) * (Extent - 1);


	float3 uvw = frac(xyz);


	float3 p0 = xyz - uvw;


	float3 f = PerlinRamp(float4(uvw, 0)).xyz;

	float3 p = p0 + f;

	float4 NoiseSample = Texture3DSampleLevel(View_PerlinNoise3DTexture, View_PerlinNoise3DTextureSampler, p / Extent + 0.5f / Extent, 0);



	float3 n = NoiseSample.xyz * 255.0f / 127.0f - 1.0f;
	float d = NoiseSample.w * 255.f - 127;
	return dot(xyz, n) - d;
}





float3 VoronoiCornerSample(float3 pos, int Quality)
{

	float3 noise = float3(Rand3DPCG16(int3(pos))) / 0xffff - 0.5;



	if (Quality <= 2)
	{
		return normalize(noise) * 0.2588;
	}



	if (Quality == 3)
	{
		return normalize(noise) * 0.3090;
	}


	return noise;
}








float4 VoronoiCompare(float4 minval, float3 candidate, float3 offset, bool bDistanceOnly)
{
	if (bDistanceOnly)
	{
		return float4(0, 0, 0, min(minval.w, dot(offset, offset)));
	}
	else
	{
		float newdist = dot(offset, offset);
		return newdist > minval.w ? minval : float4(candidate, newdist);
	}
}


float4 VoronoiNoise3D_ALU(float3 v, int Quality, bool bTiling, float RepeatSize, bool bDistanceOnly)
{
	float3 fv = frac(v), fv2 = frac(v + 0.5);
	float3 iv = floor(v), iv2 = floor(v + 0.5);


	float4 mindist = float4(0,0,0,100);
	float3 p, offset;


	if (Quality == 3)
	{
		[unroll]  for (offset.x = -1; offset.x <= 1; ++offset.x)
		{
			[unroll]  for (offset.y = -1; offset.y <= 1; ++offset.y)
			{
				[unroll]  for (offset.z = -1; offset.z <= 1; ++offset.z)
				{
					p = offset + VoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
				}
			}
		}
	}


	else
	{
		[unroll]  for (offset.x = 0; offset.x <= 1; ++offset.x)
		{
			[unroll]  for (offset.y = 0; offset.y <= 1; ++offset.y)
			{
				[unroll]  for (offset.z = 0; offset.z <= 1; ++offset.z)
				{
					p = offset + VoronoiCornerSample(NoiseTileWrap(iv + offset, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);


					if (Quality == 2)
					{

						p = offset + VoronoiCornerSample(NoiseTileWrap(iv2 + offset, bTiling, RepeatSize) + 467, Quality);
						mindist = VoronoiCompare(mindist, iv2 + p, fv2 - p, bDistanceOnly);
					}
				}
			}
		}
	}


	if (Quality >= 4)
	{
		[unroll]  for (offset.x = -1; offset.x <= 2; offset.x += 3)
		{
			[unroll]  for (offset.y = 0; offset.y <= 1; ++offset.y)
			{
				[unroll]  for (offset.z = 0; offset.z <= 1; ++offset.z)
				{

					p = offset.xyz + VoronoiCornerSample(NoiseTileWrap(iv + offset.xyz, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);


					p = offset.yzx + VoronoiCornerSample(NoiseTileWrap(iv + offset.yzx, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);


					p = offset.zxy + VoronoiCornerSample(NoiseTileWrap(iv + offset.zxy, bTiling, RepeatSize), Quality);
					mindist = VoronoiCompare(mindist, iv + p, fv - p, bDistanceOnly);
				}
			}
		}
	}


	return float4(mindist.xyz, sqrt(mindist.w));
}







float3 ComputeSimplexWeights2D(float2 OrthogonalPos, out float2 PosA, out float2 PosB, out float2 PosC)
{
	float2 OrthogonalPosFloor = floor(OrthogonalPos);
	PosA = OrthogonalPosFloor;
	PosB = PosA + float2(1, 1);

	float2 LocalPos = OrthogonalPos - OrthogonalPosFloor;

	PosC = PosA + ((LocalPos.x > LocalPos.y) ? float2(1,0) : float2(0,1));

	float b = min(LocalPos.x, LocalPos.y);
	float c = abs(LocalPos.y - LocalPos.x);
	float a = 1.0f - b - c;

	return float3(a, b, c);
}



float4 ComputeSimplexWeights3D(float3 OrthogonalPos, out float3 PosA, out float3 PosB, out float3 PosC, out float3 PosD)
{
	float3 OrthogonalPosFloor = floor(OrthogonalPos);

	PosA = OrthogonalPosFloor;
	PosB = PosA + float3(1, 1, 1);

	OrthogonalPos -= OrthogonalPosFloor;

	float Largest = max(OrthogonalPos.x, max(OrthogonalPos.y, OrthogonalPos.z));
	float Smallest = min(OrthogonalPos.x, min(OrthogonalPos.y, OrthogonalPos.z));

	PosC = PosA + float3(Largest == OrthogonalPos.x, Largest == OrthogonalPos.y, Largest == OrthogonalPos.z);
	PosD = PosA + float3(Smallest != OrthogonalPos.x, Smallest != OrthogonalPos.y, Smallest != OrthogonalPos.z);

	float4 ret;

	float RG = OrthogonalPos.x - OrthogonalPos.y;
	float RB = OrthogonalPos.x - OrthogonalPos.z;
	float GB = OrthogonalPos.y - OrthogonalPos.z;

	ret.b =
		  min(max(0, RG), max(0, RB))
		+ min(max(0, -RG), max(0, GB))
		+ min(max(0, -RB), max(0, -GB));

	ret.a =
		  min(max(0, -RG), max(0, -RB))
		+ min(max(0, RG), max(0, -GB))
		+ min(max(0, RB), max(0, GB));

	ret.g = Smallest;
	ret.r = 1.0f - ret.g - ret.b - ret.a;

	return ret;
}

float2 GetPerlinNoiseGradientTextureAt(float2 v)
{
	float2 TexA = (v.xy + 0.5f) / 128.0f;


	float3 p = Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, TexA, 0).xyz * 2 - 1;
	return normalize(p.xy + p.z * 0.33f);
}

float3 GetPerlinNoiseGradientTextureAt(float3 v)
{
	const float2 ZShear = float2(17.0f, 89.0f);

	float2 OffsetA = v.z * ZShear;
	float2 TexA = (v.xy + OffsetA + 0.5f) / 128.0f;

	return Texture2DSampleLevel(View_PerlinNoiseGradientTexture, View_PerlinNoiseGradientTextureSampler, TexA , 0).xyz * 2 - 1;
}

float2 SkewSimplex(float2 In)
{
	return In + dot(In, (sqrt(3.0f) - 1.0f) * 0.5f );
}
float2 UnSkewSimplex(float2 In)
{
	return In - dot(In, (3.0f - sqrt(3.0f)) / 6.0f );
}
float3 SkewSimplex(float3 In)
{
	return In + dot(In, 1.0 / 3.0f );
}
float3 UnSkewSimplex(float3 In)
{
	return In - dot(In, 1.0 / 6.0f );
}




float GradientSimplexNoise2D_TEX(float2 EvalPos)
{
	float2 OrthogonalPos = SkewSimplex(EvalPos);

	float2 PosA, PosB, PosC, PosD;
	float3 Weights = ComputeSimplexWeights2D(OrthogonalPos, PosA, PosB, PosC);


	float2 A = GetPerlinNoiseGradientTextureAt(PosA);
	float2 B = GetPerlinNoiseGradientTextureAt(PosB);
	float2 C = GetPerlinNoiseGradientTextureAt(PosC);

	PosA = UnSkewSimplex(PosA);
	PosB = UnSkewSimplex(PosB);
	PosC = UnSkewSimplex(PosC);

	float DistanceWeight;

	DistanceWeight = saturate(0.5f - length2(EvalPos - PosA)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float a = dot(A, EvalPos - PosA) * DistanceWeight;
	DistanceWeight = saturate(0.5f - length2(EvalPos - PosB)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float b = dot(B, EvalPos - PosB) * DistanceWeight;
	DistanceWeight = saturate(0.5f - length2(EvalPos - PosC)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float c = dot(C, EvalPos - PosC) * DistanceWeight;

	return 70 * (a + b + c);
}






float SimplexNoise3D_TEX(float3 EvalPos)
{
	float3 OrthogonalPos = SkewSimplex(EvalPos);

	float3 PosA, PosB, PosC, PosD;
	float4 Weights = ComputeSimplexWeights3D(OrthogonalPos, PosA, PosB, PosC, PosD);


	float3 A = GetPerlinNoiseGradientTextureAt(PosA);
	float3 B = GetPerlinNoiseGradientTextureAt(PosB);
	float3 C = GetPerlinNoiseGradientTextureAt(PosC);
	float3 D = GetPerlinNoiseGradientTextureAt(PosD);

	PosA = UnSkewSimplex(PosA);
	PosB = UnSkewSimplex(PosB);
	PosC = UnSkewSimplex(PosC);
	PosD = UnSkewSimplex(PosD);

	float DistanceWeight;

	DistanceWeight = saturate(0.6f - length2(EvalPos - PosA)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float a = dot(A, EvalPos - PosA) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosB)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float b = dot(B, EvalPos - PosB) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosC)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float c = dot(C, EvalPos - PosC) * DistanceWeight;
	DistanceWeight = saturate(0.6f - length2(EvalPos - PosD)); DistanceWeight *= DistanceWeight; DistanceWeight *= DistanceWeight;
	float d = dot(D, EvalPos - PosD) * DistanceWeight;

	return 32 * (a + b + c + d);
}


float VolumeRaymarch(float3 posPixelWS, float3 posCameraWS)
{
	float ret = 0;
	int cnt = 60;

	[loop]  for(int i=0; i < cnt; ++i)
	{
		ret += saturate(FastGradientPerlinNoise3D_TEX(lerp(posPixelWS, posCameraWS, i/(float)cnt) * 0.01) - 0.2f);
	}

	return ret / cnt * (length(posPixelWS - posCameraWS) * 0.001f );
}
#line 481 "/Engine/Private/Common.ush"
#line 486 "/Engine/Private/Common.ush"
float  PhongShadingPow( float  X,  float  Y)
{
#line 504 "/Engine/Private/Common.ush"
	return ClampedPow(X, Y);
}
#line 538 "/Engine/Private/Common.ush"
Texture2D LightAttenuationTexture;
SamplerState LightAttenuationTextureSampler;





float ConvertTangentUnormToSnorm8(float Input)
{
	int IntVal = int(round(Input * 255.0f));

	IntVal = (IntVal > 127) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 127.0f, -1, 1);
}

float2 ConvertTangentUnormToSnorm8(float2 Input)
{
	int2 IntVal = int2(round(Input * 255.0f));

	IntVal = (IntVal > 127) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 127.0f, -1, 1);
}

float3 ConvertTangentUnormToSnorm8(float3 Input)
{
	int3 IntVal = int3(round(Input * 255.0f));
	IntVal = (IntVal > 127) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 127.0f, -1, 1);
}

float4 ConvertTangentUnormToSnorm8(float4 Input)
{
	int4 IntVal = int4(round(Input * 255.0f));

	IntVal = (IntVal > 127) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 127.0f, -1, 1);
}

float ConvertTangentUnormToSnorm16(float Input)
{
	int IntVal = int(round(Input * 65535.0f));

	IntVal = (IntVal > 32767) ? (IntVal | 0xFFFF8000) : IntVal;
	return clamp(IntVal / 32767.0f, -1, 1);
}

float2 ConvertTangentUnormToSnorm16(float2 Input)
{
	int2 IntVal = int2(round(Input * 65535.0f));

	IntVal = (IntVal > 32767) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 32767.0f, -1, 1);
}

float3 ConvertTangentUnormToSnorm16(float3 Input)
{
	int3 IntVal = int3(round(Input * 65535.0f));
	IntVal = (IntVal > 32767) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 32767.0f, -1, 1);
}

float4 ConvertTangentUnormToSnorm16(float4 Input)
{
	int4 IntVal = int4(round(Input * 65535.0f));

	IntVal = (IntVal > 32767) ? (IntVal | 0xFFFFFF80) : IntVal;
	return clamp(IntVal / 32767.0f, -1, 1);
}

float ConvertTangentSnormToUnorm8(float Input)
{
	float Res = Input >= 0.0f ? Input * 127 : ((Input + 1.0) * 127) + 128;
	return clamp(Res / 255, 0.0f, 0.99f);
}

float2 ConvertTangentSnormToUnorm8(float2 Input)
{
	float2 Res = Input >= 0.0f ? Input * 127 : ((Input + 1.0) * 127) + 128;
	return clamp(Res / 255, 0.0f, 0.99f);
}

float3 ConvertTangentSnormToUnorm8(float3 Input)
{
	float3 Res = Input >= 0.0f ? Input * 127 : ((Input + 1.0) * 127) + 128;
	return clamp(Res / 255, 0.0f, 0.99f);
}

float4 ConvertTangentSnormToUnorm8(float4 Input)
{
	float4 Res = Input >= 0.0f ? Input * 127 : ((Input + 1.0) * 127) + 128;
	return clamp(Res / 255, 0.0f, 0.99f);
}

float ConvertTangentSnormToUnorm16(float Input)
{
	float Res = Input >= 0.0f ? Input * 32767 : ((Input + 1.0) * 32767) + 32768;
	return clamp(Res / 65535, 0.0f, 0.99f);
}

float2 ConvertTangentSnormToUnorm16(float2 Input)
{
	float2 Res = Input >= 0.0f ? Input * 32767 : ((Input + 1.0) * 32767) + 32768;
	return clamp(Res / 65535, 0.0f, 0.99f);
}

float3 ConvertTangentSnormToUnorm16(float3 Input)
{
	float3 Res = Input >= 0.0f ? Input * 32767 : ((Input + 1.0) * 32767) + 32768;
	return clamp(Res / 65535, 0.0f, 0.99f);
}

float4 ConvertTangentSnormToUnorm16(float4 Input)
{
	float4 Res = Input >= 0.0f ? Input * 32767 : ((Input + 1.0) * 32767) + 32768;
	return clamp(Res / 65535, 0.0f, 0.99f);
}






float Square( float x )
{
	return x*x;
}

float2 Square( float2 x )
{
	return x*x;
}

float3 Square( float3 x )
{
	return x*x;
}

float4 Square( float4 x )
{
	return x*x;
}

float Pow2( float x )
{
	return x*x;
}

float2 Pow2( float2 x )
{
	return x*x;
}

float3 Pow2( float3 x )
{
	return x*x;
}

float4 Pow2( float4 x )
{
	return x*x;
}

float Pow3( float x )
{
	return x*x*x;
}

float2 Pow3( float2 x )
{
	return x*x*x;
}

float3 Pow3( float3 x )
{
	return x*x*x;
}

float4 Pow3( float4 x )
{
	return x*x*x;
}

float Pow4( float x )
{
	float xx = x*x;
	return xx * xx;
}

float2 Pow4( float2 x )
{
	float2 xx = x*x;
	return xx * xx;
}

float3 Pow4( float3 x )
{
	float3 xx = x*x;
	return xx * xx;
}

float4 Pow4( float4 x )
{
	float4 xx = x*x;
	return xx * xx;
}

float Pow5( float x )
{
	float xx = x*x;
	return xx * xx * x;
}

float2 Pow5( float2 x )
{
	float2 xx = x*x;
	return xx * xx * x;
}

float3 Pow5( float3 x )
{
	float3 xx = x*x;
	return xx * xx * x;
}

float4 Pow5( float4 x )
{
	float4 xx = x*x;
	return xx * xx * x;
}

float Pow6( float x )
{
	float xx = x*x;
	return xx * xx * xx;
}

float2 Pow6( float2 x )
{
	float2 xx = x*x;
	return xx * xx * xx;
}

float3 Pow6( float3 x )
{
	float3 xx = x*x;
	return xx * xx * xx;
}

float4 Pow6( float4 x )
{
	float4 xx = x*x;
	return xx * xx * xx;
}


float  AtanFast(  float  x )
{

	float3  A = x < 1 ?  float3 ( x, 0, 1 ) :  float3 ( 1/x, 0.5 * PI, -1 );
	return A.y + A.z * ( ( ( -0.130234 * A.x - 0.0954105 ) * A.x + 1.00712 ) * A.x - 0.00001203333 );
}


float  EncodeLightAttenuation( float  InColor)
{


	return sqrt(InColor);
}


float4  EncodeLightAttenuation( float4  InColor)
{
	return sqrt(InColor);
}
#line 841 "/Engine/Private/Common.ush"
float3  HdrMosaic( float3  LinearColor, float2 VPos)
{
	float2 V;
	V = VPos.xy * 0.5;
	V.y += V.x;
	V = frac(V);
	float2  C;
	C = (V *  float2 (2.0 * (-0.5/255.0),  (( 6.0 * ((255.0-( 6.0 / (1.0/2.0) ))/255.0) - (1.0/2.0) ) * 2.0) )) +  float2 (-0.5/255.0,  (1.0/2.0) );
	return (LinearColor * C.y) + C.x;
}





float3  HdrDemosaic( float3  Pixel,  float3  OtherPixel, float2 VPos)
{
	float  A = frac(dot(VPos + View_DemosaicVposOffset, float2(0.5, 0.5)));
	float  B = 0.5 - A;
	A = A *  (((1.0/ 6.0 ) - (1.0/ (1.0/2.0) )) * 2.0)  +  (1.0/ (1.0/2.0) ) ;
	B = B *  (((1.0/ 6.0 ) - (1.0/ (1.0/2.0) )) * 2.0)  +  (1.0/ (1.0/2.0) ) ;





		return max((Pixel * A), (OtherPixel * B));

}



float4  RGBTEncode( float3  Color)
{
	float4  RGBT;
	float  Max = max(max(Color.r, Color.g), max(Color.b, 1e-6));
	float  RcpMax = rcp(Max);
	RGBT.rgb = Color.rgb * RcpMax;
	RGBT.a = Max * rcp(1.0 + Max);
	return RGBT;
}

float3  RGBTDecode( float4  RGBT)
{
	RGBT.a = RGBT.a * rcp(1.0 - RGBT.a);
	return RGBT.rgb * RGBT.a;
}



float4  RGBMEncode(  float3  Color )
{
	Color *= 1.0 / 64.0;

	float4 rgbm;
	rgbm.a = saturate( max( max( Color.r, Color.g ), max( Color.b, 1e-6 ) ) );
	rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;
	rgbm.rgb = Color / rgbm.a;
	return rgbm;
}

float4  RGBMEncodeFast(  float3  Color )
{

	float4  rgbm;
	rgbm.a = dot( Color, 255.0 / 64.0 );
	rgbm.a = ceil( rgbm.a );
	rgbm.rgb = Color / rgbm.a;
	rgbm *=  float4 ( 255.0 / 64.0, 255.0 / 64.0, 255.0 / 64.0, 1.0 / 255.0 );
	return rgbm;
}

float3  RGBMDecode(  float4  rgbm,  float  MaxValue )
{
	return rgbm.rgb * (rgbm.a * MaxValue);
}

float3  RGBMDecode(  float4  rgbm )
{
	return rgbm.rgb * (rgbm.a * 64.0f);
}

float4  RGBTEncode8BPC( float3  Color,  float  Range)
{
	float  Max = max(max(Color.r, Color.g), max(Color.b, 1e-6));
	Max = min(Max, Range);

	float4  RGBT;
	RGBT.a = (Range + 1) / Range * Max / (1 + Max);


	RGBT.a = ceil(RGBT.a*255.0) / 255.0;
	Max = RGBT.a / (1 + 1 / Range - RGBT.a);

	float  RcpMax = rcp(Max);
	RGBT.rgb = Color.rgb * RcpMax;
	return RGBT;
}

float3  RGBTDecode8BPC( float4  RGBT,  float  Range)
{
	RGBT.a = RGBT.a / (1 + 1 / Range - RGBT.a);
	return RGBT.rgb * RGBT.a;
}






float  GetHDR32bppEncodeMode()
{
#line 962 "/Engine/Private/Common.ush"
	return  0.0 ;
}



float4  Encode32BPPHDR( float4  Color, float2 SvPosition)
{
	float  Mode = GetHDR32bppEncodeMode();
	if (Mode ==  1.0 )
	{
		return  float4 (HdrMosaic(Color.rgb, SvPosition), Color.a);
	}
	else if (Mode ==  2.0 )
	{
		return RGBTEncode8BPC(Color.rgb,  1024.0 );
	}
	else
	{

		return Color;
	}
}

float4  Decode32BPPHDR( float4  Encoded,  float3  OtherEncoded =  float3 (0, 0, 0), float2 SvPosition = float2(0, 0))
{
	float  Mode = GetHDR32bppEncodeMode();
	if (Mode ==  1.0 )
	{
		return  float4 (HdrDemosaic(Encoded.rgb, OtherEncoded, SvPosition), 0.0f);
	}
	if (Mode ==  2.0 )
	{
		return  float4 (RGBTDecode8BPC(Encoded,  1024.0 ), 0.0f);
	}
	else
	{

		return Encoded;
	}
}


float4 Decode32BPPHDR(float4 Pixel, float2 SvPosition, Texture2D SourceTexture, SamplerState SourceSampler, float2 InTexCoords[4])
{
	float3  PixelColorN = SourceTexture.Sample(SourceSampler, InTexCoords[0].xy).rgb;
	float3  PixelColorE = SourceTexture.Sample(SourceSampler, InTexCoords[1].xy).rgb;
	float3  PixelColorW = SourceTexture.Sample(SourceSampler, InTexCoords[2].xy).rgb;
	float3  PixelColorS = SourceTexture.Sample(SourceSampler, InTexCoords[3].xy).rgb;
	float3  PixelColorV = PixelColorN * 0.5 + PixelColorS * 0.5;
	float3  PixelColorH = PixelColorW * 0.5 + PixelColorE * 0.5;
	if(abs(PixelColorN.g - PixelColorS.g) < abs(PixelColorW.g - PixelColorE.g))
	{
		PixelColorH = PixelColorV;
	}
	Pixel.rgb = Decode32BPPHDR(Pixel, PixelColorH, SvPosition.xy).rgb;
	Pixel.a = 0.0;
	return Pixel;
}
#line 1052 "/Engine/Private/Common.ush"
float2 CalcScreenUVFromOffsetFraction(float4 ScreenPosition, float2 OffsetFraction)
{
	float2 NDC = ScreenPosition.xy / ScreenPosition.w;



	float2 OffsetNDC = clamp(NDC + OffsetFraction * float2(2, -2), -.999f, .999f);
	return float2(OffsetNDC * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz);
}

float4 GetPerPixelLightAttenuation(float2 UV)
{
	return Square(Texture2DSampleLevel(LightAttenuationTexture, LightAttenuationTextureSampler, UV, 0));
}




float ConvertFromDeviceZ(float DeviceZ)
{

	return DeviceZ * View_InvDeviceZToWorldZTransform[0] + View_InvDeviceZToWorldZTransform[1] + 1.0f / (DeviceZ * View_InvDeviceZToWorldZTransform[2] - View_InvDeviceZToWorldZTransform[3]);
}




float ConvertToDeviceZ(float SceneDepth)
{
	[flatten]
	if (View_ViewToClip[3][3] < 1.0f)
	{

		return 1.0f / ((SceneDepth + View_InvDeviceZToWorldZTransform[3]) * View_InvDeviceZToWorldZTransform[2]);
	}
	else
	{

		return SceneDepth * View_ViewToClip[2][2] + View_ViewToClip[3][2];
	}
}

float2 ScreenPositionToBufferUV(float4 ScreenPosition)
{
	return float2(ScreenPosition.xy / ScreenPosition.w * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz);
}

float2 SvPositionToBufferUV(float4 SvPosition)
{
	return SvPosition.xy * View_BufferSizeAndInvSize.zw;
}


float3 SvPositionToTranslatedWorld(float4 SvPosition)
{
	float4 HomWorldPos = mul(float4(SvPosition.xyz, 1), View_SVPositionToTranslatedWorld);

	return HomWorldPos.xyz / HomWorldPos.w;
}


float3 SvPositionToResolvedTranslatedWorld(float4 SvPosition)
{
	float4 HomWorldPos = mul(float4(SvPosition.xyz, 1), ResolvedView.SVPositionToTranslatedWorld);

	return HomWorldPos.xyz / HomWorldPos.w;
}


float3 SvPositionToWorld(float4 SvPosition)
{
	return SvPositionToTranslatedWorld(SvPosition) - View_PreViewTranslation;
}


float4 SvPositionToScreenPosition(float4 SvPosition)
{



	float2 PixelPos = SvPosition.xy - View_ViewRectMin.xy;


	float3 NDCPos = float3( (PixelPos * View_ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z);


	return float4(NDCPos.xyz, 1) * SvPosition.w;
}


float4 SvPositionToResolvedScreenPosition(float4 SvPosition)
{
	float2 PixelPos = SvPosition.xy - ResolvedView.ViewRectMin.xy;


	float3 NDCPos = float3( (PixelPos * ResolvedView.ViewSizeAndInvSize.zw - 0.5f) * float2(2, -2), SvPosition.z);


	return float4(NDCPos.xyz, 1) * SvPosition.w;
}

float2 SvPositionToViewportUV(float4 SvPosition)
{

	float2 PixelPos = SvPosition.xy - View_ViewRectMin.xy;

	return PixelPos.xy * View_ViewSizeAndInvSize.zw;
}

float2 BufferUVToViewportUV(float2 BufferUV)
{
	float2 PixelPos = BufferUV.xy * View_BufferSizeAndInvSize.xy - View_ViewRectMin.xy;
	return PixelPos.xy * View_ViewSizeAndInvSize.zw;
}

float2 ViewportUVToBufferUV(float2 ViewportUV)
{
	float2 PixelPos = ViewportUV * View_ViewSizeAndInvSize.xy;
	return (PixelPos + View_ViewRectMin.xy) * View_BufferSizeAndInvSize.zw;
}


float2 ViewportUVToScreenPos(float2 ViewportUV)
{
	return float2(2 * ViewportUV.x - 1, 1 - 2 * ViewportUV.y);
}

float2 ScreenPosToViewportUV(float2 ScreenPos)
{
	return float2(0.5 + 0.5 * ScreenPos.x, 0.5 - 0.5 * ScreenPos.y);
}
#line 1190 "/Engine/Private/Common.ush"
float2  ScreenAlignedPosition( float4 ScreenPosition )
{
	return  float2 (ScreenPositionToBufferUV(ScreenPosition));
}
#line 1198 "/Engine/Private/Common.ush"
float2  ScreenAlignedUV(  float2  UV )
{
	return (UV* float2 (2,-2) +  float2 (-1,1))*View_ScreenPositionScaleBias.xy + View_ScreenPositionScaleBias.wz;
}
#line 1206 "/Engine/Private/Common.ush"
float2  GetViewportCoordinates( float2  InFragmentCoordinates)
{
	return InFragmentCoordinates;
}
#line 1214 "/Engine/Private/Common.ush"
float4  UnpackNormalMap(  float4  TextureSample )
{






		float2  NormalXY = TextureSample.rg;


	NormalXY = NormalXY *  float2 (2.0f,2.0f) -  float2 (1.0f,1.0f);
	float  NormalZ = sqrt( saturate( 1.0f - dot( NormalXY, NormalXY ) ) );
	return  float4 ( NormalXY.xy, NormalZ, 1.0f );

}


float AntialiasedTextureMask( Texture2D Tex, SamplerState Sampler, float2 UV, float ThresholdConst, int Channel )
{

	float4  MaskConst =  float4 (Channel == 0, Channel == 1, Channel == 2, Channel == 3);


	const float WidthConst = 1.0f;
	float InvWidthConst = 1 / WidthConst;
#line 1262 "/Engine/Private/Common.ush"
	float Result;
	{

		float Sample1 = dot(MaskConst, Texture2DSample(Tex, Sampler, UV));


		float2 TexDD = float2(DDX(Sample1), DDY(Sample1));

		float TexDDLength = max(abs(TexDD.x), abs(TexDD.y));
		float Top = InvWidthConst * (Sample1 - ThresholdConst);
		Result = Top / TexDDLength + ThresholdConst;
	}

	Result = saturate(Result);

	return Result;
}



float Noise3D_Multiplexer(int Function, float3 Position, int Quality, bool bTiling, float RepeatSize)
{

	switch(Function)
	{
		case 0:
			return SimplexNoise3D_TEX(Position);
		case 1:
			return GradientNoise3D_TEX(Position, bTiling, RepeatSize);
		case 2:
			return FastGradientPerlinNoise3D_TEX(Position);
		case 3:
			return GradientNoise3D_ALU(Position, bTiling, RepeatSize);
		case 4:
			return ValueNoise3D_ALU(Position, bTiling, RepeatSize);
		default:
			return VoronoiNoise3D_ALU(Position, Quality, bTiling, RepeatSize, true).w * 2. - 1.;
	}
	return 0;
}



float  MaterialExpressionNoise(float3 Position, float Scale, int Quality, int Function, bool bTurbulence, uint Levels, float OutputMin, float OutputMax, float LevelScale, float FilterWidth, bool bTiling, float RepeatSize)
{
	Position *= Scale;
	FilterWidth *= Scale;

	float Out = 0.0f;
	float OutScale = 1.0f;
	float InvLevelScale = 1.0f / LevelScale;

	[loop]  for(uint i = 0; i < Levels; ++i)
	{

		OutScale *= saturate(1.0 - FilterWidth);

		if(bTurbulence)
		{
			Out += abs(Noise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize)) * OutScale;
		}
		else
		{
			Out += Noise3D_Multiplexer(Function, Position, Quality, bTiling, RepeatSize) * OutScale;
		}

		Position *= LevelScale;
		RepeatSize *= LevelScale;
		OutScale *= InvLevelScale;
		FilterWidth *= LevelScale;
	}

	if(!bTurbulence)
	{

		Out = Out * 0.5f + 0.5f;
	}


	return lerp(OutputMin, OutputMax, Out);
}





float4  MaterialExpressionVectorNoise( float3  Position, int Quality, int Function, bool bTiling, float TileSize)
{
	float4 result = float4(0,0,0,1);
	float3x4 Jacobian = JacobianSimplex_ALU(Position, bTiling, TileSize);


	switch (Function)
	{
	case 0:
		result.xyz = float3(Rand3DPCG16(int3(floor(NoiseTileWrap(Position, bTiling, TileSize))))) / 0xffff;
		break;
	case 1:
		result.xyz = float3(Jacobian[0].w, Jacobian[1].w, Jacobian[2].w);
		break;
	case 2:
		result = Jacobian[0];
		break;
	case 3:
		result.xyz = float3(Jacobian[2][1] - Jacobian[1][2], Jacobian[0][2] - Jacobian[2][0], Jacobian[1][0] - Jacobian[0][1]);
		break;
	default:
		result = VoronoiNoise3D_ALU(Position, Quality, bTiling, TileSize, false);
		break;
	}
	return result;
}
#line 1389 "/Engine/Private/Common.ush"
float2 LineBoxIntersect(float3 RayOrigin, float3 RayEnd, float3 BoxMin, float3 BoxMax)
{
	float3 InvRayDir = 1.0f / (RayEnd - RayOrigin);


	float3 FirstPlaneIntersections = (BoxMin - RayOrigin) * InvRayDir;

	float3 SecondPlaneIntersections = (BoxMax - RayOrigin) * InvRayDir;

	float3 ClosestPlaneIntersections = min(FirstPlaneIntersections, SecondPlaneIntersections);

	float3 FurthestPlaneIntersections = max(FirstPlaneIntersections, SecondPlaneIntersections);

	float2 BoxIntersections;

	BoxIntersections.x = max(ClosestPlaneIntersections.x, max(ClosestPlaneIntersections.y, ClosestPlaneIntersections.z));

	BoxIntersections.y = min(FurthestPlaneIntersections.x, min(FurthestPlaneIntersections.y, FurthestPlaneIntersections.z));

	return saturate(BoxIntersections);
}


float  ComputeDistanceFromBoxToPoint( float3  Mins,  float3  Maxs,  float3  InPoint)
{
	float3  DistancesToMin = InPoint < Mins ? abs(InPoint - Mins) : 0;
	float3  DistancesToMax = InPoint > Maxs ? abs(InPoint - Maxs) : 0;


	float  Distance = dot(DistancesToMin, 1);
	Distance += dot(DistancesToMax, 1);
	return Distance;
}


float  ComputeSquaredDistanceFromBoxToPoint( float3  BoxCenter,  float3  BoxExtent,  float3  InPoint)
{
	float3  AxisDistances = max(abs(InPoint - BoxCenter) - BoxExtent, 0);
	return dot(AxisDistances, AxisDistances);
}


float ComputeDistanceFromBoxToPointInside(float3 BoxCenter, float3 BoxExtent, float3 InPoint)
{
	float3 DistancesToMin = max(InPoint - BoxCenter + BoxExtent, 0);
	float3 DistancesToMax = max(BoxCenter + BoxExtent - InPoint, 0);
	float3 ClosestDistances = min(DistancesToMin, DistancesToMax);
	return min(ClosestDistances.x, min(ClosestDistances.y, ClosestDistances.z));
}

bool RayHitSphere(float3 RayOrigin, float3 UnitRayDirection, float3 SphereCenter, float SphereRadius)
{
	float3 ClosestPointOnRay = max(0, dot(SphereCenter - RayOrigin, UnitRayDirection)) * UnitRayDirection;
	float3 CenterToRay = RayOrigin + ClosestPointOnRay - SphereCenter;
	return dot(CenterToRay, CenterToRay) <= Square(SphereRadius);
}

bool RaySegmentHitSphere(float3 RayOrigin, float3 UnitRayDirection, float RayLength, float3 SphereCenter, float SphereRadius)
{
	float DistanceAlongRay = dot(SphereCenter - RayOrigin, UnitRayDirection);
	float3 ClosestPointOnRay = DistanceAlongRay * UnitRayDirection;
	float3 CenterToRay = RayOrigin + ClosestPointOnRay - SphereCenter;
	return dot(CenterToRay, CenterToRay) <= Square(SphereRadius) && DistanceAlongRay > -SphereRadius && DistanceAlongRay - SphereRadius < RayLength;
}
#line 1458 "/Engine/Private/Common.ush"
float2 RayIntersectSphere(float3 RayOrigin, float3 RayDirection, float4 Sphere)
{
	float3 LocalPosition = RayOrigin - Sphere.xyz;
	float LocalPositionSqr = dot(LocalPosition, LocalPosition);

	float3 QuadraticCoef;
	QuadraticCoef.x = dot(RayDirection, RayDirection);
	QuadraticCoef.y = 2 * dot(RayDirection, LocalPosition);
	QuadraticCoef.z = LocalPositionSqr - Sphere.w * Sphere.w;

	float Discriminant = QuadraticCoef.y * QuadraticCoef.y - 4 * QuadraticCoef.x * QuadraticCoef.z;

	float2 Intersections = -1;


	[flatten]
	if (Discriminant >= 0)
	{
		float SqrtDiscriminant = sqrt(Discriminant);
		Intersections = (-QuadraticCoef.y + float2(-1, 1) * SqrtDiscriminant) / (2 * QuadraticCoef.x);
	}

	return Intersections;
}


float3  TransformTangentVectorToWorld( float3x3  TangentToWorld,  float3  InTangentVector)
{


	return mul(InTangentVector, TangentToWorld);
}


float3  TransformWorldVectorToTangent( float3x3  TangentToWorld,  float3  InWorldVector)
{


	return mul(TangentToWorld, InWorldVector);
}

float3 TransformWorldVectorToView(float3 InTangentVector)
{

	return mul(InTangentVector, (float3x3)ResolvedView.TranslatedWorldToView);
}


float  GetBoxPushout( float3  Normal, float3  Extent)
{
	return dot(abs(Normal * Extent),  float3 (1.0f, 1.0f, 1.0f));
}


void GenerateCoordinateSystem(float3 ZAxis, out float3 XAxis, out float3 YAxis)
{
	if (abs(ZAxis.x) > abs(ZAxis.y))
	{
		float InverseLength = 1.0f / sqrt(dot(ZAxis.xz, ZAxis.xz));
		XAxis = float3(-ZAxis.z * InverseLength, 0.0f, ZAxis.x * InverseLength);
	}
	else
	{
		float InverseLength = 1.0f / sqrt(dot(ZAxis.yz, ZAxis.yz));
		XAxis = float3(0.0f, ZAxis.z * InverseLength, -ZAxis.y * InverseLength);
	}

	YAxis = cross(ZAxis, XAxis);
}
#line 1537 "/Engine/Private/Common.ush"
struct FScreenVertexOutput
{




	noperspective  float2  UV : TEXCOORD0;

	float4 Position : SV_POSITION;
};





float2 EncodeVelocityToTexture(float2 In)
{


	return In * (0.499f * 0.5f) + 32767.0f / 65535.0f;
}

float2 DecodeVelocityFromTexture(float2 In)
{
	const float InvDiv = 1.0f / (0.499f * 0.5f);



	return In * InvDiv - 32767.0f / 65535.0f * InvDiv;
}


bool GetGIReplaceState()
{



	return false;

}

bool GetRayTracingQualitySwitch()
{



	return false;

}


struct FWriteToSliceGeometryOutput
{
	FScreenVertexOutput Vertex;
	uint LayerIndex : SV_RenderTargetArrayIndex;
};







void DrawRectangle( in float4 InPosition, in float2 InTexCoord, out float4 OutPosition, out float2 OutTexCoord)
{
	OutPosition = InPosition;
	OutPosition.xy = -1.0f + 2.0f * (DrawRectangleParameters_PosScaleBias.zw + (InPosition.xy * DrawRectangleParameters_PosScaleBias.xy)) * DrawRectangleParameters_InvTargetSizeAndTextureSize.xy;
	OutPosition.xy *= float2( 1, -1 );
	OutTexCoord.xy = (DrawRectangleParameters_UVScaleBias.zw + (InTexCoord.xy * DrawRectangleParameters_UVScaleBias.xy)) * DrawRectangleParameters_InvTargetSizeAndTextureSize.zw;
}


void DrawRectangle( in float4 InPosition, out float4 OutPosition)
{
	OutPosition = InPosition;
	OutPosition.xy = -1.0f + 2.0f * (DrawRectangleParameters_PosScaleBias.zw + (InPosition.xy * DrawRectangleParameters_PosScaleBias.xy)) * DrawRectangleParameters_InvTargetSizeAndTextureSize.xy;
	OutPosition.xy *= float2( 1, -1 );
}
#line 1627 "/Engine/Private/Common.ush"
float SafeSaturate(float In) { return saturate(In);}
float2 SafeSaturate(float2 In) { return saturate(In);}
float3 SafeSaturate(float3 In) { return saturate(In);}
float4 SafeSaturate(float4 In) { return saturate(In);}
#line 1656 "/Engine/Private/Common.ush"
bool IsFinite(float In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool IsPositiveFinite(float In) { return asuint(In) < 0x7F800000; }float MakeFinite(float In) { return !IsFinite(In)? 0 : In; }float MakePositiveFinite(float In) { return !IsPositiveFinite(In)? 0 : In; }
bool2 IsFinite(float2 In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool2 IsPositiveFinite(float2 In) { return asuint(In) < 0x7F800000; }float2 MakeFinite(float2 In) { return !IsFinite(In)? 0 : In; }float2 MakePositiveFinite(float2 In) { return !IsPositiveFinite(In)? 0 : In; }
bool3 IsFinite(float3 In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool3 IsPositiveFinite(float3 In) { return asuint(In) < 0x7F800000; }float3 MakeFinite(float3 In) { return !IsFinite(In)? 0 : In; }float3 MakePositiveFinite(float3 In) { return !IsPositiveFinite(In)? 0 : In; }
bool4 IsFinite(float4 In) { return (asuint(In) & 0x7F800000) != 0x7F800000; }bool4 IsPositiveFinite(float4 In) { return asuint(In) < 0x7F800000; }float4 MakeFinite(float4 In) { return !IsFinite(In)? 0 : In; }float4 MakePositiveFinite(float4 In) { return !IsPositiveFinite(In)? 0 : In; }





bool GetShadowReplaceState()
{



	return false;

}

float IsShadowDepthShader()
{
	return GetShadowReplaceState() ? 1.0f : 0.0f;
}




float DecodePackedTwoChannelValue(float2 PackedHeight)
{
	return PackedHeight.x * 255.0 * 256.0 + PackedHeight.y * 255.0;
}

float DecodeHeightValue(float InValue)
{
	return (InValue - 32768.0) *  (1.0f/128.0f) ;
}

float DecodePackedHeight(float2 PackedHeight)
{
	return DecodeHeightValue(DecodePackedTwoChannelValue(PackedHeight));
}


uint ReverseBits32( uint bits )
{

	return reversebits( bits );
#line 1710 "/Engine/Private/Common.ush"
}


uint ReverseBitsN(uint Bitfield, const uint BitCount)
{
	return ReverseBits32(Bitfield) >> (32 - BitCount);
}


struct FPixelShaderIn
{

	float4 SvPosition;


	uint Coverage;


	bool bIsFrontFace;
};

struct FPixelShaderOut
{

	float4 MRT[8];


	uint Coverage;


	float Depth;
};
#line 8 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 1 "DeferredShadingCommon.ush"
#line 10 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "ShadingCommon.ush"
#line 26 "/Engine/Private/ShadingCommon.ush"
uint GetShadingModelID()
{
#line 49 "/Engine/Private/ShadingCommon.ush"
	return  0xF ;

}


float3 GetShadingModelColor(uint ShadingModelID)
{
#line 71 "/Engine/Private/ShadingCommon.ush"
	switch(ShadingModelID)
	{
		case  0 : return float3(0.1f, 0.1f, 0.2f);
		case  1 : return float3(0.1f, 1.0f, 0.1f);
		case  2 : return float3(1.0f, 0.1f, 0.1f);
		case  3 : return float3(0.6f, 0.4f, 0.1f);
		case  4 : return float3(0.1f, 0.4f, 0.4f);
		case  5 : return float3(0.2f, 0.6f, 0.5f);
		case  6 : return float3(0.2f, 0.2f, 0.8f);
		case  7 : return float3(0.6f, 0.1f, 0.5f);
		case  8 : return float3(0.7f, 1.0f, 1.0f);
		case  9 : return float3(0.3f, 1.0f, 1.0f);
		default: return float3(1.0f, 1.0f, 1.0f);
	}

}


float DielectricSpecularToF0(float Specular)
{
	return 0.08f * Specular;
}


float DielectricF0ToIor(float F0)
{
	return 2.0f / (1.0f - sqrt(F0)) - 1.0f;
}

float3 ComputeF0(float Specular, float3 BaseColor, float Metallic)
{
	return lerp(DielectricSpecularToF0(Specular).xxx, BaseColor, Metallic.xxx);
}
#line 11 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "LightAccumulator.ush"
#line 23 "/Engine/Private/LightAccumulator.ush"
struct FLightAccumulator
{
	float3 TotalLight;




	float ScatterableLightLuma;




	float3 ScatterableLight;



	float EstimatedCost;
};



void LightAccumulator_Add(inout FLightAccumulator In, float3 TotalLight, float3 ScatterableLight, float3 CommonMultiplier, const bool bNeedsSeparateSubsurfaceLightAccumulation)
{

	In.TotalLight += TotalLight * CommonMultiplier;


	if (bNeedsSeparateSubsurfaceLightAccumulation)
	{
		if ( 1  == 1)
		{
			if (View_bCheckerboardSubsurfaceProfileRendering == 0)
			{
				In.ScatterableLightLuma += Luminance(ScatterableLight * CommonMultiplier);
			}
		}
		else if ( 1  == 2)
		{

			In.ScatterableLight += ScatterableLight * CommonMultiplier;
		}
	}
}




float4 LightAccumulator_GetResult(FLightAccumulator In)
{
	float4 Ret;

	if ( 0  == 1)
	{

		Ret = 0.1f * float4(1.0f, 0.25f, 0.075f, 0) * In.EstimatedCost;
	}
	else
	{
		Ret = float4(In.TotalLight, 0);

		if ( 1  == 1 )
		{
			if (View_bCheckerboardSubsurfaceProfileRendering == 0)
			{

				Ret.a = In.ScatterableLightLuma;
			}
		}
		else if ( 1  == 2)
		{


			Ret.a = Luminance(In.ScatterableLight);

		}
	}

	return Ret;
}
#line 12 "/Engine/Private/DeferredShadingCommon.ush"
#line 1 "SceneTexturesCommon.ush"
#line 16 "/Engine/Private/SceneTexturesCommon.ush"
float3 CalcSceneColor(float2 ScreenUV)
{



	return Texture2DSampleLevel(SceneTexturesStruct_SceneColorTexture, SceneTexturesStruct_SceneColorTextureSampler, ScreenUV, 0).rgb;

}


float4 CalcFullSceneColor(float2 ScreenUV)
{



	return Texture2DSample(SceneTexturesStruct_SceneColorTexture, SceneTexturesStruct_SceneColorTextureSampler,ScreenUV);

}

float CalcSceneDepth(float2 ScreenUV)
{



	return ConvertFromDeviceZ(Texture2DSampleLevel(SceneTexturesStruct_SceneDepthTexture, SceneTexturesStruct_SceneDepthTextureSampler, ScreenUV, 0).r);

}
#line 47 "/Engine/Private/SceneTexturesCommon.ush"
float4 CalcSceneColorAndDepth( float2 ScreenUV )
{
	return float4(CalcSceneColor(ScreenUV), CalcSceneDepth(ScreenUV));
}


float LookupDeviceZ( float2 ScreenUV )
{

	return Texture2DSampleLevel(SceneTexturesStruct_SceneDepthTexture, SceneTexturesStruct_SceneDepthTextureSampler, ScreenUV, 0).r;
}


float CalcSceneDepth(uint2 PixelPos)
{



	float DeviceZ = SceneTexturesStruct_SceneDepthTextureNonMS.Load(int3(PixelPos, 0));


	return ConvertFromDeviceZ(DeviceZ);

}
#line 13 "/Engine/Private/DeferredShadingCommon.ush"







float3 RGBToYCoCg( float3 RGB )
{
	float Y = dot( RGB, float3( 1, 2, 1 ) ) * 0.25;
	float Co = dot( RGB, float3( 2, 0, -2 ) ) * 0.25 + ( 0.5 * 256.0 / 255.0 );
	float Cg = dot( RGB, float3( -1, 2, -1 ) ) * 0.25 + ( 0.5 * 256.0 / 255.0 );

	float3 YCoCg = float3( Y, Co, Cg );
	return YCoCg;
}

float3 YCoCgToRGB( float3 YCoCg )
{
	float Y = YCoCg.x;
	float Co = YCoCg.y - ( 0.5 * 256.0 / 255.0 );
	float Cg = YCoCg.z - ( 0.5 * 256.0 / 255.0 );

	float R = Y + Co - Cg;
	float G = Y + Cg;
	float B = Y - Co - Cg;

	float3 RGB = float3( R, G, B );
	return RGB;
}










float2 UnitVectorToOctahedron( float3 N )
{
	N.xy /= dot( 1, abs(N) );
	if( N.z <= 0 )
	{
		N.xy = ( 1 - abs(N.yx) ) * ( N.xy >= 0 ? float2(1,1) : float2(-1,-1) );
	}
	return N.xy;
}

float3 OctahedronToUnitVector( float2 Oct )
{
	float3 N = float3( Oct, 1 - dot( 1, abs(Oct) ) );
	if( N.z < 0 )
	{
		N.xy = ( 1 - abs(N.yx) ) * ( N.xy >= 0 ? float2(1,1) : float2(-1,-1) );
	}
	return normalize(N);
}

float2 UnitVectorToHemiOctahedron( float3 N )
{
	N.xy /= dot( 1, abs(N) );
	return float2( N.x + N.y, N.x - N.y );
}

float3 HemiOctahedronToUnitVector( float2 Oct )
{
	Oct = float2( Oct.x + Oct.y, Oct.x - Oct.y ) * 0.5;
	float3 N = float3( Oct, 1 - dot( 1, abs(Oct) ) );
	return normalize(N);
}

float3 Pack1212To888( float2 x )
{








	float2 x1212 = floor( x * 4095 );
	float2 High = floor( x1212 / 256 );
	float2 Low = x1212 - High * 256;
	float3 x888 = float3( Low, High.x + High.y * 16 );
	return saturate( x888 / 255 );

}

float2 Pack888To1212( float3 x )
{








	float3 x888 = floor( x * 255 );
	float High = floor( x888.z / 16 );
	float Low = x888.z - High * 16;
	float2 x1212 = x888.xy + float2( Low, High ) * 256;
	return saturate( x1212 / 4095 );

}

float3 EncodeNormal( float3 N )
{
	return N * 0.5 + 0.5;

}

float3 DecodeNormal( float3 N )
{
	return N * 2 - 1;

}

void EncodeNormal( inout float3 N, out uint Face )
{

	uint Axis = 2;
	if( abs(N.x) >= abs(N.y) && abs(N.x) >= abs(N.z) )
	{
		Axis = 0;
	}
	else if( abs(N.y) > abs(N.z) )
	{
		Axis = 1;
	}
	Face = Axis * 2;
#line 153 "/Engine/Private/DeferredShadingCommon.ush"
	N = Axis == 0 ? N.yzx : N;
	N = Axis == 1 ? N.xzy : N;

	Face += N.z > 0 ? 0 : 1;
	N.xy *= N.z > 0 ? 1 : -1;
	N.xy = N.xy * 0.5 + 0.5;
}

void DecodeNormal( inout float3 N, in uint Face )
{
	uint Axis = Face >> 1;

	N.xy = N.xy * 2 - 1;
	N.z = sqrt( 1 - dot( N.xy, N.xy ) );

	N = Axis == 0 ? N.zxy : N;
	N = Axis == 1 ? N.xzy : N;
	N *= (Face & 1) ? -1 : 1;
}

float3 EncodeBaseColor(float3 BaseColor)
{

	return BaseColor;
}

float3 DecodeBaseColor(float3 BaseColor)
{

	return BaseColor;
}

float3 EncodeSubsurfaceColor(float3 SubsurfaceColor)
{
	return sqrt(saturate(SubsurfaceColor));
}


float3 EncodeSubsurfaceProfile(float SubsurfaceProfile)
{
	return float3(SubsurfaceProfile, 0, 0);
}

float EncodeIndirectIrradiance(float IndirectIrradiance)
{
	float L = IndirectIrradiance;
#line 202 "/Engine/Private/DeferredShadingCommon.ush"
	const float LogBlackPoint = 0.00390625;
	return log2( L + LogBlackPoint ) / 16 + 0.5;
}

float DecodeIndirectIrradiance(float IndirectIrradiance)
{



	const float OneOverPreExposure = 1.f;



	float LogL = IndirectIrradiance;
	const float LogBlackPoint = 0.00390625;
	return OneOverPreExposure * (exp2( LogL * 16 - 8 ) - LogBlackPoint);
}

float ComputeAngleFromRoughness( float Roughness, const float Threshold = 0.04f )
{

	float Angle = 3 * Square( Roughness );
#line 229 "/Engine/Private/DeferredShadingCommon.ush"
	return Angle;
}

float ComputeRoughnessFromAngle( float Angle, const float Threshold = 0.04f )
{

	float Roughness = sqrt( 0.33333 * Angle );
#line 241 "/Engine/Private/DeferredShadingCommon.ush"
	return Roughness;
}

float AddAngleToRoughness( float Angle, float Roughness )
{
	return saturate( sqrt( Square( Roughness ) + 0.33333 * Angle ) );
}




float Encode71(float Scalar, uint Mask)
{
	return
		127.0f / 255.0f * saturate(Scalar) +
		128.0f / 255.0f * Mask;
}





float Decode71(float Scalar, out uint Mask)
{
	Mask = (uint)(Scalar > 0.5f);

	return (Scalar - 0.5f * Mask) * 2.0f;
}

float EncodeShadingModelIdAndSelectiveOutputMask(uint ShadingModelId, uint SelectiveOutputMask)
{
	uint Value = (ShadingModelId &  0xF ) | SelectiveOutputMask;
	return (float)Value / (float)0xFF;
}

uint DecodeShadingModelId(float InPackedChannel)
{
	return ((uint)round(InPackedChannel * (float)0xFF)) &  0xF ;
}

uint DecodeSelectiveOutputMask(float InPackedChannel)
{
	return ((uint)round(InPackedChannel * (float)0xFF)) & ~ 0xF ;
}

bool IsSubsurfaceModel(int ShadingModel)
{
	return ShadingModel ==  2
		|| ShadingModel ==  3
		|| ShadingModel ==  5
		|| ShadingModel ==  6
		|| ShadingModel ==  7
		|| ShadingModel ==  9 ;
}

bool UseSubsurfaceProfile(int ShadingModel)
{
	return ShadingModel ==  5  || ShadingModel ==  9 ;
}


struct FGBufferData
{

	float3 WorldNormal;

	float3 DiffuseColor;

	float3 SpecularColor;

	float3 BaseColor;

	float Metallic;

	float Specular;

	float4 CustomData;

	float IndirectIrradiance;


	float4 PrecomputedShadowFactors;

	float Roughness;

	float GBufferAO;

	uint ShadingModelID;

	uint SelectiveOutputMask;

	float PerObjectGBufferData;

	float CustomDepth;

	uint CustomStencil;


	float Depth;

	float4 Velocity;


	float3 StoredBaseColor;

	float StoredSpecular;

	float StoredMetallic;
};

bool HasDistanceFieldRepresentation(FGBufferData GBufferData)
{
	uint PackedAlpha = (uint)(GBufferData.PerObjectGBufferData * 3.999f);
	return PackedAlpha & 1;
}

bool HasDynamicIndirectShadowCasterRepresentation(FGBufferData GBufferData)
{
	uint PackedAlpha = (uint)(GBufferData.PerObjectGBufferData * 3.999f);
	return (PackedAlpha & 2) != 0;
}

struct FScreenSpaceData
{

	FGBufferData GBuffer;

	float AmbientOcclusion;
};


void SetGBufferForUnlit(out float4 OutGBufferB)
{
	OutGBufferB = 0;
	OutGBufferB.a = EncodeShadingModelIdAndSelectiveOutputMask( 0 , 0);
}


void EncodeGBuffer(
	FGBufferData GBuffer,
	out float4 OutGBufferA,
	out float4 OutGBufferB,
	out float4 OutGBufferC,
	out float4 OutGBufferD,
	out float4 OutGBufferE,
	out float4 OutGBufferVelocity,
	float QuantizationBias = 0
	)
{
	if (GBuffer.ShadingModelID ==  0 )
	{
		OutGBufferA = 0;
		SetGBufferForUnlit(OutGBufferB);
		OutGBufferC = 0;
		OutGBufferD = 0;
		OutGBufferE = 0;
	}
	else
	{

		OutGBufferA.rgb = EncodeNormal( GBuffer.WorldNormal );
		OutGBufferA.a = GBuffer.PerObjectGBufferData;
#line 413 "/Engine/Private/DeferredShadingCommon.ush"
		OutGBufferB.r = GBuffer.Metallic;
		OutGBufferB.g = GBuffer.Specular;
		OutGBufferB.b = GBuffer.Roughness;
		OutGBufferB.a = EncodeShadingModelIdAndSelectiveOutputMask(GBuffer.ShadingModelID, GBuffer.SelectiveOutputMask);

		OutGBufferC.rgb = EncodeBaseColor( GBuffer.BaseColor );



		OutGBufferC.a = EncodeIndirectIrradiance(GBuffer.IndirectIrradiance * GBuffer.GBufferAO) + QuantizationBias * (1.0 / 255.0);
#line 427 "/Engine/Private/DeferredShadingCommon.ush"
		OutGBufferD = GBuffer.CustomData;
		OutGBufferE = GBuffer.PrecomputedShadowFactors;
	}




	OutGBufferVelocity = 0;

}




bool CheckerFromPixelPos(uint2 PixelPos)
{


	uint TemporalAASampleIndex = View_TemporalAAParams.x;


	return (PixelPos.x + PixelPos.y + TemporalAASampleIndex) % 2;
#line 452 "/Engine/Private/DeferredShadingCommon.ush"
}




bool CheckerFromSceneColorUV(float2 UVSceneColor)
{

	uint2 PixelPos = uint2(UVSceneColor * View_BufferSizeAndInvSize.xy);

	return CheckerFromPixelPos(PixelPos);
}




void AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(inout float3 BaseColor, inout float3 SpecularColor, inout float Specular, bool bChecker)
{





	const bool bCheckerboardRequired = View_bSubsurfacePostprocessEnabled > 0 && View_bCheckerboardSubsurfaceProfileRendering > 0;
	BaseColor = View_bSubsurfacePostprocessEnabled ? float3(1, 1, 1) : BaseColor;

	if (bCheckerboardRequired)
	{



		BaseColor = bChecker;

		SpecularColor *= !bChecker;
		Specular *= !bChecker;
	}
}



FGBufferData DecodeGBufferData(
	float4 InGBufferA,
	float4 InGBufferB,
	float4 InGBufferC,
	float4 InGBufferD,
	float4 InGBufferE,
	float4 InGBufferVelocity,
	float CustomNativeDepth,
	uint CustomStencil,
	float SceneDepth,
	bool bGetNormalizedNormal,
	bool bChecker)
{
	FGBufferData GBuffer;

	GBuffer.WorldNormal = DecodeNormal( InGBufferA.xyz );
	if(bGetNormalizedNormal)
	{
		GBuffer.WorldNormal = normalize(GBuffer.WorldNormal);
	}

	GBuffer.PerObjectGBufferData = InGBufferA.a;
	GBuffer.Metallic = InGBufferB.r;
	GBuffer.Specular = InGBufferB.g;
	GBuffer.Roughness = InGBufferB.b;



	GBuffer.ShadingModelID = DecodeShadingModelId(InGBufferB.a);
	GBuffer.SelectiveOutputMask = DecodeSelectiveOutputMask(InGBufferB.a);

	GBuffer.BaseColor = DecodeBaseColor(InGBufferC.rgb);


	GBuffer.GBufferAO = 1;
	GBuffer.IndirectIrradiance = DecodeIndirectIrradiance(InGBufferC.a);
#line 533 "/Engine/Private/DeferredShadingCommon.ush"
	GBuffer.CustomData = !(GBuffer.SelectiveOutputMask &  (1 << 4) ) ? InGBufferD : 0;

	GBuffer.PrecomputedShadowFactors = !(GBuffer.SelectiveOutputMask &  (1 << 5) ) ? InGBufferE : ((GBuffer.SelectiveOutputMask &  (1 << 6) ) ? 0 : 1);
	GBuffer.CustomDepth = ConvertFromDeviceZ(CustomNativeDepth);
	GBuffer.CustomStencil = CustomStencil;
	GBuffer.Depth = SceneDepth;

	GBuffer.StoredBaseColor = GBuffer.BaseColor;
	GBuffer.StoredMetallic = GBuffer.Metallic;
	GBuffer.StoredSpecular = GBuffer.Specular;

	[flatten]
	if( GBuffer.ShadingModelID ==  9  )
	{
		GBuffer.Metallic = 0.0;
#line 551 "/Engine/Private/DeferredShadingCommon.ush"
	}


	{
		GBuffer.SpecularColor = ComputeF0(GBuffer.Specular, GBuffer.BaseColor, GBuffer.Metallic);

		if (UseSubsurfaceProfile(GBuffer.ShadingModelID))
		{
			AdjustBaseColorAndSpecularColorForSubsurfaceProfileLighting(GBuffer.BaseColor, GBuffer.SpecularColor, GBuffer.Specular, bChecker);
		}

		GBuffer.DiffuseColor = GBuffer.BaseColor - GBuffer.BaseColor * GBuffer.Metallic;


		{

			GBuffer.DiffuseColor = GBuffer.DiffuseColor * View_DiffuseOverrideParameter.www + View_DiffuseOverrideParameter.xyz;
			GBuffer.SpecularColor = GBuffer.SpecularColor * View_SpecularOverrideParameter.w + View_SpecularOverrideParameter.xyz;
		}

	}

	GBuffer.Velocity = !(GBuffer.SelectiveOutputMask &  (1 << 7) ) ? InGBufferVelocity : 0;

	return GBuffer;
}

float3 ExtractSubsurfaceColor(FGBufferData BufferData)
{
	return Square(BufferData.CustomData.rgb);
}

uint ExtractSubsurfaceProfileInt(FGBufferData BufferData)
{

	return uint(BufferData.CustomData.r * 255.0f + 0.5f);
}
#line 598 "/Engine/Private/DeferredShadingCommon.ush"
	FGBufferData GetGBufferDataUint(uint2 PixelPos, bool bGetNormalizedNormal = true)
	{
		float4 GBufferA = SceneTexturesStruct_GBufferATextureNonMS.Load(int3(PixelPos, 0));
		float4 GBufferB = SceneTexturesStruct_GBufferBTextureNonMS.Load(int3(PixelPos, 0));
		float4 GBufferC = SceneTexturesStruct_GBufferCTextureNonMS.Load(int3(PixelPos, 0));
		float4 GBufferD = SceneTexturesStruct_GBufferDTextureNonMS.Load(int3(PixelPos, 0));
		float CustomNativeDepth = SceneTexturesStruct_CustomDepthTextureNonMS.Load(int3(PixelPos, 0)).r;
		uint CustomStencil = SceneTexturesStruct_CustomStencilTexture.Load(int3(PixelPos, 0))  .g ;


			float4 GBufferE = SceneTexturesStruct_GBufferETextureNonMS.Load(int3(PixelPos, 0));
#line 616 "/Engine/Private/DeferredShadingCommon.ush"
			float4 GBufferVelocity = 0;


		float SceneDepth = CalcSceneDepth(PixelPos);

		return DecodeGBufferData(GBufferA, GBufferB, GBufferC, GBufferD, GBufferE, GBufferVelocity, CustomNativeDepth, CustomStencil, SceneDepth, bGetNormalizedNormal, CheckerFromPixelPos(PixelPos));
	}


	FScreenSpaceData GetScreenSpaceDataUint(uint2 PixelPos, bool bGetNormalizedNormal = true)
	{
		FScreenSpaceData Out;

		Out.GBuffer = GetGBufferDataUint(PixelPos, bGetNormalizedNormal);





		float4 ScreenSpaceAO = Texture2DSampleLevel(SceneTexturesStruct_ScreenSpaceAOTexture, SceneTexturesStruct_ScreenSpaceAOTextureSampler, (PixelPos + 0.5f) * View_BufferSizeAndInvSize.zw, 0);
		Out.AmbientOcclusion = ScreenSpaceAO.r;

		return Out;
	}



FGBufferData GetGBufferData(float2 UV, bool bGetNormalizedNormal = true)
{
#line 660 "/Engine/Private/DeferredShadingCommon.ush"
	float4 GBufferA = Texture2DSampleLevel(SceneTexturesStruct_GBufferATexture, SceneTexturesStruct_GBufferATextureSampler, UV, 0);
	float4 GBufferB = Texture2DSampleLevel(SceneTexturesStruct_GBufferBTexture, SceneTexturesStruct_GBufferBTextureSampler, UV, 0);
	float4 GBufferC = Texture2DSampleLevel(SceneTexturesStruct_GBufferCTexture, SceneTexturesStruct_GBufferCTextureSampler, UV, 0);
	float4 GBufferD = Texture2DSampleLevel(SceneTexturesStruct_GBufferDTexture, SceneTexturesStruct_GBufferDTextureSampler, UV, 0);
	float CustomNativeDepth = Texture2DSampleLevel(SceneTexturesStruct_CustomDepthTexture, SceneTexturesStruct_CustomDepthTextureSampler, UV, 0).r;


	int2 IntUV = (int2)trunc(UV * View_BufferSizeAndInvSize.xy);
	uint CustomStencil = SceneTexturesStruct_CustomStencilTexture.Load(int3(IntUV, 0))  .g ;
#line 674 "/Engine/Private/DeferredShadingCommon.ush"
		float4 GBufferE = Texture2DSampleLevel(SceneTexturesStruct_GBufferETexture, SceneTexturesStruct_GBufferETextureSampler, UV, 0);
#line 682 "/Engine/Private/DeferredShadingCommon.ush"
		float4 GBufferVelocity = 0;



	float SceneDepth = CalcSceneDepth(UV);

	return DecodeGBufferData(GBufferA, GBufferB, GBufferC, GBufferD, GBufferE, GBufferVelocity, CustomNativeDepth, CustomStencil, SceneDepth, bGetNormalizedNormal, CheckerFromSceneColorUV(UV));
}


uint GetShadingModelId(float2 UV)
{
	return DecodeShadingModelId(Texture2DSampleLevel(SceneTexturesStruct_GBufferBTexture, SceneTexturesStruct_GBufferBTextureSampler, UV, 0).a);
}


FScreenSpaceData GetScreenSpaceData(float2 UV, bool bGetNormalizedNormal = true)
{
	FScreenSpaceData Out;

	Out.GBuffer = GetGBufferData(UV, bGetNormalizedNormal);
	float4 ScreenSpaceAO = Texture2DSampleLevel(SceneTexturesStruct_ScreenSpaceAOTexture, SceneTexturesStruct_ScreenSpaceAOTextureSampler, UV, 0);

	Out.AmbientOcclusion = ScreenSpaceAO.r;

	return Out;
}
#line 9 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 1 "BRDF.ush"
#line 10 "/Engine/Private/BRDF.ush"
struct BxDFContext
{
	float NoV;
	float NoL;
	float VoL;
	float NoH;
	float VoH;

};

void Init( inout BxDFContext Context,  float3  N,  float3  V,  float3  L )
{
	Context.NoL = dot(N, L);
	Context.NoV = dot(N, V);
	Context.VoL = dot(V, L);
	float InvLenH = rsqrt( 2 + 2 * Context.VoL );
	Context.NoH = saturate( ( Context.NoL + Context.NoV ) * InvLenH );
	Context.VoH = saturate( InvLenH + InvLenH * Context.VoL );


}


void SphereMaxNoH( inout BxDFContext Context, float SinAlpha, bool bNewtonIteration )
{
	if( SinAlpha > 0 )
	{
		float CosAlpha = sqrt( 1 - Pow2( SinAlpha ) );

		float RoL = 2 * Context.NoL * Context.NoV - Context.VoL;
		if( RoL >= CosAlpha )
		{
			Context.NoH = 1;
			Context.VoH = abs( Context.NoV );
		}
		else
		{
			float rInvLengthT = SinAlpha * rsqrt( 1 - RoL*RoL );
			float NoTr = rInvLengthT * ( Context.NoV - RoL * Context.NoL );
			float VoTr = rInvLengthT * ( 2 * Context.NoV*Context.NoV - 1 - RoL * Context.VoL );

			if( bNewtonIteration )
			{

				float NxLoV = sqrt( saturate( 1 - Pow2(Context.NoL) - Pow2(Context.NoV) - Pow2(Context.VoL) + 2 * Context.NoL * Context.NoV * Context.VoL ) );

				float NoBr = rInvLengthT * NxLoV;
				float VoBr = rInvLengthT * NxLoV * 2 * Context.NoV;
				float NoLVTr = Context.NoL * CosAlpha + Context.NoV + NoTr;
				float VoLVTr = Context.VoL * CosAlpha + 1 + VoTr;

				float p = NoBr * VoLVTr;
				float q = NoLVTr * VoLVTr;
				float s = VoBr * NoLVTr;

				float xNum = q * ( -0.5 * p + 0.25 * VoBr * NoLVTr );
				float xDenom = p*p + s * (s - 2*p) + NoLVTr * ( (Context.NoL * CosAlpha + Context.NoV) * Pow2(VoLVTr) + q * (-0.5 * (VoLVTr + Context.VoL * CosAlpha) - 0.5) );
				float TwoX1 = 2 * xNum / ( Pow2(xDenom) + Pow2(xNum) );
				float SinTheta = TwoX1 * xDenom;
				float CosTheta = 1.0 - TwoX1 * xNum;
				NoTr = CosTheta * NoTr + SinTheta * NoBr;
				VoTr = CosTheta * VoTr + SinTheta * VoBr;
			}

			Context.NoL = Context.NoL * CosAlpha + NoTr;
			Context.VoL = Context.VoL * CosAlpha + VoTr;
			float InvLenH = rsqrt( 2 + 2 * Context.VoL );
			Context.NoH = saturate( ( Context.NoL + Context.NoV ) * InvLenH );
			Context.VoH = saturate( InvLenH + InvLenH * Context.VoL );
		}
	}
}
#line 153 "/Engine/Private/BRDF.ush"
float3 Diffuse_Lambert( float3 DiffuseColor )
{
	return DiffuseColor * (1 / PI);
}


float3 Diffuse_Burley( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float FD90 = 0.5 + 2 * VoH * VoH * Roughness;
	float FdV = 1 + (FD90 - 1) * Pow5( 1 - NoV );
	float FdL = 1 + (FD90 - 1) * Pow5( 1 - NoL );
	return DiffuseColor * ( (1 / PI) * FdV * FdL );
}


float3 Diffuse_OrenNayar( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float a = Roughness * Roughness;
	float s = a;
	float s2 = s * s;
	float VoL = 2 * VoH * VoH - 1;
	float Cosri = VoL - NoV * NoL;
	float C1 = 1 - 0.5 * s2 / (s2 + 0.33);
	float C2 = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0 ? rcp( max( NoL, NoV ) ) : 1 );
	return DiffuseColor / PI * ( C1 + C2 ) * ( 1 + Roughness * 0.5 );
}


float3 Diffuse_Gotanda( float3 DiffuseColor, float Roughness, float NoV, float NoL, float VoH )
{
	float a = Roughness * Roughness;
	float a2 = a * a;
	float F0 = 0.04;
	float VoL = 2 * VoH * VoH - 1;
	float Cosri = VoL - NoV * NoL;

	float a2_13 = a2 + 1.36053;
	float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - NoV, 1 + rcp(39*a2*a2+1) ) + 1 );

	float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - Pow5( 1 - NoL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a * (NoL - 1) ) * NoL;
	float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * NoV) ) ) * ( 1 - pow( 1 - NoL, ( 1 - 0.3726732 * NoV * NoV ) / ( 0.188566 + 0.38841 * NoV ) ) );
	float Bp = Cosri < 0 ? 1.4 * NoV * NoL * Cosri : Cosri;
	float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
	return DiffuseColor / PI * Lr;
#line 206 "/Engine/Private/BRDF.ush"
}


float D_Blinn( float a2, float NoH )
{
	float n = 2 / a2 - 2;
	return (n+2) / (2*PI) * PhongShadingPow( NoH, n );
}


float D_Beckmann( float a2, float NoH )
{
	float NoH2 = NoH * NoH;
	return exp( (NoH2 - 1) / (a2 * NoH2) ) / ( PI * a2 * NoH2 * NoH2 );
}



float D_GGX( float a2, float NoH )
{
	float d = ( NoH * a2 - NoH ) * NoH + 1;
	return a2 / ( PI*d*d );
}



float D_GGXaniso( float ax, float ay, float NoH, float3 H, float3 X, float3 Y )
{
	float XoH = dot( X, H );
	float YoH = dot( Y, H );
	float d = XoH*XoH / (ax*ax) + YoH*YoH / (ay*ay) + NoH*NoH;
	return 1 / ( PI * ax*ay * d*d );
}

float Vis_Implicit()
{
	return 0.25;
}


float Vis_Neumann( float NoV, float NoL )
{
	return 1 / ( 4 * max( NoL, NoV ) );
}


float Vis_Kelemen( float VoH )
{

	return rcp( 4 * VoH * VoH + 1e-5);
}



float Vis_Schlick( float a2, float NoV, float NoL )
{
	float k = sqrt(a2) * 0.5;
	float Vis_SchlickV = NoV * (1 - k) + k;
	float Vis_SchlickL = NoL * (1 - k) + k;
	return 0.25 / ( Vis_SchlickV * Vis_SchlickL );
}



float Vis_Smith( float a2, float NoV, float NoL )
{
	float Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
	float Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
	return rcp( Vis_SmithV * Vis_SmithL );
}



float Vis_SmithJointApprox( float a2, float NoV, float NoL )
{
	float a = sqrt(a2);
	float Vis_SmithV = NoL * ( NoV * ( 1 - a ) + a );
	float Vis_SmithL = NoV * ( NoL * ( 1 - a ) + a );
	return 0.5 * rcp( Vis_SmithV + Vis_SmithL );
}

float3 F_None( float3 SpecularColor )
{
	return SpecularColor;
}


float3 F_Schlick( float3 SpecularColor, float VoH )
{
	float Fc = Pow5( 1 - VoH );



	return saturate( 50.0 * SpecularColor.g ) * Fc + (1 - Fc) * SpecularColor;

}

float3 F_Fresnel( float3 SpecularColor, float VoH )
{
	float3 SpecularColorSqrt = sqrt( clamp( float3(0, 0, 0), float3(0.99, 0.99, 0.99), SpecularColor ) );
	float3 n = ( 1 + SpecularColorSqrt ) / ( 1 - SpecularColorSqrt );
	float3 g = sqrt( n*n + VoH*VoH - 1 );
	return 0.5 * Square( (g - VoH) / (g + VoH) ) * ( 1 + Square( ((g+VoH)*VoH - 1) / ((g-VoH)*VoH + 1) ) );
}








Texture2D PreIntegratedGF;
SamplerState PreIntegratedGFSampler;


float3  EnvBRDF(  float3  SpecularColor,  float  Roughness,  float  NoV )
{

	float2 AB = Texture2DSampleLevel( PreIntegratedGF, PreIntegratedGFSampler, float2( NoV, Roughness ), 0 ).rg;


	float3 GF = SpecularColor * AB.x + saturate( 50.0 * SpecularColor.g ) * AB.y;
	return GF;
}

float3  EnvBRDFApprox(  float3  SpecularColor,  float  Roughness,  float  NoV )
{


	const  float4  c0 = { -1, -0.0275, -0.572, 0.022 };
	const  float4  c1 = { 1, 0.0425, 1.04, -0.04 };
	float4  r = Roughness * c0 + c1;
	float  a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
	float2  AB =  float2 ( -1.04, 1.04 ) * a004 + r.zw;



	AB.y *= saturate( 50.0 * SpecularColor.g );

	return SpecularColor * AB.x + AB.y;
}

float  EnvBRDFApproxNonmetal(  float  Roughness,  float  NoV )
{

	const  float2  c0 = { -1, -0.0275 };
	const  float2  c1 = { 1, 0.0425 };
	float2  r = Roughness * c0 + c1;
	return min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
}


float D_InvBlinn( float a2, float NoH )
{
	float A = 4;
	float Cos2h = NoH * NoH;
	float Sin2h = 1 - Cos2h;

	return rcp( PI * (1 + A*a2) ) * ( 1 + A * exp( -Cos2h / a2 ) );
}

float D_InvBeckmann( float a2, float NoH )
{
	float A = 4;
	float Cos2h = NoH * NoH;
	float Sin2h = 1 - Cos2h;
	float Sin4h = Sin2h * Sin2h;
	return rcp( PI * (1 + A*a2) * Sin4h ) * ( Sin4h + A * exp( -Cos2h / (a2 * Sin2h) ) );
}

float D_InvGGX( float a2, float NoH )
{
	float A = 4;
	float d = ( NoH - a2 * NoH ) * NoH + a2;
	return rcp( PI * (1 + A*a2) ) * ( 1 + 4 * a2*a2 / ( d*d ) );
}

float Vis_Cloth( float NoV, float NoL )
{
	return rcp( 4 * ( NoL + NoV - NoL * NoV ) );
}
#line 10 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 1 "ReflectionEnvironmentShared.ush"
#line 13 "/Engine/Private/ReflectionEnvironmentShared.ush"
float  ComputeReflectionCaptureMipFromRoughness( float  Roughness,  float  CubemapMaxMip)
{



	float  LevelFrom1x1 =  1  -  1.2  * log2(Roughness);
	return CubemapMaxMip - 1 - LevelFrom1x1;
}

float ComputeReflectionCaptureRoughnessFromMip(float Mip,  float  CubemapMaxMip)
{
	float LevelFrom1x1 = CubemapMaxMip - 1 - Mip;
	return exp2( (  1  - LevelFrom1x1 ) /  1.2  );
}



float3 GetSkyLightReflection(float3 ReflectionVector, float Roughness, out float OutSkyAverageBrightness)
{
	float AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness, ReflectionStruct_SkyLightParameters.x);
	float3 Reflection = TextureCubeSampleLevel(ReflectionStruct_SkyLightCubemap, ReflectionStruct_SkyLightCubemapSampler, ReflectionVector, AbsoluteSpecularMip).rgb;

	OutSkyAverageBrightness = ReflectionStruct_SkyLightCubemapBrightness * Luminance( View_SkyLightColor.rgb );
	return Reflection * View_SkyLightColor.rgb;
}

float3 GetSkyLightReflectionSupportingBlend(float3 ReflectionVector, float Roughness, out float OutSkyAverageBrightness)
{
	float3 Reflection = GetSkyLightReflection(ReflectionVector, Roughness, OutSkyAverageBrightness);

	[branch]
	if (ReflectionStruct_SkyLightParameters.w > 0)
	{
		float AbsoluteSpecularMip = ComputeReflectionCaptureMipFromRoughness(Roughness, ReflectionStruct_SkyLightParameters.x);
		float3 BlendDestinationReflection = TextureCubeSampleLevel(ReflectionStruct_SkyLightBlendDestinationCubemap, ReflectionStruct_SkyLightBlendDestinationCubemapSampler, ReflectionVector, AbsoluteSpecularMip).rgb;

		Reflection = lerp(Reflection, BlendDestinationReflection * View_SkyLightColor.rgb, ReflectionStruct_SkyLightParameters.w);
	}

	return Reflection;
}
#line 59 "/Engine/Private/ReflectionEnvironmentShared.ush"
float3 GetSkySHDiffuse(float3 Normal)
{
	float4 NormalVector = float4(Normal, 1);

	float3 Intermediate0, Intermediate1, Intermediate2;
	Intermediate0.x = dot(View_SkyIrradianceEnvironmentMap[0], NormalVector);
	Intermediate0.y = dot(View_SkyIrradianceEnvironmentMap[1], NormalVector);
	Intermediate0.z = dot(View_SkyIrradianceEnvironmentMap[2], NormalVector);

	float4 vB = NormalVector.xyzz * NormalVector.yzzx;
	Intermediate1.x = dot(View_SkyIrradianceEnvironmentMap[3], vB);
	Intermediate1.y = dot(View_SkyIrradianceEnvironmentMap[4], vB);
	Intermediate1.z = dot(View_SkyIrradianceEnvironmentMap[5], vB);

	float vC = NormalVector.x * NormalVector.x - NormalVector.y * NormalVector.y;
	Intermediate2 = View_SkyIrradianceEnvironmentMap[6].xyz * vC;


	return max(0, Intermediate0 + Intermediate1 + Intermediate2);
}
#line 85 "/Engine/Private/ReflectionEnvironmentShared.ush"
float3 GetSkySHDiffuseSimple(float3 Normal)
{
	float4 NormalVector = float4(Normal, 1);

	float3 Intermediate0;
	Intermediate0.x = dot(View_SkyIrradianceEnvironmentMap[0], NormalVector);
	Intermediate0.y = dot(View_SkyIrradianceEnvironmentMap[1], NormalVector);
	Intermediate0.z = dot(View_SkyIrradianceEnvironmentMap[2], NormalVector);


	return max(0, Intermediate0);
}



float3 GetOffSpecularPeakReflectionDir(float3 Normal, float3 ReflectionVector, float Roughness)
{
	float a = Square(Roughness);
	return lerp( Normal, ReflectionVector, (1 - a) * ( sqrt(1 - a) + a ) );
}

float GetSpecularOcclusion(float NoV, float RoughnessSq, float AO)
{
	return saturate( pow( NoV + AO, RoughnessSq ) - 1 + AO );
}

float3 GetLookupVectorForBoxCapture(float3 ReflectionVector, float3 WorldPosition, float4 BoxCapturePositionAndRadius, float4x4 BoxTransform, float4 BoxScales, float3 LocalCaptureOffset, out float DistanceAlpha)
{

	float3 LocalRayStart = mul(float4(WorldPosition, 1), BoxTransform).xyz;
	float3 LocalRayDirection = mul(float4(ReflectionVector, 0), BoxTransform).xyz;

	float3 InvRayDir = rcp(LocalRayDirection);


	float3 FirstPlaneIntersections = -InvRayDir - LocalRayStart * InvRayDir;

	float3 SecondPlaneIntersections = InvRayDir - LocalRayStart * InvRayDir;

	float3 FurthestPlaneIntersections = max(FirstPlaneIntersections, SecondPlaneIntersections);


	float Intersection = min(FurthestPlaneIntersections.x, min(FurthestPlaneIntersections.y, FurthestPlaneIntersections.z));


	float3 IntersectPosition = WorldPosition + Intersection * ReflectionVector;
	float3 ProjectedCaptureVector = IntersectPosition - (BoxCapturePositionAndRadius.xyz + LocalCaptureOffset);




	float BoxDistance = ComputeDistanceFromBoxToPoint(-(BoxScales.xyz - .5f * BoxScales.w), BoxScales.xyz - .5f * BoxScales.w, LocalRayStart * BoxScales.xyz);


	DistanceAlpha = 1.0 - smoothstep(0, .7f * BoxScales.w, BoxDistance);

	return ProjectedCaptureVector;
}

float3 GetLookupVectorForSphereCapture(float3 ReflectionVector, float3 WorldPosition, float4 SphereCapturePositionAndRadius, float NormalizedDistanceToCapture, float3 LocalCaptureOffset, inout float DistanceAlpha)
{
	float3 ProjectedCaptureVector = ReflectionVector;
	float ProjectionSphereRadius = SphereCapturePositionAndRadius.w;
	float SphereRadiusSquared = ProjectionSphereRadius * ProjectionSphereRadius;

	float3 LocalPosition = WorldPosition - SphereCapturePositionAndRadius.xyz;
	float LocalPositionSqr = dot(LocalPosition, LocalPosition);


	float3 QuadraticCoef;
	QuadraticCoef.x = 1;
	QuadraticCoef.y = dot(ReflectionVector, LocalPosition);
	QuadraticCoef.z = LocalPositionSqr - SphereRadiusSquared;

	float Determinant = QuadraticCoef.y * QuadraticCoef.y - QuadraticCoef.z;


	[flatten]
	if (Determinant >= 0)
	{
		float FarIntersection = sqrt(Determinant) - QuadraticCoef.y;

		float3 LocalIntersectionPosition = LocalPosition + FarIntersection * ReflectionVector;
		ProjectedCaptureVector = LocalIntersectionPosition - LocalCaptureOffset;



		float x = saturate( 2.5 * NormalizedDistanceToCapture - 1.5 );
		DistanceAlpha = 1 - x*x*(3 - 2*x);
	}
	return ProjectedCaptureVector;
}

float ComputeMixingWeight(float IndirectIrradiance, float AverageBrightness, float Roughness)
{

	float MixingAlpha = smoothstep(0, 1, saturate(Roughness * View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.x + View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.y));





	float MixingWeight = IndirectIrradiance / max(AverageBrightness, .0001f);

	MixingWeight = min(MixingWeight, View_ReflectionEnvironmentRoughnessMixingScaleBiasAndLargestWeight.z);

	return lerp(1.0f, MixingWeight, MixingAlpha);
}
#line 11 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 1 "SkyLightingShared.ush"
#line 7 "/Engine/Private/SkyLightingShared.ush"
float ApproximateConeConeIntersection(float ArcLength0, float ArcLength1, float AngleBetweenCones)
{
	float AngleDifference = abs(ArcLength0 - ArcLength1);

	float Intersection = smoothstep(
		0,
		1.0,
		1.0 - saturate((AngleBetweenCones - AngleDifference) / (ArcLength0 + ArcLength1 - AngleDifference)));

	return Intersection;
}

float ApplyBentNormalAO;
float InvSkySpecularOcclusionStrength;
float4 OcclusionTintAndMinOcclusion;

void GetDistanceFieldAOSpecularOcclusion(float3 BentNormalAO, float3 ReflectionVector, float Roughness, bool bTwoSidedFoliage, out float IndirectSpecularOcclusion, out float IndirectDiffuseOcclusion, out float3 ExtraIndirectSpecular)
{
	IndirectSpecularOcclusion = 1;
	IndirectDiffuseOcclusion = 1;
	ExtraIndirectSpecular = 0;

	[branch]
	if (ApplyBentNormalAO > 0)
	{
		float BentNormalLength = length(BentNormalAO);

		[branch]
		if (View_DistanceFieldAOSpecularOcclusionMode == 0)
		{
			IndirectSpecularOcclusion = BentNormalLength;
		}
		else
		{
			[branch]
			if (bTwoSidedFoliage)
			{
				IndirectSpecularOcclusion = BentNormalLength;
			}
			else
			{
				float ReflectionConeAngle = max(Roughness, .1f) * PI;
				float UnoccludedAngle = BentNormalLength * PI * InvSkySpecularOcclusionStrength;
				float AngleBetween = acos(dot(BentNormalAO, ReflectionVector) / max(BentNormalLength, .001f));
				IndirectSpecularOcclusion = ApproximateConeConeIntersection(ReflectionConeAngle, UnoccludedAngle, AngleBetween);


				IndirectSpecularOcclusion = lerp(0, IndirectSpecularOcclusion, saturate((UnoccludedAngle - .1f) / .2f));
			}
		}

		IndirectSpecularOcclusion = lerp(IndirectSpecularOcclusion, 1, OcclusionTintAndMinOcclusion.w);
		ExtraIndirectSpecular = (1 - IndirectSpecularOcclusion) * OcclusionTintAndMinOcclusion.xyz;
		IndirectDiffuseOcclusion = lerp(BentNormalLength, 1, OcclusionTintAndMinOcclusion.w);
	}
}

float GetDynamicSkyIndirectIrradiance(float3 BentNormal, float3 WorldNormal)
{
	float SkyVisibility = length(BentNormal);
	float3 DiffuseLookup = GetSkySHDiffuse(WorldNormal) * View_SkyLightColor.rgb;
	return Luminance(DiffuseLookup) * SkyVisibility;
}
#line 12 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 1 "DistanceFieldAOShared.ush"
#line 28 "/Engine/Private/DistanceFieldAOShared.ush"
float AOObjectMaxDistance;
float AOStepScale;
float AOStepExponentScale;
float AOMaxViewDistance;

float AOGlobalMaxOcclusionDistance;


float GetAOMaxDistance()
{
	return max(AOObjectMaxDistance, AOGlobalMaxOcclusionDistance);
}







float GetStepOffset(float StepIndex)
{



	float temp = AOStepExponentScale * StepIndex;
	return AOStepScale * (temp * temp + 1);
}

uint2 TileListGroupSize;

Texture2D DistanceFieldNormalTexture;
SamplerState DistanceFieldNormalSampler;

float4 EncodeDownsampledGBuffer(FGBufferData GBufferData, float SceneDepth)
{
	return float4(GBufferData.WorldNormal.xyz, SceneDepth);
}

void GetDownsampledGBuffer(float2 ScreenUV, out float3 OutNormal, out float OutDepth)
{
	float4 TextureValue = Texture2DSampleLevel(DistanceFieldNormalTexture, DistanceFieldNormalSampler, ScreenUV, 0);
	OutNormal = TextureValue.xyz;
	OutDepth = TextureValue.w;
}

float GetDownsampledDepth(float2 ScreenUV)
{
	return abs(Texture2DSampleLevel(DistanceFieldNormalTexture, DistanceFieldNormalSampler, ScreenUV, 0).w);
}

uint CurrentLevelDownsampleFactor;
float2 AOBufferSize;

uint DownsampleFactorToBaseLevel;
float2 BaseLevelTexelSize;

Texture2D BentNormalAOTexture;
SamplerState BentNormalAOSampler;
#line 90 "/Engine/Private/DistanceFieldAOShared.ush"
Texture2D IrradianceTexture;
SamplerState IrradianceSampler;

bool SphereIntersectCone(float4 SphereCenterAndRadius, float3 ConeVertex, float3 ConeAxis, float ConeAngleCos, float ConeAngleSin)
{
	float3 U = ConeVertex - (SphereCenterAndRadius.w / ConeAngleSin) * ConeAxis;
	float3 D = SphereCenterAndRadius.xyz - U;
	float DSizeSq = dot(D, D);
	float E = dot(ConeAxis, D);

	if (E > 0 && E * E >= DSizeSq * ConeAngleCos * ConeAngleCos)
	{
		D = SphereCenterAndRadius.xyz - ConeVertex;
		DSizeSq = dot(D, D);
		E = -dot(ConeAxis, D);

		if (E > 0 && E * E >= DSizeSq * ConeAngleSin * ConeAngleSin)
		{
			return DSizeSq <= SphereCenterAndRadius.w * SphereCenterAndRadius.w;
		}
		else
		{
			return true;
		}
	}

	return false;
}

bool SphereIntersectConeWithDepthRanges(float4 SphereCenterAndRadius, float3 ConeVertex, float3 ConeAxis, float ConeAngleCos, float ConeAngleSin, float4 ConeAxisDepthRanges)
{
	if (SphereIntersectCone(SphereCenterAndRadius, ConeVertex, ConeAxis, ConeAngleCos, ConeAngleSin))
	{
		float ConeAxisDistance = dot(SphereCenterAndRadius.xyz - ConeVertex, ConeAxis);
		float2 ConeAxisDistanceMinMax = float2(ConeAxisDistance + SphereCenterAndRadius.w, ConeAxisDistance - SphereCenterAndRadius.w);

		if (ConeAxisDistanceMinMax.x > ConeAxisDepthRanges.x && ConeAxisDistanceMinMax.y < ConeAxisDepthRanges.y
			|| ConeAxisDistanceMinMax.x > ConeAxisDepthRanges.z && ConeAxisDistanceMinMax.y < ConeAxisDepthRanges.w)
		{
			return true;
		}
	}

	return false;
}

Buffer<float> RecordConeVisibility;
float BentNormalNormalizeFactor;

void FindBestAxisVectors2(float3 InZAxis, out float3 OutXAxis, out float3 OutYAxis )
{
	float3 UpVector = abs(InZAxis.z) < 0.999 ? float3(0,0,1) : float3(1,0,0);
	OutXAxis = normalize( cross( UpVector, InZAxis ) );
	OutYAxis = cross( InZAxis, OutXAxis );
}

float3 ComputeBentNormal(float3 RecordWorldNormal, uint RelativeRecordIndex)
{
	float3 TangentX;
	float3 TangentY;
	FindBestAxisVectors2(RecordWorldNormal, TangentX, TangentY);

	float3 UnoccludedDirection = 0;

	for (uint ConeIndex = 0; ConeIndex <  9 ; ConeIndex++)
	{
		float3 ConeDirection = AOSamples2_SampleDirections[ConeIndex].xyz;
		float3 RotatedConeDirection = ConeDirection.x * TangentX + ConeDirection.y * TangentY + ConeDirection.z * RecordWorldNormal;

		float ConeVisibility = RecordConeVisibility[RelativeRecordIndex *  9  + ConeIndex];
		UnoccludedDirection += ConeVisibility * RotatedConeDirection;
	}

	float InvNumSamples = 1.0f / (float) 9 ;
	UnoccludedDirection = UnoccludedDirection * (BentNormalNormalizeFactor * InvNumSamples);

	return UnoccludedDirection;
}

float2 AOBufferBilinearUVMax;

float3 UpsampleDFAO(float4 UVAndScreenPos)
{

	float2 DistanceFieldUVs = UVAndScreenPos.xy - View_ViewRectMin.xy * View_BufferSizeAndInvSize.zw;
	DistanceFieldUVs = min(DistanceFieldUVs, AOBufferBilinearUVMax);



	float2 LowResBufferSize = floor(View_BufferSizeAndInvSize.xy /  2 );
	float2 LowResTexelSize = 1.0f / LowResBufferSize;
	float2 Corner00UV = floor(DistanceFieldUVs * LowResBufferSize - .5f) / LowResBufferSize + .5f * LowResTexelSize;
	float2 BilinearWeights = (DistanceFieldUVs - Corner00UV) * LowResBufferSize;

	float4 TextureValues00 = Texture2DSampleLevel(BentNormalAOTexture, BentNormalAOSampler, Corner00UV, 0);
	float4 TextureValues10 = Texture2DSampleLevel(BentNormalAOTexture, BentNormalAOSampler, Corner00UV + float2(LowResTexelSize.x, 0), 0);
	float4 TextureValues01 = Texture2DSampleLevel(BentNormalAOTexture, BentNormalAOSampler, Corner00UV + float2(0, LowResTexelSize.y), 0);
	float4 TextureValues11 = Texture2DSampleLevel(BentNormalAOTexture, BentNormalAOSampler, Corner00UV + LowResTexelSize, 0);

	float4 CornerWeights = float4(
		(1 - BilinearWeights.y) * (1 - BilinearWeights.x),
		(1 - BilinearWeights.y) * BilinearWeights.x,
		BilinearWeights.y * (1 - BilinearWeights.x),
		BilinearWeights.y * BilinearWeights.x);

	float Epsilon = .0001f;

	float4 CornerDepths = float4(TextureValues00.w, TextureValues10.w, TextureValues01.w, TextureValues11.w);
	float SceneDepth = CalcSceneDepth(UVAndScreenPos.xy);
	float4 DepthWeights = 1.0f / (abs(CornerDepths - SceneDepth.xxxx) + Epsilon);
	float4 FinalWeights = CornerWeights * DepthWeights;

	float InvWeight = 1.0f / dot(FinalWeights, 1);

	float3 InterpolatedResult =
		(FinalWeights.x * TextureValues00.xyz
			+ FinalWeights.y * TextureValues10.xyz
			+ FinalWeights.z * TextureValues01.xyz
			+ FinalWeights.w * TextureValues11.xyz)
		* InvWeight;

	float3 BentNormal = InterpolatedResult.xyz;
#line 218 "/Engine/Private/DistanceFieldAOShared.ush"
	return BentNormal;
}
#line 238 "/Engine/Private/DistanceFieldAOShared.ush"
uint2 ScreenGridConeVisibilitySize;
float2 JitterOffset;

uint2 ComputeTileCoordinateFromScreenGrid(uint2 OutputCoordinate)
{
	uint2 TileCoordinate = OutputCoordinate *  1  /  4 ;
	return TileCoordinate;
}

float2 GetBaseLevelScreenUVFromScreenGrid(uint2 OutputCoordinate, float JitterScale)
{
	float2 BaseLevelScreenUV = (OutputCoordinate *  1  + JitterOffset * JitterScale + float2(.5f, .5f)) * BaseLevelTexelSize;
	return BaseLevelScreenUV;
}

float2 GetBaseLevelScreenUVFromScreenGrid(uint2 OutputCoordinate)
{
	return GetBaseLevelScreenUVFromScreenGrid(OutputCoordinate, 1);
}

float2 GetScreenUVFromScreenGrid(uint2 OutputCoordinate, float JitterScale)
{
	float2 ScreenUV = ((OutputCoordinate *  1  + JitterOffset * JitterScale) *  2  + View_ViewRectMin.xy + float2(.5f, .5f)) * View_BufferSizeAndInvSize.zw;
	return ScreenUV;
}

float2 GetScreenUVFromScreenGrid(uint2 OutputCoordinate)
{
	return GetScreenUVFromScreenGrid(OutputCoordinate, 1);
}

Buffer<uint> CulledTilesStartOffsetArray;
#line 13 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 1 "ShadingModels.ush"
#line 5 "/Engine/Private/ShadingModels.ush"
#line 1 "DeferredShadingCommon.ush"
#line 6 "/Engine/Private/ShadingModels.ush"
#line 1 "BRDF.ush"
#line 7 "/Engine/Private/ShadingModels.ush"
#line 8 "/Engine/Private/ShadingModels.ush"
#line 1 "CapsuleLight.ush"
#line 5 "/Engine/Private/CapsuleLight.ush"
float SmoothMin( float a, float b, float k )
{
	float h = saturate( 0.5 + (0.5 / k) * (b - a) );
	return lerp( b, a, h ) - k * (h - h*h);
}

float SmoothMax( float a, float b, float k )
{
	return SmoothMin( a, b, -k );
}

float SmoothClamp( float x, float Min, float Max, float k )
{
	return SmoothMin( SmoothMax( x, Min, k ), Max, k );

}

struct FCapsuleLight
{
	float3 LightPos[2];
	float Length;
	float Radius;
	float SoftRadius;
	float DistBiasSqr;
};

void ClipToHorizon( inout float3 Line0, inout float3 Line1, float3 N )
{
	float NoP0 = dot( N, Line0 );
	float NoP1 = dot( N, Line1 );
	if( NoP0 < 0 ) Line0 = ( Line0 * NoP1 - Line1 * NoP0 ) / ( NoP1 - NoP0 );
	if( NoP1 < 0 ) Line1 = ( -Line0 * NoP1 + Line1 * NoP0 ) / ( -NoP1 + NoP0 );
}


float3 ClosestPointLineToPoint( float3 Line0, float3 Line1, float Length )
{
	float3 Line01 = Line1 - Line0;
	return Line0 + Line01 * saturate( -dot( Line01, Line0 ) / Pow2( Length ) );

}


float3 ClosestPointLineToRay( float3 Line0, float3 Line1, float Length, float3 R )
{
	float3 L0 = Line0;
	float3 L1 = Line1;
	float3 Line01 = Line1 - Line0;


	float A = Square( Length );
	float B = dot( R, Line01 );
	float t = saturate( dot( Line0, B*R - Line01 ) / (A - B*B) );

	return Line0 + t * Line01;
}

float3 SmallestAnglePointOnLineToRay( float3 Line0, float3 Line1, float Length, float3 R )
{
	float3 L0 = Line0;
	float3 L1 = Line1;
	float3 Line01 = Line1 - Line0;

	float A = Square( Length );
	float B = 2 * dot( Line0, Line01 );
	float C = dot( Line0, Line0 );
	float D = dot( R, Line0 );
	float E = dot( R, Line01 );
	float t = saturate( (B*D - 2*C*E) / (B*E - 2*A*D) );

	return Line0 + t * Line01;
}

float3 LineIrradiance( float3 N, float3 Line0, float3 Line1, float DistanceBiasSqr, out float CosSubtended, out float BaseIrradiance, out float NoL )
{
	float LengthSqr0 = dot( Line0, Line0 );
	float LengthSqr1 = dot( Line1, Line1 );
	float InvLength0 = rsqrt( LengthSqr0 );
	float InvLength1 = rsqrt( LengthSqr1 );
	float InvLength01 = InvLength0 * InvLength1;

	CosSubtended = dot( Line0, Line1 ) * InvLength01;
	BaseIrradiance = InvLength01 / ( CosSubtended * 0.5 + 0.5 + DistanceBiasSqr * InvLength01 );
	NoL = 0.5 * ( dot(N, Line0) * InvLength0 + dot(N, Line1) * InvLength1 );

	float3 VectorIrradiance = ( BaseIrradiance * 0.5 ) * ( Line0 * InvLength0 + Line1 * InvLength1 );
	return VectorIrradiance;
}


float SphereHorizonCosWrap( float NoL, float SinAlphaSqr )
{

	float SinAlpha = sqrt( SinAlphaSqr );

	if( NoL < SinAlpha )
	{
		NoL = max( NoL, -SinAlpha );
#line 120 "/Engine/Private/CapsuleLight.ush"
		NoL = Pow2( SinAlpha + NoL ) / ( 4 * SinAlpha );

	}
#line 127 "/Engine/Private/CapsuleLight.ush"
	return NoL;
}
#line 9 "/Engine/Private/ShadingModels.ush"
#line 1 "RectLight.ush"
#line 7 "/Engine/Private/RectLight.ush"
#line 1 "MonteCarlo.ush"
#line 12 "/Engine/Private/MonteCarlo.ush"
float3x3 GetTangentBasis( float3 TangentZ )
{
	const float Sign = TangentZ.z >= 0 ? 1 : -1;
	const float a = -rcp( Sign + TangentZ.z );
	const float b = TangentZ.x * TangentZ.y * a;

	float3 TangentX = { 1 + Sign * a * Pow2( TangentZ.x ), Sign * b, -Sign * TangentZ.x };
	float3 TangentY = { b, Sign + a * Pow2( TangentZ.y ), -TangentZ.y };

	return float3x3( TangentX, TangentY, TangentZ );
}

float3 TangentToWorld( float3 Vec, float3 TangentZ )
{
	return mul( Vec, GetTangentBasis( TangentZ ) );
}

float3 WorldToTangent(float3 Vec, float3 TangentZ)
{
	return mul(GetTangentBasis(TangentZ), Vec);
}

float2 Hammersley( uint Index, uint NumSamples, uint2 Random )
{
	float E1 = frac( (float)Index / NumSamples + float( Random.x & 0xffff ) / (1<<16) );
	float E2 = float( ReverseBits32(Index) ^ Random.y ) * 2.3283064365386963e-10;
	return float2( E1, E2 );
}

float2 Hammersley16( uint Index, uint NumSamples, uint2 Random )
{
	float E1 = frac( (float)Index / NumSamples + float( Random.x ) * (1.0 / 65536.0) );
	float E2 = float( ( ReverseBits32(Index) >> 16 ) ^ Random.y ) * (1.0 / 65536.0);
	return float2( E1, E2 );
}


float2 R2Sequence( uint Index )
{
	const float Phi = 1.324717957244746;
	const float2 a = float2( 1.0 / Phi, 1.0 / Pow2(Phi) );
	return frac( a * Index );
}



float2 JitteredR2( uint Index, uint NumSamples, float2 Jitter, float JitterAmount = 0.5 )
{
	const float Phi = 1.324717957244746;
	const float2 a = float2( 1.0 / Phi, 1.0 / Pow2(Phi) );
	const float d0 = 0.76;
	const float i0 = 0.7;

	return frac( a * Index + ( JitterAmount * 0.5 * d0 * sqrt(PI) * rsqrt( NumSamples ) ) * Jitter );
}


float2 JitteredR2( uint Index, float2 Jitter, float JitterAmount = 0.5 )
{
	const float Phi = 1.324717957244746;
	const float2 a = float2( 1.0 / Phi, 1.0 / Pow2(Phi) );
	const float d0 = 0.76;
	const float i0 = 0.7;

	return frac( a * Index + ( JitterAmount * 0.25 * d0 * sqrt(PI) * rsqrt( Index - i0 ) ) * Jitter );
}
#line 97 "/Engine/Private/MonteCarlo.ush"
uint2 SobolPixel(uint2 Pixel)
{

	int3 SobolLo = int3(Pixel & 0xfu, 0);
	int3 SobolHi = int3((Pixel >> 4u) & 0xfu, 0) + int3(16, 0, 0);
	uint Packed = View_SobolSamplingTexture.Load(SobolLo) ^ View_SobolSamplingTexture.Load(SobolHi);
	return uint2(Packed, Packed << 8u) & 0xff00u;
}






uint2 SobolIndex(uint2 Base, int Index, int Bits = 10)
{
	uint2 SobolNumbers[10] = {
		uint2(0x8680u, 0x4c80u), uint2(0xf240u, 0x9240u), uint2(0x8220u, 0x0e20u), uint2(0x4110u, 0x1610u), uint2(0xa608u, 0x7608u),
		uint2(0x8a02u, 0x280au), uint2(0xe204u, 0x9e04u), uint2(0xa400u, 0x4682u), uint2(0xe300u, 0xa74du), uint2(0xb700u, 0x9817u),
	};

	uint2 Result = Base;
	[unroll]  for (int b = 0; b < 10 && b < Bits; ++b)
	{
		Result ^= (Index & (1 << b)) ? SobolNumbers[b] : 0;
	}
	return Result;
}


uint2 ComputePixelUniqueSobolRandSample(uint2 PixelCoord)
{
	const uint TemporalBits = 10;
	uint FrameIndexMod1024 = ReverseBitsN(GetPowerOfTwoModulatedFrameIndex(1 << TemporalBits), TemporalBits);

	uint2 SobolBase = SobolPixel(PixelCoord);
	return SobolIndex(SobolBase, FrameIndexMod1024, TemporalBits);
}




float2 UniformSampleDisk( float2 E )
{
	float Theta = 2 * PI * E.x;
	float Radius = sqrt( E.y );
	return Radius * float2( cos( Theta ), sin( Theta ) );
}

float2 UniformSampleDiskConcentric( float2 E )
{
	float2 p = 2 * E - 1;
	float Radius;
	float Phi;
	if( abs( p.x ) > abs( p.y ) )
	{
		Radius = p.x;
		Phi = (PI/4) * (p.y / p.x);
	}
	else
	{
		Radius = p.y;
		Phi = (PI/2) - (PI/4) * (p.x / p.y);
	}
	return float2( Radius * cos( Phi ), Radius * sin( Phi ) );
}



float2 UniformSampleDiskConcentricApprox( float2 E )
{
	float2 sf = E * sqrt(2.0) - sqrt(0.5);
	float2 sq = sf*sf;
	float root = sqrt(2.0*max(sq.x, sq.y) - min(sq.x, sq.y));
	if (sq.x > sq.y)
	{
		sf.x = sf.x > 0 ? root : -root;
	}
	else
	{
		sf.y = sf.y > 0 ? root : -root;
	}
	return sf;
}

float4 UniformSampleSphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = 1 - 2 * E.y;
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float PDF = 1.0 / (4 * PI);

	return float4( H, PDF );
}

float4 UniformSampleHemisphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = E.y;
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float PDF = 1.0 / (2 * PI);

	return float4( H, PDF );
}

float4 CosineSampleHemisphere( float2 E )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = sqrt( E.y );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float PDF = CosTheta * (1.0 / PI);

	return float4( H, PDF );
}

float4 CosineSampleHemisphere( float2 E, float3 N )
{
	float3 H = UniformSampleSphere( E ).xyz;
	H = normalize( N + H );

	float PDF = H.z * (1.0 / PI);

	return float4( H, PDF );
}

float4 UniformSampleCone( float2 E, float CosThetaMax )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = lerp( CosThetaMax, 1, E.y );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 L;
	L.x = SinTheta * cos( Phi );
	L.y = SinTheta * sin( Phi );
	L.z = CosTheta;

	float PDF = 1.0 / ( 2 * PI * (1 - CosThetaMax) );

	return float4( L, PDF );
}

float4 ImportanceSampleBlinn( float2 E, float a2 )
{
	float n = 2 / a2 - 2;

	float Phi = 2 * PI * E.x;
	float CosTheta = ClampedPow( E.y, 1 / (n + 1) );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float D = (n+2) / (2*PI) * ClampedPow( CosTheta, n );
	float PDF = D * CosTheta;

	return float4( H, PDF );
}

float4 ImportanceSampleGGX( float2 E, float a2 )
{
	float Phi = 2 * PI * E.x;
	float CosTheta = sqrt( (1 - E.y) / ( 1 + (a2 - 1) * E.y ) );
	float SinTheta = sqrt( 1 - CosTheta * CosTheta );

	float3 H;
	H.x = SinTheta * cos( Phi );
	H.y = SinTheta * sin( Phi );
	H.z = CosTheta;

	float d = ( CosTheta * a2 - CosTheta ) * CosTheta + 1;
	float D = a2 / ( PI*d*d );
	float PDF = D * CosTheta;

	return float4( H, PDF );
}




float4 ImportanceSampleVisibleGGX( float2 E, float a2, float3 V )
{

	float a = sqrt(a2);


	float3 Vh = normalize( float3( a * V.xy, V.z ) );


	float3 Tangent0 = (Vh.z < 0.9999) ? normalize( cross( float3(0, 0, 1), Vh ) ) : float3(1, 0, 0);
	float3 Tangent1 = cross( Vh, Tangent0 );

	float Radius = sqrt( E.x );
	float Phi = 2 * PI * E.y;

	float2 p = Radius * float2( cos( Phi ), sin( Phi ) );
	float s = 0.5 + 0.5 * Vh.z;
	p.y = (1 - s) * sqrt( 1 - p.x * p.x ) + s * p.y;

	float3 H;
	H = p.x * Tangent0;
	H += p.y * Tangent1;
	H += sqrt( saturate( 1 - dot( p, p ) ) ) * Vh;


	H = normalize( float3( a * H.xy, max(0.0, H.z) ) );

	float NoV = V.z;
	float NoH = H.z;
	float VoH = dot(V, H);

	float d = (NoH * a2 - NoH) * NoH + 1;
	float D = a2 / (PI*d*d);

	float G_SmithV = 2 * NoV / (NoV + sqrt(NoV * (NoV - NoV * a2) + a2));

	float PDF = G_SmithV * VoH * D / NoV;

	return float4(H, PDF);
}



float MISWeight( uint Num, float PDF, uint OtherNum, float OtherPDF )
{
	float Weight = Num * PDF;
	float OtherWeight = OtherNum * OtherPDF;
	return Weight * Weight / (Weight * Weight + OtherWeight * OtherWeight);
}
#line 8 "/Engine/Private/RectLight.ush"









struct FRect
{
	float3 Origin;
	float3x3 Axis;
	float2 Extent;
	float2 FullExtent;
	float2 Offset;
};


struct FRectTexture
{
#line 43 "/Engine/Private/RectLight.ush"
	Texture2D SourceTexture;
#line 48 "/Engine/Private/RectLight.ush"
};

FRectTexture InitRectTexture(Texture2D SourceTexture)
{
	FRectTexture Output;
#line 67 "/Engine/Private/RectLight.ush"
	Output.SourceTexture = SourceTexture;
#line 72 "/Engine/Private/RectLight.ush"
	return Output;
}

float3 SampleRectTextureInternal(Texture2D RectSourceTexture, float2 RectUV, float Level, bool bIsReference)
{
	float2 TextureSize;
	RectSourceTexture.GetDimensions( TextureSize.x, TextureSize.y );
    Level += log2(max(TextureSize.x, TextureSize.y)) - 2;
	return RectSourceTexture.SampleLevel( View_SharedTrilinearClampedSampler, RectUV, bIsReference ? 0 : Level ).rgb;
}


float3 SampleRectTexture(FRectTexture RectTexture, float2 RectUV, float Level, bool bIsReference=false)
{
#line 100 "/Engine/Private/RectLight.ush"
	return SampleRectTextureInternal(RectTexture.SourceTexture, RectUV, Level, bIsReference);
#line 105 "/Engine/Private/RectLight.ush"
}


float3 RectIrradianceLambert( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{







	float3 LocalPosition;
	LocalPosition.x = dot( Rect.Axis[0], Rect.Origin );
	LocalPosition.y = dot( Rect.Axis[1], Rect.Origin );
	LocalPosition.z = dot( Rect.Axis[2], Rect.Origin );


	float x0 = LocalPosition.x - Rect.Extent.x;
	float x1 = LocalPosition.x + Rect.Extent.x;
	float y0 = LocalPosition.y - Rect.Extent.y;
	float y1 = LocalPosition.y + Rect.Extent.y;
	float z0 = LocalPosition.z;
	float z0Sqr = z0 * z0;


	float3 v0 = float3( x0, y0, z0 );
	float3 v1 = float3( x1, y0, z0 );
	float3 v2 = float3( x1, y1, z0 );
	float3 v3 = float3( x0, y1, z0 );

	float3 L0 = v0 * rsqrt( dot( v0.xy, v0.xy ) + z0Sqr );
	float3 L1 = v1 * rsqrt( dot( v1.xy, v1.xy ) + z0Sqr );
	float3 L2 = v2 * rsqrt( dot( v2.xy, v2.xy ) + z0Sqr );
	float3 L3 = v3 * rsqrt( dot( v3.xy, v3.xy ) + z0Sqr );
#line 152 "/Engine/Private/RectLight.ush"
	float c01 = dot( L0, L1 );
	float c12 = dot( L1, L2 );
	float c23 = dot( L2, L3 );
	float c30 = dot( L3, L0 );
#line 172 "/Engine/Private/RectLight.ush"
	float w01 = ( 1.5708 - 0.175 * c01 ) * rsqrt( c01 + 1 );
	float w12 = ( 1.5708 - 0.175 * c12 ) * rsqrt( c12 + 1 );
	float w23 = ( 1.5708 - 0.175 * c23 ) * rsqrt( c23 + 1 );
	float w30 = ( 1.5708 - 0.175 * c30 ) * rsqrt( c30 + 1 );










	float3 L;
	L = cross( L1, -w01 * L0 + w12 * L2 );
	L += cross( L3, w30 * L0 + -w23 * L2 );




	L = L.x * Rect.Axis[0] + L.y * Rect.Axis[1] + L.z * Rect.Axis[2];

	float LengthSqr = dot( L, L );
	float InvLength = rsqrt( LengthSqr );
	float Length = LengthSqr * InvLength;


	L *= InvLength;

	BaseIrradiance = 0.5 * Length;




	float SinAlphaSqr = BaseIrradiance * (1.0 / PI);

	NoL = SphereHorizonCosWrap( dot( N, L ), SinAlphaSqr );

	return L;
}

float3 RectIrradianceApproxKaris( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{
	float2 RectLocal;
	RectLocal.x = SmoothClamp( dot( Rect.Axis[0], -Rect.Origin ), -Rect.Extent.x, Rect.Extent.x, 16 );
	RectLocal.y = SmoothClamp( dot( Rect.Axis[1], -Rect.Origin ), -Rect.Extent.y, Rect.Extent.y, 16 );

	float3 ClosestPoint = Rect.Origin;
	ClosestPoint += Rect.Axis[0] * RectLocal.x;
	ClosestPoint += Rect.Axis[1] * RectLocal.y;

	float3 OppositePoint = 2 * Rect.Origin - ClosestPoint;

	float3 L0 = normalize( ClosestPoint );
	float3 L1 = normalize( OppositePoint );
	float3 L = normalize( L0 + L1 );


	float Distance = dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], L );
	float DistanceSqr = Distance * Distance;



	BaseIrradiance = 4 * Rect.Extent.x * Rect.Extent.y * rsqrt( ( (4 / PI) * Square( Rect.Extent.x ) + DistanceSqr ) * ( (4 / PI) * Square( Rect.Extent.y ) + DistanceSqr ) );
	BaseIrradiance *= saturate( dot( Rect.Axis[2], L ) );




	float SinAlphaSqr = BaseIrradiance * (1.0 / PI);

	NoL = SphereHorizonCosWrap( dot( N, L ), SinAlphaSqr );

	return L;
}

float3 RectIrradianceApproxLagarde( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{
	float3 L = normalize( Rect.Origin );

	float3 v0 = Rect.Origin - Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y;
	float3 v1 = Rect.Origin + Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y;
	float3 v2 = Rect.Origin + Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y;
	float3 v3 = Rect.Origin - Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y;

	float3 n0 = normalize( cross( v0, v1 ) );
	float3 n1 = normalize( cross( v1, v2 ) );
	float3 n2 = normalize( cross( v2, v3 ) );
	float3 n3 = normalize( cross( v3, v0 ) );

	float g0 = acos( dot( n0, n1 ) );
	float g1 = acos( dot( n1, n2 ) );
	float g2 = acos( dot( n2, n3 ) );
	float g3 = acos( dot( n3, n0 ) );


	BaseIrradiance = g0 + g1 + g2 + g3 - 2*PI;

	NoL = 0.2 * ( saturate( dot( N, L ) ) +
		saturate( dot( N, normalize(v0) ) ) +
		saturate( dot( N, normalize(v1) ) ) +
		saturate( dot( N, normalize(v2) ) ) +
		saturate( dot( N, normalize(v3) ) ) );

	return L;
}

float3 RectIrradianceApproxDrobot( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{
#line 295 "/Engine/Private/RectLight.ush"
	float clampCosAngle = 0.001 + saturate( dot( N, Rect.Axis[2] ) );

	float3 d0 = normalize( -Rect.Axis[2] + N * clampCosAngle );

	float3 d1 = normalize( N - Rect.Axis[2] * clampCosAngle );
	float3 dh = normalize( d0 + d1 );



	float3 PointOnPlane = dh * ( dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], dh ) );

	float3 ClosestPoint = Rect.Origin;
	ClosestPoint += Rect.Axis[0] * clamp( dot( Rect.Axis[0], PointOnPlane - Rect.Origin ), -Rect.Extent.x, Rect.Extent.x );
	ClosestPoint += Rect.Axis[1] * clamp( dot( Rect.Axis[1], PointOnPlane - Rect.Origin ), -Rect.Extent.y, Rect.Extent.y );

	float3 v0 = Rect.Origin - Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y;
	float3 v1 = Rect.Origin + Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y;
	float3 v2 = Rect.Origin + Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y;
	float3 v3 = Rect.Origin - Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y;

	float3 n0 = normalize( cross( v0, v1 ) );
	float3 n1 = normalize( cross( v1, v2 ) );
	float3 n2 = normalize( cross( v2, v3 ) );
	float3 n3 = normalize( cross( v3, v0 ) );

	float g0 = acos( dot( n0, n1 ) );
	float g1 = acos( dot( n1, n2 ) );
	float g2 = acos( dot( n2, n3 ) );
	float g3 = acos( dot( n3, n0 ) );

	float SolidAngle = g0 + g1 + g2 + g3 - 2*PI;

	float3 L = normalize( ClosestPoint );
#line 340 "/Engine/Private/RectLight.ush"
	BaseIrradiance = SolidAngle;
	NoL = saturate( dot( N, L ) );

	return L;
}


float3 SampleSourceTexture( float3 L, FRect Rect, FRectTexture RectTexture)
{


	L += Rect.Axis[2] * saturate( 0.001 - dot( Rect.Axis[2], L ) );


	float DistToPlane = dot( Rect.Axis[2], Rect.Origin ) / dot( Rect.Axis[2], L );
	float3 PointOnPlane = L * DistToPlane;

	float2 PointInRect;
	PointInRect.x = dot( Rect.Axis[0], PointOnPlane - Rect.Origin );
	PointInRect.y = dot( Rect.Axis[1], PointOnPlane - Rect.Origin );


    float2 RectUV = (PointInRect + Rect.Offset) / Rect.FullExtent * float2(0.5, -0.5) + 0.5;

	float Level = log2( DistToPlane * rsqrt( Rect.FullExtent.x * Rect.FullExtent.y ) );

    return SampleRectTexture(RectTexture, RectUV, Level);
#line 370 "/Engine/Private/RectLight.ush"
}

float IntegrateEdge( float3 L0, float3 L1 )
{
	float c01 = dot( L0, L1 );
#line 387 "/Engine/Private/RectLight.ush"
	float w01 = ( 0.8543985 + (0.4965155 + 0.0145206 * abs(c01)) * abs(c01) ) /
				( 3.4175940 + (4.1616724 + abs(c01)) * abs(c01) );

	w01 = c01 > 0 ? w01 : 0.5 * rsqrt( 1 - c01 * c01 ) - w01;


	return w01;
}


float3 PolygonIrradiance( float3 Poly[4] )
{
	float3 L0 = normalize( Poly[0] );
	float3 L1 = normalize( Poly[1] );
	float3 L2 = normalize( Poly[2] );
	float3 L3 = normalize( Poly[3] );









	float w01 = IntegrateEdge( L0, L1 );
	float w12 = IntegrateEdge( L1, L2 );
	float w23 = IntegrateEdge( L2, L3 );
	float w30 = IntegrateEdge( L3, L0 );








	float3 L;
	L = cross( L1, -w01 * L0 + w12 * L2 );
	L += cross( L3, w30 * L0 + -w23 * L2 );




	return L;
}


Texture2D LTCMatTexture;
SamplerState LTCMatSampler;
Texture2D LTCAmpTexture;
SamplerState LTCAmpSampler;



float3 RectGGXApproxLTC( float Roughness, float3 SpecularColor,  float3  N, float3 V, FRect Rect, FRectTexture RectTexture )
{

	if (Rect.Extent.x == 0 || Rect.Extent.y == 0) return 0;

	float NoV = saturate( abs( dot(N, V) ) + 1e-5 );

	float2 UV = float2( Roughness, sqrt( 1 - NoV ) );
	UV = UV * (63.0 / 64.0) + (0.5 / 64.0);

	float4 LTCMat = LTCMatTexture.SampleLevel( LTCMatSampler, UV, 0 );
	float4 LTCAmp = LTCAmpTexture.SampleLevel( LTCAmpSampler, UV, 0 );

	float3x3 LTC = {
		float3( LTCMat.x, 0, LTCMat.z ),
		float3( 0, 1, 0 ),
		float3( LTCMat.y, 0, LTCMat.w )
	};

	float LTCDet = LTCMat.x * LTCMat.w - LTCMat.y * LTCMat.z;

	float4 InvLTCMat = LTCMat / LTCDet;
	float3x3 InvLTC = {
		float3( InvLTCMat.w, 0,-InvLTCMat.z ),
		float3( 0, 1, 0 ),
		float3(-InvLTCMat.y, 0, InvLTCMat.x )
	};


	float3 T1 = normalize( V - N * dot( N, V ) );
	float3 T2 = cross( N, T1 );
	float3x3 TangentBasis = float3x3( T1, T2, N );

	LTC = mul( LTC, TangentBasis );
	InvLTC = mul( transpose( TangentBasis ), InvLTC );

	float3 Poly[4];
	Poly[0] = mul( LTC, Rect.Origin - Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y );
	Poly[1] = mul( LTC, Rect.Origin + Rect.Axis[0] * Rect.Extent.x - Rect.Axis[1] * Rect.Extent.y );
	Poly[2] = mul( LTC, Rect.Origin + Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y );
	Poly[3] = mul( LTC, Rect.Origin - Rect.Axis[0] * Rect.Extent.x + Rect.Axis[1] * Rect.Extent.y );


	float3 L = PolygonIrradiance( Poly );

	float LengthSqr = dot( L, L );
	float InvLength = rsqrt( LengthSqr );
	float Length = LengthSqr * InvLength;


	L *= InvLength;




	float SinAlphaSqr = Length;

	float NoL = SphereHorizonCosWrap( L.z, SinAlphaSqr );
	float Irradiance = SinAlphaSqr * NoL;


	Irradiance = -min(-Irradiance, 0.0);
#line 514 "/Engine/Private/RectLight.ush"
	SpecularColor = LTCAmp.y + ( LTCAmp.x - LTCAmp.y ) * SpecularColor;


	L = mul( InvLTC, L );

	float3 LightColor = SampleSourceTexture( L, Rect, RectTexture );

	return LightColor * Irradiance * SpecularColor;
}




struct FSphericalRect
{
	float3x3 Axis;

	float x0;
	float x1;
	float y0;
	float y1;
	float z0;

	float b0;
	float b1;
	float k;
	float SolidAngle;
};


FSphericalRect BuildSphericalRect( FRect Rect )
{
	FSphericalRect SphericalRect;

	SphericalRect.Axis = Rect.Axis;

	float3 LocalPosition;
	LocalPosition.x = dot( Rect.Axis[0], Rect.Origin );
	LocalPosition.y = dot( Rect.Axis[1], Rect.Origin );
	LocalPosition.z = dot( Rect.Axis[2], Rect.Origin );

	SphericalRect.x0 = LocalPosition.x - Rect.Extent.x;
	SphericalRect.x1 = LocalPosition.x + Rect.Extent.x;
	SphericalRect.y0 = LocalPosition.y - Rect.Extent.y;
	SphericalRect.y1 = LocalPosition.y + Rect.Extent.y;
	SphericalRect.z0 = -abs( LocalPosition.z );

	SphericalRect.Axis[2] *= LocalPosition.z > 0 ? -1 : 1;

	float3 v0 = float3( SphericalRect.x0, SphericalRect.y0, SphericalRect.z0 );
	float3 v1 = float3( SphericalRect.x1, SphericalRect.y0, SphericalRect.z0 );
	float3 v2 = float3( SphericalRect.x1, SphericalRect.y1, SphericalRect.z0 );
	float3 v3 = float3( SphericalRect.x0, SphericalRect.y1, SphericalRect.z0 );

	float3 n0 = normalize( cross( v0, v1 ) );
	float3 n1 = normalize( cross( v1, v2 ) );
	float3 n2 = normalize( cross( v2, v3 ) );
	float3 n3 = normalize( cross( v3, v0 ) );

	float g0 = acos( -dot( n0, n1 ) );
	float g1 = acos( -dot( n1, n2 ) );
	float g2 = acos( -dot( n2, n3 ) );
	float g3 = acos( -dot( n3, n0 ) );

	SphericalRect.b0 = n0.z;
	SphericalRect.b1 = n2.z;

	SphericalRect.k = 2*PI - g2 - g3;
	SphericalRect.SolidAngle = g0 + g1 - SphericalRect.k;

	return SphericalRect;
}

float3 UniformSampleSphericalRect( float2 E, FSphericalRect Rect )
{
	float au = E.x * Rect.SolidAngle + Rect.k;
	float fu = ( cos(au) * Rect.b0 - Rect.b1 ) / sin(au);
	float cu = rsqrt( fu*fu + Rect.b0 * Rect.b0 ) * ( fu > 0 ? 1 : -1 );
	cu = clamp(cu, -1, 1);

	float xu = -(cu * Rect.z0) * rsqrt(1 - cu*cu);
	xu = clamp( xu, Rect.x0, Rect.x1 );

	float d = sqrt( xu*xu + Rect.z0 * Rect.z0 );
	float h0 = Rect.y0 * rsqrt( d*d + Rect.y0 * Rect.y0 );
	float h1 = Rect.y1 * rsqrt( d*d + Rect.y1 * Rect.y1 );
	float hv = h0 + E.y * (h1 - h0);
	float yv = (hv*hv < 1 - 1e-6) ? (hv * d) * rsqrt( 1 - hv*hv ) : Rect.y1;

	return mul( float3( xu, yv, Rect.z0 ), Rect.Axis );
}

float3 RectIrradianceRef( float3 N, FRect Rect, out float BaseIrradiance, out float NoL )
{
	FSphericalRect SphericalRect = BuildSphericalRect( Rect );

	const uint NumSamples = 32;

	float3 L = 0;
	NoL = 0;

	[loop]
	for( uint i = 0; i < NumSamples; i++ )
	{
		float2 E = Hammersley( i, NumSamples, 0 );
		float3 Ls = normalize( UniformSampleSphericalRect( E, SphericalRect ) );

		L += Ls;
		NoL += saturate( dot(N, Ls) );
	}

	BaseIrradiance = SphericalRect.SolidAngle;
	NoL /= NumSamples;

	return normalize(L);
}

FRect GetRect(
	float3 ToLight,
	float3 LightDataDirection,
	float3 LightDataTangent,
	float LightDataSourceRadius,
	float LightDataSourceLength,
	float LightDataRectLightBarnCosAngle,
	float LightDataRectLightBarnLength,
	bool bComputeVisibleRect)
{

	FRect Rect;
	Rect.Origin = ToLight;
	Rect.Axis[1] = LightDataTangent;
	Rect.Axis[2] = LightDataDirection;
	Rect.Axis[0] = cross( Rect.Axis[1], Rect.Axis[2] );
	Rect.Extent = float2(LightDataSourceRadius, LightDataSourceLength);
	Rect.FullExtent = Rect.Extent;
	Rect.Offset = 0;
#line 671 "/Engine/Private/RectLight.ush"
	if (bComputeVisibleRect && LightDataRectLightBarnCosAngle > 0.035f)
	{
		const float3 LightNormal =-Rect.Axis[2];
		const float3 LightdPdv =-Rect.Axis[1];
		const float3 LightdPdu =-Rect.Axis[0];
		const float2 LightExtent = float2(LightDataSourceRadius, LightDataSourceLength);
		const float BarnLength = LightDataRectLightBarnLength;


		const float3 S_World = -ToLight;
		float3 S_Light = float3(dot(S_World, LightdPdu), dot(S_World, LightdPdv), dot(S_World, LightNormal));




		const float CosTheta = LightDataRectLightBarnCosAngle;
		const float SinTheta = sqrt(1 - max(0, CosTheta * CosTheta));
		const float BarnDepth = min(S_Light.z, CosTheta * BarnLength);
		const float S_ratio = BarnDepth / (CosTheta * BarnLength);
		const float D_B = SinTheta * BarnLength * S_ratio;


		const float2 SignS = sign(S_Light.xy);
		S_Light.xy = float2(SignS.x, SignS.y) * max(abs(S_Light.xy), LightExtent + D_B.xx);


		const float3 C = float3(SignS.x * (LightExtent.x + D_B), SignS.y * (LightExtent.y + D_B), BarnDepth);



		const float3 SProj = S_Light - C;
		const float CosEta = max(SProj.z, 0);
		const float2 SinEta = abs(SProj.xy);
		const float2 TanEta = CosEta > 0.001f ? abs(SProj.xy)/CosEta : 10000.f;
		const float2 D_S = BarnDepth * TanEta;




		float2 MinMaxX = float2(-LightExtent.x, LightExtent.x);
		float2 MinMaxY = float2(-LightExtent.y, LightExtent.y);
		MinMaxX += (D_S.x - D_B) * float2(max(0, -SignS.x), -max(0, SignS.x));
		MinMaxY += (D_S.y - D_B) * float2(max(0, -SignS.y), -max(0, SignS.y));
		MinMaxX = clamp(MinMaxX, -LightExtent.x, LightExtent.x);
		MinMaxY = clamp(MinMaxY, -LightExtent.y, LightExtent.y);

		const float2 RectOffset = 0.5f * float2(MinMaxX.x + MinMaxX.y, MinMaxY.x + MinMaxY.y);

		Rect.Extent = 0.5f * float2(MinMaxX.y - MinMaxX.x, MinMaxY.y - MinMaxY.x);
		Rect.Origin = Rect.Origin + LightdPdu * RectOffset.x + LightdPdv * RectOffset.y;
		Rect.Offset = -RectOffset;
		Rect.FullExtent = LightExtent;
	}

	return Rect;
}
#line 10 "/Engine/Private/ShadingModels.ush"
#line 1 "TransmissionCommon.ush"
#line 7 "/Engine/Private/TransmissionCommon.ush"
#line 1 "SubsurfaceProfileCommon.ush"
#line 31 "/Engine/Private/SubsurfaceProfileCommon.ush"
Texture2D SSProfilesTexture;
#line 8 "/Engine/Private/TransmissionCommon.ush"

SamplerState TransmissionProfilesLinearSampler;

struct FTransmissionProfileParams
{
	float ExtinctionScale;
	float NormalScale;
	float ScatteringDistribution;
	float OneOverIOR;
};

FTransmissionProfileParams GetTransmissionProfileParams(FGBufferData GBufferData)
{
	FTransmissionProfileParams Result;


	uint SubsurfaceProfileInt = ExtractSubsurfaceProfileInt(GBufferData);


	float4 Data =  SSProfilesTexture .Load(int3( ( 0 +1) , SubsurfaceProfileInt, 0));

	Result.ExtinctionScale = Data.x;
	Result.NormalScale = Data.y;
	Result.ScatteringDistribution = Data.z;
	Result.OneOverIOR = Data.w;

	return Result;
}

float4 GetTransmissionProfile(FGBufferData GBufferData, float Thickness)
{

	uint SubsurfaceProfileInt = ExtractSubsurfaceProfileInt(GBufferData);
	float3 TextureSize;
	SSProfilesTexture .GetDimensions(0, TextureSize.x, TextureSize.y,TextureSize.z);
	float2 uv = float2(( ( ( ( ( ( 0 +1) +1) +1) +1) + ( 13 + 9 + 6 ) )  + Thickness /  5.0f  * ( 32 -1) + 0.5f), SubsurfaceProfileInt + 0.5f) / (TextureSize.xy);
	return Texture2DSampleLevel( SSProfilesTexture , TransmissionProfilesLinearSampler, uv, 0);
}

float EncodeThickness(float Thickness)
{
	return 1 - Thickness;
}

float DecodeThickness(float Thickness)
{
	return 1 - Thickness;
}
#line 11 "/Engine/Private/ShadingModels.ush"
#line 50 "/Engine/Private/ShadingModels.ush"
struct FAreaLight
{
	float SphereSinAlpha;
	float SphereSinAlphaSoft;
	float LineCosSubtended;

	float3 FalloffColor;

	FRect Rect;
	FRectTexture Texture;
	bool bIsRect;
};

struct FShadowTerms
{
	float SurfaceShadow;
	float TransmissionShadow;
	float TransmissionThickness;
};

float New_a2( float a2, float SinAlpha, float VoH )
{
	return a2 + 0.25 * SinAlpha * (3.0 * sqrtFast(a2) + SinAlpha) / ( VoH + 0.001 );


}

float EnergyNormalization( inout float a2, float VoH, FAreaLight AreaLight )
{
	if( AreaLight.SphereSinAlphaSoft > 0 )
	{

		a2 = saturate( a2 + Pow2( AreaLight.SphereSinAlphaSoft ) / ( VoH * 3.6 + 0.4 ) );
	}

	float Sphere_a2 = a2;
	float Energy = 1;
	if( AreaLight.SphereSinAlpha > 0 )
	{
		Sphere_a2 = New_a2( a2, AreaLight.SphereSinAlpha, VoH );
		Energy = a2 / Sphere_a2;
	}

	if( AreaLight.LineCosSubtended < 1 )
	{

		float LineCosTwoAlpha = AreaLight.LineCosSubtended;
		float LineTanAlpha = sqrt( ( 1.0001 - LineCosTwoAlpha ) / ( 1 + LineCosTwoAlpha ) );
		float Line_a2 = New_a2( Sphere_a2, LineTanAlpha, VoH );
		Energy *= sqrt( Sphere_a2 / Line_a2 );
#line 106 "/Engine/Private/ShadingModels.ush"
	}

	return Energy;
}

float3 SpecularGGX( float Roughness, float3 SpecularColor, BxDFContext Context, float NoL, FAreaLight AreaLight )
{
	float a2 = Pow4( Roughness );
	float Energy = EnergyNormalization( a2, Context.VoH, AreaLight );


	float D = D_GGX( a2, Context.NoH ) * Energy;
	float Vis = Vis_SmithJointApprox( a2, Context.NoV, NoL );
	float3 F = F_Schlick( SpecularColor, Context.VoH );

	return (D * Vis) * F;
}

float3 DualSpecularGGX(float AverageRoughness, float Lobe0Roughness, float Lobe1Roughness, float LobeMix, float3 SpecularColor, BxDFContext Context, float NoL, FAreaLight AreaLight)
{
	float AverageAlpha2 = Pow4(AverageRoughness);
	float Lobe0Alpha2 = Pow4(Lobe0Roughness);
	float Lobe1Alpha2 = Pow4(Lobe1Roughness);

	float Lobe0Energy = EnergyNormalization(Lobe0Alpha2, Context.VoH, AreaLight);
	float Lobe1Energy = EnergyNormalization(Lobe1Alpha2, Context.VoH, AreaLight);


	float D = lerp(D_GGX(Lobe0Alpha2, Context.NoH) * Lobe0Energy, D_GGX(Lobe1Alpha2, Context.NoH) * Lobe1Energy, LobeMix);
	float Vis = Vis_SmithJointApprox(AverageAlpha2, Context.NoV, NoL);
	float3 F = F_Schlick(SpecularColor, Context.VoH);

	return (D * Vis) * F;
}

struct FDirectLighting
{
	float3 Diffuse;
	float3 Specular;
	float3 Transmission;
};

FDirectLighting DefaultLitBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	BxDFContext Context;
	Init( Context, N, V, L );
	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, true );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );

	FDirectLighting Lighting;
	Lighting.Diffuse = AreaLight.FalloffColor * (Falloff * NoL) * Diffuse_Lambert( GBuffer.DiffuseColor );

	if( AreaLight.bIsRect )
		Lighting.Specular = RectGGXApproxLTC( GBuffer.Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture );
	else
		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * SpecularGGX( GBuffer.Roughness, GBuffer.SpecularColor, Context, NoL, AreaLight );

	Lighting.Transmission = 0;
	return Lighting;
}

float3 SimpleShading( float3 DiffuseColor, float3 SpecularColor, float Roughness, float3 L, float3 V,  float3  N )
{
	float3 H = normalize(V + L);
	float NoH = saturate( dot(N, H) );


	float D = D_GGX( Pow4(Roughness), NoH );
	float Vis = Vis_Implicit();
	float3 F = F_None( SpecularColor );

	return Diffuse_Lambert( DiffuseColor ) + (D * Vis) * F;
}

FDirectLighting ClearCoatBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	const float ClearCoat = GBuffer.CustomData.x;
	const float ClearCoatRoughness = max(GBuffer.CustomData.y, 0.02f);
	const float Film = 1 * ClearCoat;
	const float MetalSpec = 0.9;


	BxDFContext Context;

	float3  Nspec = N;
	float NoLSpec = NoL;

	if(  0  )
	{
		Nspec = GBuffer.WorldNormal;
	}

	Init( Context, Nspec, V, L );
	SphereMaxNoH( Context, AreaLight.SphereSinAlpha,  0  == 0 );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );
	Context.VoH = AreaLight.bIsRect ? Context.NoV : Context.VoH;

	if(  0  )
	{
		NoLSpec = saturate( Context.NoL + 1e-5 );
	}


	float F0 = 0.04;
	float Fc = Pow5( 1 - Context.VoH );
	float F = Fc + (1 - Fc) * F0;
	F *= ClearCoat;

	FDirectLighting Lighting;

	if( AreaLight.bIsRect )
	{
		Lighting.Specular = ClearCoat * RectGGXApproxLTC( ClearCoatRoughness, F0, Nspec, V, AreaLight.Rect, AreaLight.Texture );
	}
	else
	{
		float a2 = Pow4( ClearCoatRoughness );
		float Energy = EnergyNormalization( a2, Context.VoH, AreaLight );


		float D = D_GGX( a2, Context.NoH ) * Energy;
		float Vis = Vis_SmithJointApprox( a2, Context.NoV, NoLSpec );

		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoLSpec) * D * Vis * F;
	}

	if(  0  )
	{
		Init( Context, N, V, L );
		SphereMaxNoH( Context, AreaLight.SphereSinAlpha, true );
		Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );
	}

	float LayerAttenuation = (1 - F);
	Lighting.Diffuse = AreaLight.FalloffColor * (LayerAttenuation * Falloff * NoL) * Diffuse_Lambert( GBuffer.DiffuseColor );

	if( AreaLight.bIsRect )
	{
		Lighting.Specular += LayerAttenuation * RectGGXApproxLTC( GBuffer.Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture );
	}
	else
	{
		Lighting.Specular += AreaLight.FalloffColor * (LayerAttenuation * Falloff * NoL) * SpecularGGX( GBuffer.Roughness, GBuffer.SpecularColor, Context, NoL, AreaLight );
	}

	Lighting.Transmission = 0;
	return Lighting;
#line 324 "/Engine/Private/ShadingModels.ush"
}


float ApproximateHG(float cosJ, float g)
{
	float g2 = g * g;
	float gcos2 = 1.0f - (g * cosJ);
	gcos2 *= gcos2;

	const float ISO_PHASE_FUNC_Normalized = 0.5;

	return (ISO_PHASE_FUNC_Normalized * (1.0f - g2) / max( 1e-5, gcos2));
}

void GetProfileDualSpecular(FGBufferData GBuffer, out float AverageToRoughness0, out float AverageToRoughness1, out float LobeMix)
{


	uint SubsurfaceProfileInt = ExtractSubsurfaceProfileInt(GBuffer);

	float4 Data =  SSProfilesTexture .Load(int3( ( ( ( 0 +1) +1) +1) , SubsurfaceProfileInt, 0));
	AverageToRoughness0 = Data.x *  2.0f ;
	AverageToRoughness1 = Data.y *  2.0f ;
	LobeMix = Data.z;
#line 354 "/Engine/Private/ShadingModels.ush"
}

FDirectLighting SubsurfaceProfileBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	BxDFContext Context;
	Init( Context, N, V, L );
	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, true );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );

	float AverageToRoughness0;
	float AverageToRoughness1;
	float LobeMix;
	GetProfileDualSpecular(GBuffer, AverageToRoughness0, AverageToRoughness1, LobeMix);

	float AverageRoughness = GBuffer.Roughness;
	float Lobe0Roughness = max(saturate(AverageRoughness * AverageToRoughness0), 0.02f);
	float Lobe1Roughness = saturate(AverageRoughness * AverageToRoughness1);



	float Opacity = GBuffer.CustomData.a;
	Lobe0Roughness = lerp(1.0f, Lobe0Roughness, saturate(Opacity * 10.0f));
	Lobe1Roughness = lerp(1.0f, Lobe1Roughness, saturate(Opacity * 10.0f));

	FDirectLighting Lighting;
	Lighting.Diffuse = AreaLight.FalloffColor * (Falloff * NoL) * Diffuse_Burley( GBuffer.DiffuseColor, GBuffer.Roughness, Context.NoV, NoL, Context.VoH );

	if (AreaLight.bIsRect)
	{
		float3 Lobe0Specular = RectGGXApproxLTC(Lobe0Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		float3 Lobe1Specular = RectGGXApproxLTC(Lobe1Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture);
		Lighting.Specular = lerp(Lobe0Specular, Lobe1Specular, LobeMix);
	}
	else
	{
		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * DualSpecularGGX(AverageRoughness, Lobe0Roughness, Lobe1Roughness, LobeMix, GBuffer.SpecularColor, Context, NoL, AreaLight);
	}
#line 408 "/Engine/Private/ShadingModels.ush"
	Lighting.Transmission = 0;



	return Lighting;
}

FDirectLighting ClothBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	const float3 FuzzColor = saturate(GBuffer.CustomData.rgb);
	const float Cloth = saturate(GBuffer.CustomData.a);

	BxDFContext Context;
	Init( Context, N, V, L );
	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, true );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );

	float3 Spec1;
	if( AreaLight.bIsRect )
		Spec1 = RectGGXApproxLTC( GBuffer.Roughness, GBuffer.SpecularColor, N, V, AreaLight.Rect, AreaLight.Texture );
	else
		Spec1 = AreaLight.FalloffColor * (Falloff * NoL) * SpecularGGX( GBuffer.Roughness, GBuffer.SpecularColor, Context, NoL, AreaLight );


	float D2 = D_InvGGX( Pow4( GBuffer.Roughness ), Context.NoH );
	float Vis2 = Vis_Cloth( Context.NoV, NoL );
	float3 F2 = F_Schlick( FuzzColor, Context.VoH );
	float3 Spec2 = AreaLight.FalloffColor * (Falloff * NoL) * (D2 * Vis2) * F2;

	FDirectLighting Lighting;
	Lighting.Diffuse = AreaLight.FalloffColor * (Falloff * NoL) * Diffuse_Lambert( GBuffer.DiffuseColor );
	Lighting.Specular = lerp( Spec1, Spec2, Cloth );
	Lighting.Transmission = 0;
	return Lighting;
}

float Hair_g( float B, float Theta )
{
	return exp( -0.5 * Pow2( Theta ) / (B*B) ) / ( sqrt(2*PI) * B );
}

float Hair_F( float CosTheta )
{
	const float n = 1.55;
	const float F0 = Pow2( (1 - n) / (1 + n) );
	return F0 + (1 - F0) * Pow5( 1 - CosTheta );
}
#line 667 "/Engine/Private/ShadingModels.ush"
float3 HairShading( FGBufferData GBuffer, float3 L, float3 V,  float3  N, float Shadow, float Backlit, float Area, uint2 Random )
{



	float ClampedRoughness = clamp(GBuffer.Roughness, 1/255.0f, 1.0f);
#line 684 "/Engine/Private/ShadingModels.ush"
	const float VoL = dot(V,L);
	const float SinThetaL = dot(N,L);
	const float SinThetaV = dot(N,V);
	float CosThetaD = cos( 0.5 * abs( asinFast( SinThetaV ) - asinFast( SinThetaL ) ) );



	const float3 Lp = L - SinThetaL * N;
	const float3 Vp = V - SinThetaV * N;
	const float CosPhi = dot(Lp,Vp) * rsqrt( dot(Lp,Lp) * dot(Vp,Vp) + 1e-4 );
	const float CosHalfPhi = sqrt( saturate( 0.5 + 0.5 * CosPhi ) );


	float n = 1.55;

	float n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;

	float Shift = 0.035;
	float Alpha[] =
	{
		-Shift * 2,
		Shift,
		Shift * 4,
	};
	float B[] =
	{
		Area + Pow2( ClampedRoughness ),
		Area + Pow2( ClampedRoughness ) / 2,
		Area + Pow2( ClampedRoughness ) * 2,
	};

	float3 S = 0;


	if(1)
	{
		const float sa = sin( Alpha[0] );
		const float ca = cos( Alpha[0] );
		float Shift = 2*sa* ( ca * CosHalfPhi * sqrt( 1 - SinThetaV * SinThetaV ) + sa * SinThetaV );

		float Mp = Hair_g( B[0] * sqrt(2.0) * CosHalfPhi, SinThetaL + SinThetaV - Shift );
		float Np = 0.25 * CosHalfPhi;
		float Fp = Hair_F( sqrt( saturate( 0.5 + 0.5 * VoL ) ) );
		S += Mp * Np * Fp * ( GBuffer.Specular * 2 ) * lerp( 1, Backlit, saturate(-VoL) );
	}


	if(1)
	{
		float Mp = Hair_g( B[1], SinThetaL + SinThetaV - Alpha[1] );

		float a = 1 / n_prime;


		float h = CosHalfPhi * ( 1 + a * ( 0.6 - 0.8 * CosPhi ) );




		float f = Hair_F( CosThetaD * sqrt( saturate( 1 - h*h ) ) );
		float Fp = Pow2(1 - f);


		float3 Tp = pow( GBuffer.BaseColor, 0.5 * sqrt( 1 - Pow2(h * a) ) / CosThetaD );







		float Np = exp( -3.65 * CosPhi - 3.98 );

		S += Mp * Np * Fp * Tp * Backlit;
	}


	if(1)
	{
		float Mp = Hair_g( B[2], SinThetaL + SinThetaV - Alpha[2] );


		float f = Hair_F( CosThetaD * 0.5 );
		float Fp = Pow2(1 - f) * f;

		float3 Tp = pow( GBuffer.BaseColor, 0.8 / CosThetaD );



		float Np = exp( 17 * CosPhi - 16.78 );

		S += Mp * Np * Fp * Tp;
	}


	if(1)
	{

		float KajiyaDiffuse = 1 - abs( dot(N,L) );

		float3 FakeNormal = normalize( V - N * dot(V,N) );

		N = FakeNormal;


		float Wrap = 1;
		float NoL = saturate( ( dot(N, L) + Wrap ) / Square( 1 + Wrap ) );
		float DiffuseScatter = (1 / PI) * lerp( NoL, KajiyaDiffuse, 0.33 ) * GBuffer.Metallic;
		float Luma = Luminance( GBuffer.BaseColor );
		float3 ScatterTint = pow( GBuffer.BaseColor / Luma, 1 - Shadow );
		S += sqrt( GBuffer.BaseColor ) * DiffuseScatter * ScatterTint;
	}

	S = -min(-S, 0.0);

	return S;
}

FDirectLighting HairBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting;
	Lighting.Diffuse = 0;
	Lighting.Specular = 0;
	Lighting.Transmission = AreaLight.FalloffColor * Falloff * HairShading( GBuffer, L, V, N, Shadow.TransmissionShadow, 1, 0, uint2(0,0) );
	return Lighting;
}

FDirectLighting SubsurfaceBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting = DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );

	float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);
	float Opacity = GBuffer.CustomData.a;

	float3 H = normalize(V + L);



	float InScatter = pow(saturate(dot(L, -V)), 12) * lerp(3, .1f, Opacity);


	float NormalContribution = saturate(dot(N, H) * Opacity + 1 - Opacity);
	float BackScatter = GBuffer.GBufferAO * NormalContribution / (PI * 2);


	Lighting.Transmission = AreaLight.FalloffColor * ( Falloff * lerp(BackScatter, 1, InScatter) ) * SubsurfaceColor;

	return Lighting;
}

FDirectLighting TwoSidedBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting = DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );

	float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);


	float Wrap = 0.5;
	float WrapNoL = saturate( ( -dot(N, L) + Wrap ) / Square( 1 + Wrap ) );


	float VoL = dot(V, L);
	float Scatter = D_GGX( 0.6*0.6, saturate( -VoL ) );

	Lighting.Transmission = AreaLight.FalloffColor * (Falloff * WrapNoL * Scatter) * SubsurfaceColor;

	return Lighting;
}

FDirectLighting EyeBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{









	const float3 IrisNormal = OctahedronToUnitVector( GBuffer.CustomData.yz * 2 - 1 );
	const float IrisDistance = GBuffer.StoredMetallic;
	const float IrisMask = 1.0f - GBuffer.CustomData.w;





	const float3 CausticNormal = normalize(lerp(IrisNormal, -N, IrisMask*IrisDistance));


	BxDFContext Context;
	Init( Context, N, V, L );
	SphereMaxNoH( Context, AreaLight.SphereSinAlpha, false );
	Context.NoV = saturate( abs( Context.NoV ) + 1e-5 );
	Context.VoH = AreaLight.bIsRect ? Context.NoV : Context.VoH;


	float F0 = GBuffer.Specular * 0.08;
	float Fc = Pow5( 1 - Context.VoH );
	float F = Fc + (1 - Fc) * F0;

	FDirectLighting Lighting;

	if( AreaLight.bIsRect )
	{
		Lighting.Specular = RectGGXApproxLTC( GBuffer.Roughness, F0, N, V, AreaLight.Rect, AreaLight.Texture );
	}
	else
	{
		float a2 = Pow4( GBuffer.Roughness );
		float Energy = EnergyNormalization( a2, Context.VoH, AreaLight );


		float D = D_GGX( a2, Context.NoH ) * Energy;
		float Vis = Vis_SmithJointApprox( a2, Context.NoV, NoL );

		Lighting.Specular = AreaLight.FalloffColor * (Falloff * NoL) * D * Vis * F;
	}

	float IrisNoL = saturate( dot( IrisNormal, L ) );
	float Power = lerp( 12, 1, IrisNoL );
	float Caustic = 0.8 + 0.2 * ( Power + 1 ) * pow( saturate( dot( CausticNormal, L ) ), Power );
	float Iris = IrisNoL * Caustic;
	float Sclera = NoL;

	Lighting.Diffuse = 0;
	Lighting.Transmission = AreaLight.FalloffColor * ( Falloff * lerp( Sclera, Iris, IrisMask ) * (1 - F) ) * Diffuse_Lambert( GBuffer.DiffuseColor );
	return Lighting;
}

FDirectLighting PreintegratedSkinBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	FDirectLighting Lighting = DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );

	float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);
	float Opacity = GBuffer.CustomData.a;

	float3 PreintegratedBRDF = Texture2DSampleLevel(View_PreIntegratedBRDF, View_PreIntegratedBRDFSampler, float2(saturate(dot(N, L) * .5 + .5), 1 - Opacity), 0).rgb;
	Lighting.Transmission = AreaLight.FalloffColor * Falloff * PreintegratedBRDF * SubsurfaceColor;

	return Lighting;
}

FDirectLighting IntegrateBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float Falloff, float NoL, FAreaLight AreaLight, FShadowTerms Shadow )
{
	switch( GBuffer.ShadingModelID )
	{
		case  1 :
			return DefaultLitBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  2 :
			return SubsurfaceBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  3 :
			return PreintegratedSkinBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  4 :
			return ClearCoatBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  5 :
			return SubsurfaceProfileBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  6 :
			return TwoSidedBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  7 :
			return HairBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  8 :
			return ClothBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		case  9 :
			return EyeBxDF( GBuffer, N, V, L, Falloff, NoL, AreaLight, Shadow );
		default:
			return (FDirectLighting)0;
	}
}

FDirectLighting EvaluateBxDF( FGBufferData GBuffer,  float3  N,  float3  V,  float3  L, float NoL, FShadowTerms Shadow )
{
	FAreaLight AreaLight;
	AreaLight.SphereSinAlpha = 0;
	AreaLight.SphereSinAlphaSoft = 0;
	AreaLight.LineCosSubtended = 1;
	AreaLight.FalloffColor = 1;
	AreaLight.Rect = (FRect)0;
	AreaLight.bIsRect = false;
    AreaLight.Texture = InitRectTexture(LTCAmpTexture);

	return IntegrateBxDF( GBuffer, N, V, L, 1, NoL, AreaLight, Shadow );
}
#line 14 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 1 "LightGridCommon.ush"
#line 13 "/Engine/Private/LightGridCommon.ush"
struct LightGridData
{
	uint LightGridPixelSizeShift;
	float3 LightGridZParams;
	int3 CulledGridSize;
};

LightGridData GetLightGridData(uint EyeIndex)
{
	LightGridData Result;
#line 30 "/Engine/Private/LightGridCommon.ush"
		Result.LightGridPixelSizeShift = ForwardLightData_LightGridPixelSizeShift;
		Result.LightGridZParams = ForwardLightData_LightGridZParams;
		Result.CulledGridSize = ForwardLightData_CulledGridSize;
#line 44 "/Engine/Private/LightGridCommon.ush"
	return Result;
}

uint ComputeLightGridCellIndex(uint2 PixelPos, float SceneDepth, uint EyeIndex)
{
	const LightGridData GridData = GetLightGridData(EyeIndex);
	uint ZSlice = (uint)(max(0, log2(SceneDepth * GridData.LightGridZParams.x + GridData.LightGridZParams.y) * GridData.LightGridZParams.z));
	ZSlice = min(ZSlice, (uint)(GridData.CulledGridSize.z - 1));
	uint3 GridCoordinate = uint3(PixelPos >> GridData.LightGridPixelSizeShift, ZSlice);
	uint GridIndex = (GridCoordinate.z * GridData.CulledGridSize.y + GridCoordinate.y) * GridData.CulledGridSize.x + GridCoordinate.x;
	return GridIndex;
}

uint ComputeLightGridCellIndex(uint2 PixelPos, float SceneDepth)
{
	return ComputeLightGridCellIndex(PixelPos, SceneDepth, 0);
}
#line 70 "/Engine/Private/LightGridCommon.ush"
uint GetNumLocalLights(uint EyeIndex)
{



	return ForwardLightData_NumLocalLights;

}

struct FCulledLightsGridData
{
	uint NumLocalLights;
	uint DataStartIndex;
};

FCulledLightsGridData GetCulledLightsGrid(uint GridIndex, uint EyeIndex)
{
	FCulledLightsGridData Result;
#line 95 "/Engine/Private/LightGridCommon.ush"
		Result.NumLocalLights = min(ForwardLightData_NumCulledLightsGrid[GridIndex *  2  + 0], ForwardLightData_NumLocalLights);
		Result.DataStartIndex = ForwardLightData_NumCulledLightsGrid[GridIndex *  2  + 1];
#line 107 "/Engine/Private/LightGridCommon.ush"
	return Result;
}

struct FDirectionalLightData
{
	uint HasDirectionalLight;
	uint DirectionalLightShadowMapChannelMask;
	float2 DirectionalLightDistanceFadeMAD;
	float3 DirectionalLightColor;
	float3 DirectionalLightDirection;
};

FDirectionalLightData GetDirectionalLightData(uint EyeIndex)
{
	FDirectionalLightData Result;
#line 129 "/Engine/Private/LightGridCommon.ush"
		Result.HasDirectionalLight = ForwardLightData_HasDirectionalLight;
		Result.DirectionalLightShadowMapChannelMask = ForwardLightData_DirectionalLightShadowMapChannelMask;
		Result.DirectionalLightDistanceFadeMAD = ForwardLightData_DirectionalLightDistanceFadeMAD;
		Result.DirectionalLightColor = ForwardLightData_DirectionalLightColor;
		Result.DirectionalLightDirection = ForwardLightData_DirectionalLightDirection;
#line 147 "/Engine/Private/LightGridCommon.ush"
	return Result;
}

struct FLocalLightData
{
	float4 LightPositionAndInvRadius;
	float4 LightColorAndFalloffExponent;
	float4 SpotAnglesAndSourceRadiusPacked;
    float4 LightDirectionAndShadowMask;
    float4 LightTangentAndSoftSourceRadius;
};

FLocalLightData GetLocalLightData(uint GridIndex, uint EyeIndex)
{
	FLocalLightData Result;
#line 169 "/Engine/Private/LightGridCommon.ush"
		uint LocalLightIndex = ForwardLightData_CulledLightDataGrid[GridIndex];
		uint LocalLightBaseIndex = LocalLightIndex *  5 ;
		Result.LightPositionAndInvRadius = ForwardLightData_ForwardLocalLightBuffer[LocalLightBaseIndex + 0];
		Result.LightColorAndFalloffExponent = ForwardLightData_ForwardLocalLightBuffer[LocalLightBaseIndex + 1];
		Result.LightDirectionAndShadowMask = ForwardLightData_ForwardLocalLightBuffer[LocalLightBaseIndex + 2];
		Result.SpotAnglesAndSourceRadiusPacked = ForwardLightData_ForwardLocalLightBuffer[LocalLightBaseIndex + 3];
		Result.LightTangentAndSoftSourceRadius = ForwardLightData_ForwardLocalLightBuffer[LocalLightBaseIndex + 4];
#line 191 "/Engine/Private/LightGridCommon.ush"
	return Result;
}
#line 15 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 18 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
#line 1 "ReflectionEnvironmentComposite.ush"
#line 7 "/Engine/Private/ReflectionEnvironmentComposite.ush"
float3 CompositeReflectionCapturesAndSkylight(
	float CompositeAlpha,
	float3 WorldPosition,
	float3 RayDirection,
	float Roughness,
	float IndirectIrradiance,
	float IndirectSpecularOcclusion,
	float3 ExtraIndirectSpecular,
	uint NumCapturesAffectingTile,
	uint CaptureDataStartIndex,
	int SingleCaptureIndex,
	uint EyeIndex)
{
	float Mip = ComputeReflectionCaptureMipFromRoughness(Roughness, View_ReflectionCubemapMaxMip);
	float4 ImageBasedReflections = float4(0, 0, 0, CompositeAlpha);
	float2 CompositedAverageBrightness = float2(0.0f, 1.0f);




	[loop]
	for (uint TileCaptureIndex = 0; TileCaptureIndex < NumCapturesAffectingTile; TileCaptureIndex++)
	{
		[branch]
		if (ImageBasedReflections.a < 0.001)
		{
			break;
		}

	uint CaptureIndex = 0;
#line 43 "/Engine/Private/ReflectionEnvironmentComposite.ush"
			CaptureIndex = ForwardLightData_CulledLightDataGrid[CaptureDataStartIndex + TileCaptureIndex];
#line 54 "/Engine/Private/ReflectionEnvironmentComposite.ush"
		float4 CapturePositionAndRadius = ReflectionCapture_PositionAndRadius[CaptureIndex];
		float4 CaptureProperties = ReflectionCapture_CaptureProperties[CaptureIndex];

		float3 CaptureVector = WorldPosition - CapturePositionAndRadius.xyz;
		float CaptureVectorLength = sqrt(dot(CaptureVector, CaptureVector));
		float NormalizedDistanceToCapture = saturate(CaptureVectorLength / CapturePositionAndRadius.w);

		[branch]
		if (CaptureVectorLength < CapturePositionAndRadius.w)
		{
			float3 ProjectedCaptureVector = RayDirection;
			float4 CaptureOffsetAndAverageBrightness = ReflectionCapture_CaptureOffsetAndAverageBrightness[CaptureIndex];


			float DistanceAlpha = 0;
#line 95 "/Engine/Private/ReflectionEnvironmentComposite.ush"
			float CaptureArrayIndex = CaptureProperties.g;

			{
				float4 Sample = ReflectionStruct_ReflectionCubemap.SampleLevel(ReflectionStruct_ReflectionCubemapSampler, float4(ProjectedCaptureVector, CaptureArrayIndex), Mip);

				Sample.rgb *= CaptureProperties.r;
				Sample *= DistanceAlpha;


				ImageBasedReflections.rgb += Sample.rgb * ImageBasedReflections.a * IndirectSpecularOcclusion;
				ImageBasedReflections.a *= 1 - Sample.a;

				float AverageBrightness = CaptureOffsetAndAverageBrightness.w;
				CompositedAverageBrightness.x += AverageBrightness * DistanceAlpha * CompositedAverageBrightness.y;
				CompositedAverageBrightness.y *= 1 - DistanceAlpha;
			}
		}
	}
#line 157 "/Engine/Private/ReflectionEnvironmentComposite.ush"
	ImageBasedReflections.rgb *= View_IndirectLightingColorScale;
	CompositedAverageBrightness.x *= Luminance( View_IndirectLightingColorScale );



	[branch]
	if (ReflectionStruct_SkyLightParameters.y > 0)
	{
		float SkyAverageBrightness = 1.0f;


			float3 SkyLighting = GetSkyLightReflectionSupportingBlend(RayDirection, Roughness, SkyAverageBrightness);
#line 174 "/Engine/Private/ReflectionEnvironmentComposite.ush"
		bool bNormalize = ReflectionStruct_SkyLightParameters.z < 1 &&  1 ;

		[flatten]
		if (bNormalize)
		{
			ImageBasedReflections.rgb += ImageBasedReflections.a * SkyLighting * IndirectSpecularOcclusion;
			CompositedAverageBrightness.x += SkyAverageBrightness * CompositedAverageBrightness.y;
		}
		else
		{
			ExtraIndirectSpecular += SkyLighting * IndirectSpecularOcclusion;
		}
	}



	ImageBasedReflections.rgb *= ComputeMixingWeight(IndirectIrradiance, CompositedAverageBrightness.x, Roughness);


	ImageBasedReflections.rgb += ImageBasedReflections.a * ExtraIndirectSpecular;

	return ImageBasedReflections.rgb;
}

float3 CompositeReflectionCapturesAndSkylight(
	float CompositeAlpha,
	float3 WorldPosition,
	float3 RayDirection,
	float Roughness,
	float IndirectIrradiance,
	float IndirectSpecularOcclusion,
	float3 ExtraIndirectSpecular,
	uint NumCapturesAffectingTile,
	uint CaptureDataStartIndex,
	int SingleCaptureIndex)
{
	return CompositeReflectionCapturesAndSkylight(
		CompositeAlpha,
		WorldPosition,
		RayDirection,
		Roughness,
		IndirectIrradiance,
		IndirectSpecularOcclusion,
		ExtraIndirectSpecular,
		NumCapturesAffectingTile,
		CaptureDataStartIndex,
		SingleCaptureIndex,
		0);
}
#line 19 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"

float3 GatherRadiance(float CompositeAlpha, float3 WorldPosition, float3 RayDirection, float Roughness, float3 BentNormal, float IndirectIrradiance, uint ShadingModelID, uint NumCulledReflectionCaptures, uint CaptureDataStartIndex)
{

	float IndirectSpecularOcclusion = 1.0f;
	float3 ExtraIndirectSpecular = 0;
#line 33 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
	return CompositeReflectionCapturesAndSkylight(
		CompositeAlpha,
		WorldPosition,
		RayDirection,
		Roughness,
		IndirectIrradiance,
		IndirectSpecularOcclusion,
		ExtraIndirectSpecular,
		NumCulledReflectionCaptures,
		CaptureDataStartIndex,
		0);
}


Texture2D ScreenSpaceReflectionsTexture;
SamplerState ScreenSpaceReflectionsSampler;

float3 ContrastAndNormalizeMulAdd;
float OcclusionExponent;
float OcclusionCombineMode;

float3 SkyLightDiffuse(FScreenSpaceData ScreenSpaceData, float4 UVAndScreenPos, float3 BentNormal)
{
	float2 UV = UVAndScreenPos.xy;
	float3 Lighting = 0;

	FGBufferData GBuffer = ScreenSpaceData.GBuffer;

	float SkyVisibility = 1;
	float DotProductFactor = 1;
	float3 SkyLightingNormal = GBuffer.WorldNormal;
	[branch]  if( GBuffer.ShadingModelID ==  4  &&  0 )
	{
		const float2 oct1 = ((float2(GBuffer.CustomData.a, GBuffer.CustomData.z) * 2) - (256.0/255.0)) + UnitVectorToOctahedron(GBuffer.WorldNormal);
		SkyLightingNormal = OctahedronToUnitVector(oct1);
	}

	float3 DiffuseIrradiance = 0;
#line 101 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
	SkyVisibility = pow(SkyVisibility, OcclusionExponent);
	SkyVisibility = lerp(SkyVisibility, 1, OcclusionTintAndMinOcclusion.w);


	if (OcclusionCombineMode == 0)
	{

		SkyVisibility = min(SkyVisibility, min(GBuffer.GBufferAO, ScreenSpaceData.AmbientOcclusion));
	}
	else
	{

		SkyVisibility = SkyVisibility * min(GBuffer.GBufferAO, ScreenSpaceData.AmbientOcclusion);
	}

	float ScalarFactors = SkyVisibility;

	float3 DiffuseColor = GBuffer.DiffuseColor;

	[branch]
	if (GBuffer.ShadingModelID ==  6 )
	{
		float3 SubsurfaceLookup = GetSkySHDiffuse(-GBuffer.WorldNormal) * View_SkyLightColor.rgb;
		float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);
		Lighting += ScalarFactors * SubsurfaceLookup * SubsurfaceColor;
	}

	if (GBuffer.ShadingModelID ==  2  || GBuffer.ShadingModelID ==  3 )
	{
		float3 SubsurfaceColor = ExtractSubsurfaceColor(GBuffer);

		DiffuseColor += SubsurfaceColor;
	}

	[branch]
	if (GBuffer.ShadingModelID ==  7 )
	{
		float3 N = GBuffer.WorldNormal;
		float3 V = -normalize(mul(float4(UVAndScreenPos.zw, 1, 0), View_ScreenToWorld).xyz);
		float3 L = normalize(V - N * dot(V, N));
		SkyLightingNormal = L;
		DiffuseColor = PI * HairShading(GBuffer, L, V, N, 1, 0, 0.2, uint2(0, 0));
	}

	if (GBuffer.ShadingModelID ==  8 )
	{
		DiffuseColor += GBuffer.CustomData.rgb * GBuffer.CustomData.a;
	}


	float3 DiffuseLookup = GetSkySHDiffuse(SkyLightingNormal) * View_SkyLightColor.rgb;



	Lighting += ((ScalarFactors * DotProductFactor) * DiffuseLookup + (1 - SkyVisibility) * OcclusionTintAndMinOcclusion.xyz) * DiffuseColor;

	Lighting += DiffuseIrradiance * GBuffer.DiffuseColor * (GBuffer.GBufferAO * ScreenSpaceData.AmbientOcclusion);
#line 170 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
	return Lighting;
}


float3 SpecularBounce(FScreenSpaceData ScreenSpaceData, float4 UVAndScreenPos)
{
	float2 UV = UVAndScreenPos.xy;

	FGBufferData GBuffer = ScreenSpaceData.GBuffer;

	float3 ScreenVector = normalize(mul(float4(UVAndScreenPos.zw, 1, 0), View_ScreenToWorld).xyz);

	float3 N = GBuffer.WorldNormal;
	float3 V = -ScreenVector;

	float NoV = saturate(dot(N, V));

	GBuffer.SpecularColor = EnvBRDFApprox(GBuffer.SpecularColor, GBuffer.Roughness, NoV);

	return GBuffer.SpecularColor * GBuffer.IndirectIrradiance;
}

float3 ReflectionEnvironment(FScreenSpaceData ScreenSpaceData, float4 UVAndScreenPos, float4 SvPosition, float3 BentNormal)
{



	const float PreExposure = 1.f;


	float4 Color = float4(0, 0, 0, 1);

	float2 ScreenUV = UVAndScreenPos.xy;
	float2 ScreenPosition = UVAndScreenPos.zw;
	FGBufferData GBuffer = ScreenSpaceData.GBuffer;
	float SceneDepth = CalcSceneDepth(ScreenUV);

	float3 WorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View_ScreenToWorld).xyz;
	float3 CameraToPixel = normalize(WorldPosition - View_WorldCameraOrigin);
	float3 ReflectionVector = reflect(CameraToPixel, GBuffer.WorldNormal);
	float IndirectIrradiance = GBuffer.IndirectIrradiance;


	[branch]

	if (ReflectionStruct_SkyLightParameters.y > 0 && ReflectionStruct_SkyLightParameters.z > 0)
	{
		float2 ScreenUV = ScreenPosition * View_ScreenPositionScaleBias.xy + View_ScreenPositionScaleBias.wz;
		IndirectIrradiance += GetDynamicSkyIndirectIrradiance(BentNormal, GBuffer.WorldNormal);
	}



	float3 N = GBuffer.WorldNormal;
	float3 V = -CameraToPixel;
	float3 R = 2 * dot( V, N ) * N - V;
	float NoV = saturate( dot( N, V ) );


	R = GetOffSpecularPeakReflectionDir(N, R, GBuffer.Roughness);



	float4 SSR = Texture2DSample( ScreenSpaceReflectionsTexture, ScreenSpaceReflectionsSampler, ScreenUV );
	Color.rgb = SSR.rgb;
	Color.a = 1 - SSR.a;
#line 241 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
	if(GBuffer.ShadingModelID ==  4  )
	{
#line 246 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
		const float ClearCoat = GBuffer.CustomData.x;
		Color = lerp( Color, float4(0,0,0,1), ClearCoat );
#line 256 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
	}

	float AO = GBuffer.GBufferAO * ScreenSpaceData.AmbientOcclusion;
	float RoughnessSq = GBuffer.Roughness * GBuffer.Roughness;
	float SpecularOcclusion = GetSpecularOcclusion(NoV, RoughnessSq, AO);
	Color.a *= SpecularOcclusion;


	float2 LocalPosition = SvPosition.xy - View_ViewRectMin.xy;

	uint GridIndex = ComputeLightGridCellIndex(uint2(LocalPosition.x, LocalPosition.y), SceneDepth);
	uint NumCulledEntryIndex = (ForwardLightData_NumGridCells + GridIndex) *  2 ;
	uint NumCulledReflectionCaptures = min(ForwardLightData_NumCulledLightsGrid[NumCulledEntryIndex + 0], ForwardLightData_NumReflectionCaptures);
	uint DataStartIndex = ForwardLightData_NumCulledLightsGrid[NumCulledEntryIndex + 1];
#line 276 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
	Color.rgb += PreExposure * GatherRadiance(Color.a, WorldPosition, R, GBuffer.Roughness, BentNormal, IndirectIrradiance, GBuffer.ShadingModelID, NumCulledReflectionCaptures, DataStartIndex);

	[branch]
	if( GBuffer.ShadingModelID ==  4 )
	{
		const float ClearCoat = GBuffer.CustomData.x;
		const float ClearCoatRoughness = GBuffer.CustomData.y;


		float2 AB = PreIntegratedGF.SampleLevel( PreIntegratedGFSampler, float2( NoV, GBuffer.Roughness ), 0 ).rg;
		Color.rgb *= GBuffer.SpecularColor * AB.x + AB.y * saturate( 50 * GBuffer.SpecularColor.g ) * (1 - ClearCoat);


		float F = EnvBRDF( 0.04, ClearCoatRoughness, NoV ).x;

		F *= ClearCoat;

		float LayerAttenuation = (1 - F);
		Color.rgb *= LayerAttenuation;
		Color.a = F;


		Color.rgb += SSR.rgb * F;
		Color.a *= 1 - SSR.a;

		Color.a *= SpecularOcclusion;

		float3 TopLayerR = 2 * dot( V, N ) * N - V;
		Color.rgb += PreExposure * GatherRadiance(Color.a, WorldPosition, TopLayerR, ClearCoatRoughness, BentNormal, IndirectIrradiance, GBuffer.ShadingModelID, NumCulledReflectionCaptures, DataStartIndex);
#line 309 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
	}
	else
	{
		Color.rgb *= EnvBRDF( GBuffer.SpecularColor, GBuffer.Roughness, NoV );
	}


	return -min(-Color.rgb, 0.0);
}

void ReflectionEnvironmentSkyLighting(
	in noperspective float4 UVAndScreenPos : TEXCOORD0,
	in float4 SvPosition : SV_Position,
	out float4 OutColor : SV_Target0)
{
	float2 ScreenUV = UVAndScreenPos.xy;
	FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(ScreenUV);
	uint ShadingModelID = ScreenSpaceData.GBuffer.ShadingModelID;

	OutColor = 0.0f;

	float3 BentNormal = ScreenSpaceData.GBuffer.WorldNormal;
#line 335 "/Engine/Private/ReflectionEnvironmentPixelShader.usf"
	[branch]

	if (ShadingModelID > 0)
	{

		float3 SkyLighting = SkyLightDiffuse(ScreenSpaceData, UVAndScreenPos, BentNormal);


		FLightAccumulator LightAccumulator = (FLightAccumulator)0;

		const bool bNeedsSeparateSubsurfaceLightAccumulation = UseSubsurfaceProfile(ShadingModelID);

		LightAccumulator_Add(LightAccumulator, SkyLighting, SkyLighting, 1.0f, bNeedsSeparateSubsurfaceLightAccumulation);
		OutColor = LightAccumulator_GetResult(LightAccumulator);

	}

	[branch]
	if (ShadingModelID !=  0  && ShadingModelID !=  7 )
	{



		OutColor.xyz += ReflectionEnvironment(ScreenSpaceData, UVAndScreenPos, SvPosition, BentNormal);

	}
}
